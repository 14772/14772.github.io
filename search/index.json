[{"categories":["数据结构"],"contents":"[TOC]\n本系列学习笔记链接  第一章：数据结构学习(一) 第二章：数据结构学习(二) 第三章：数据结构学习(三)  数据结构——用C语言描述(三) 线性结构 限定性线性表——栈和队列 限定性：限制线性表插入和删除等运算的位置（只允许在端点位置操作）\n栈 栈的定义与实现  栈的定义：把运算位置限制在表尾端 栈顶：允许运算端 栈底：不允许运算端 栈顶指示器：用来指示动态变化的栈顶位置 空栈：表中无任何元素 满栈：无法申请到栈区可用空间 栈的常见运算：进栈（入栈）、退栈（出栈） 上溢：栈已满还入栈 下溢：栈已空还出栈 栈的特性：后进先出（Last In First Out, LIFO）  对于栈 ADT：\n数据元素：同一个数据对象的任意类型数据\n关系：栈中数据元素之间是线性关系\n有 7 种基本操作运算：\n 初始化InitStack(S) 清栈ClearStack(S) 判空IsEmpty(S) 判满IsFull(S) 进栈Push(S, x) 出栈Pop(S, x) 读栈顶GetTop(S, x)  问题  按1，2，3的顺序进栈，则出栈顺序有哪些?   答案  元素在进栈过程中也可以出栈，也就是并非所有元素全部进栈后再出栈。\n因此，出栈顺序有：123，132，213，231，321\n   栈的顺序实现  用一组连续的存储单元依次存放自栈底到栈顶的数据元素 设一个位置指针top（栈顶指针）动态指示栈顶元素在顺序栈中的位置 top = -1 表示空栈  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  #define Stack_Size 50  typedef struct { int elem[Stack_Size]; int top; } SeqStack; void InitStack(SeqStack *S) { S-\u0026gt;top = -1; } bool IsEmpty(SeqStack S) { return S.top == -1; } bool IsFull(SeqStack S) { return S.top == Stack_Size - 1; } bool push(SeqStack *S, int x) { if (IsFull(*S)) return false; S-\u0026gt;top++; S-\u0026gt;elem[S-\u0026gt;top] = x; return true; } bool pop(SeqStack *S, int *x) { if (IsEmpty(*S)) return false; *x = S-\u0026gt;elem[S-\u0026gt;top]; S-\u0026gt;top--; return true; } bool GetTop(SeqStack S, int *x) { if (IsEmpty(S)) return false; *x = S.elem[S.top]; return true; }   顺序实现的两栈共享技术 为两个栈申请一个共享的一维数组空间S[M]，将两个栈的栈底分别为一维数组的两端 0 和 M-1。\n值得注意的是，判满条件应为S-\u0026gt;top[0] + 1 == S-\u0026gt;top[1]即栈顶指示器相邻，并且一个栈空并不会影响另一个栈是否为空。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  #define M 100  typedef struct { int Stack[M]; //栈区  int top[2]; // top[0]、top[1]为两个栈顶指示器 } DqStack; void InitStack(DqStack *S) { S-\u0026gt;top[0] = -1; S-\u0026gt;top[1] = M; } bool push(DqStack *S, int x, int i) { if (S-\u0026gt;top[0] + 1 == S-\u0026gt;top[1]) return false; switch (i) { case 0: S-\u0026gt;top[0]++; S-\u0026gt;Stack[S-\u0026gt;top[0]] = x; break; case 1: S-\u0026gt;top[1]--; S-\u0026gt;Stack[S-\u0026gt;top[1]] = x; break; default: return false; } return true; } bool pop(DqStack *S, int *x, int i) { switch (i) { case 0: if (S-\u0026gt;top[0] == -1) return false; *x = S-\u0026gt;Stack[S-\u0026gt;top[0]]; S-\u0026gt;top[0]--; break; case 1: if (S-\u0026gt;top[1] == M) return false; *x = S-\u0026gt;Stack[S-\u0026gt;top[1]]; S-\u0026gt;top[1]++; break; default: return false; } return true; }   栈的链式实现  采用带头结点的单链表实现链栈 头指针就作为栈顶指针 使用完毕时应释放其空间  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  typedef struct node { int data; struct node *next; } LinkStackNode; typedef LinkStackNode *LinkStack; bool push(LinkStack top, int x) { LinkStackNode *tmp; tmp = (LinkStackNode *)malloc(sizeof(LinkStackNode)); if (tmp == NULL) return false; tmp-\u0026gt;data = x; tmp-\u0026gt;next = top-\u0026gt;next; //头插  top-\u0026gt;next = tmp; return true; } bool pop(LinkStack top, int *x) { LinkStackNode *tmp; tmp = top-\u0026gt;next; if (tmp == NULL) //栈空  return false; top-\u0026gt;next = tmp-\u0026gt;next; *x = tmp-\u0026gt;data; free(tmp); return true; }   链式实现的多栈 top[0]、top[1]、……、top[M-1]分别为 M 个栈的栈顶指针。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdbool.h\u0026gt;#define M 5  typedef struct node { int data; struct node *next; } LinkStackNode; typedef LinkStackNode *LinkStack; void InitStack(LinkStack *top) { *top = (LinkStack *)malloc(sizeof(LinkStackNode)); (*top)-\u0026gt;next = NULL; } bool push(LinkStack top, int x) { LinkStackNode *tmp; tmp = (LinkStackNode *)malloc(sizeof(LinkStackNode)); if (tmp == NULL) return false; tmp-\u0026gt;data = x; tmp-\u0026gt;next = top-\u0026gt;next; //头插  top-\u0026gt;next = tmp; return true; } bool pop(LinkStack top, int *x) { LinkStackNode *tmp; tmp = top-\u0026gt;next; if (tmp == NULL) //栈空  return false; top-\u0026gt;next = tmp-\u0026gt;next; *x = tmp-\u0026gt;data; free(tmp); return true; } int main() { LinkStack top[M]; int tmp; for (int i = 0; i \u0026lt; 5; i++) { InitStack(\u0026amp;top[i]); push(top[i], i + 1); pop(top[i], \u0026amp;tmp); printf(\u0026#34;栈%d顶元素值%d\\n\u0026#34;, i + 1, tmp); } return 0; } /* 输出： 栈1顶元素值1 栈2顶元素值2 栈3顶元素值3 栈4顶元素值4 栈5顶元素值5 */   两种存储结构的栈满  顺序栈判满与数组定义长度有关 链栈判满与可否申请系统空间有关  栈的应用与递归 括号匹配 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdbool.h\u0026gt;#include \u0026lt;ctype.h\u0026gt;#define Stack_Size 50  typedef struct { char elem[Stack_Size]; int top; } Stack; void InitStack(Stack *S) { S-\u0026gt;top = -1; } bool IsEmpty(Stack S) { return S.top == -1; } bool IsFull(Stack S) { return S.top == Stack_Size - 1; } bool push(Stack *S, char x) { if (IsFull(*S)) return false; S-\u0026gt;top++; S-\u0026gt;elem[S-\u0026gt;top] = x; return true; } bool pop(Stack *S, char *x) { if (IsEmpty(*S)) return false; *x = S-\u0026gt;elem[S-\u0026gt;top]; S-\u0026gt;top--; return true; } bool GetTop(Stack S, char *x) { if (IsEmpty(S)) return false; *x = S.elem[S.top]; return true; } int read_line(char str[], int n) { int ch, i = 0; while (isspace(ch = getchar())) ; while (ch != \u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; ch != EOF) { if (i \u0026lt; n) { str[i++] = ch; ch = getchar(); } } str[i] = \u0026#39;\\0\u0026#39;; return i; } void BracketMatch(char *str) { Stack S; int i; char ch; InitStack(\u0026amp;S); for (i = 0; str[i] != 0; i++) { switch (str[i]) { case \u0026#39;(\u0026#39;: case \u0026#39;[\u0026#39;: case \u0026#39;{\u0026#39;: push(\u0026amp;S, str[i]); break; case \u0026#39;)\u0026#39;: case \u0026#39;]\u0026#39;: case \u0026#39;}\u0026#39;: if (IsEmpty(S)) { printf(\u0026#34;右括号多余\\n\u0026#34;); return; } else { GetTop(S, \u0026amp;ch); if ((ch == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; str[i] == \u0026#39;)\u0026#39;) || (ch == \u0026#39;[\u0026#39; \u0026amp;\u0026amp; str[i] == \u0026#39;]\u0026#39;) || (ch == \u0026#39;{\u0026#39; \u0026amp;\u0026amp; str[i] == \u0026#39;}\u0026#39;)) pop(\u0026amp;S, \u0026amp;ch); else { printf(\u0026#34;对应的左右括号不同类\\n\u0026#34;); return; } } } } if (IsEmpty(S)) printf(\u0026#34;括号匹配\\n\u0026#34;); else printf(\u0026#34;左括号多余\\n\u0026#34;); } int main() { char str[50]; read_line(str, 50); BracketMatch(str); return 0; }   运行截图：\n栈与递归 递归：在定义自身的同时又出现了对自身的调用\n递归定义的数学函数：斐波那契数列\n阿克曼函数\n例如递归求解汉诺塔：\n1 2 3 4 5 6 7 8 9 10 11 12  //将A塔座上1到n编号的由小到大圆盘按规则搬到C塔座上，B柱作为辅助塔座 void Hanoi(int n, char A, char B, char C) { if (n == 1) move(A, C); else if (n \u0026gt; 1) { Hanoi(n - 1, A, C, B); move(A, C); Hanoi(n - 1, B, A, C); } }   使用递归的前提：\n 原问题可以层层分解为类似的子问题，且子问题比原问题的规模更小 规模最小的子问题具有直接解  递归过程的实现：\n 递归进程（i-\u0026gt;i+1 层）  保留本层参数与返回地址 给下层参数赋值 将程序转移到被调函数的人口   递归退程（i+1-\u0026gt;i 层）  保存被调函数的计算结果 恢复上层参数〈释放被调函数的数据区) 依照被调函数保存的返回地址，将控制转移回调用函数    而上述过程实质上是利用栈机制实现的。\n但递归算法有缺陷：\n 时间效率低 可能栈溢出。由于递归是用栈实现的，而每个进程的栈容量有限，当调用层次过多，可能发生栈溢出 部分语言不支持递归（如 basic 语言）  基此原因，我们需要消除递归：\n 第一类，简单递归问题的转换。对于尾递归、单向递归的算法，使用循环代替 第二类，基于栈的方式。将隐性栈转化为受用户控制的显性栈  信息  尾递归：递归调用语句只有一个且处于算法的最后，尾递归是单向递归的特例。   斐波那契数列的非递归实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  int fib(int n) { int x = 0, y = 1, z; if (n == 0 || n == 1) return n; else for (int i = 2; i \u0026lt;= n; i++) { z = y; y = x + y; x = z; } return y; }   循环结构表示阶乘问题的尾递归算法：\n1 2 3 4 5 6 7  long fact(int n) { int fac = 1; for (int i = 1; i \u0026lt;= n; i++) fac *= i; return fac; }   队列 队列的定义与实现  队列（Queue）定义：只允许在表的一端插人元素，而在另一端删除元素的一种限定性线性表。 队头：允许删除的一端 队尾：允许插入的一端 特性：先进先出（ Fist In Fist Out, FIFO）  对于队列 ADT：\n数据元素：同一个数据对象的任意类型数据\n关系：队列中数据元素之间是线性关系\n有 8 种基本操作运算：\n 初始化InitQueue(\u0026amp;Q) 判空IsEmpty(Q) 判满IsFull(Q) 进队EnterQueue(\u0026amp;Q, x) 出队DeleteQueue(\u0026amp;Q, \u0026amp;x) 取队头GetHead(Q, \u0026amp;x) 清队ClearQueue(\u0026amp;Q) 删除队列DestroyQueue(\u0026amp;Q)  队列的链式实现  队首指针front、队尾指针rear为队首、队尾指示器 队尾进，队首出  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  typedef struct Node { int data; struct Node *next; } LinkQueueNode; typedef struct { LinkQueueNode *front; LinkQueueNode *rear; } LinkQueue; bool InitQueue(LinkQueue *Q) { Q-\u0026gt;front = (LinkQueueNode *)malloc(sizeof(LinkQueueNode)); if (Q-\u0026gt;front != NULL) { Q-\u0026gt;rear = Q-\u0026gt;front; Q-\u0026gt;front-\u0026gt;next = NULL; return true; } else return false; } bool EnterQueue(LinkQueue *Q, int x) { LinkQueueNode *NewNode; NewNode = (LinkQueueNode *)malloc(sizeof(LinkQueueNode)); if (NewNode != NULL) { NewNode-\u0026gt;data = x; NewNode-\u0026gt;next = NULL; Q-\u0026gt;rear-\u0026gt;next = NewNode; Q-\u0026gt;rear = NewNode; return true; } return false; } bool DeleteQueue(LinkQueue *Q, int *x) { LinkQueueNode *p; if (Q-\u0026gt;front == Q-\u0026gt;rear) //空队  return false; p = Q-\u0026gt;front-\u0026gt;next; Q-\u0026gt;front-\u0026gt;next = p-\u0026gt;next; if (Q-\u0026gt;rear == p) Q-\u0026gt;rear = Q-\u0026gt;front; *x = p-\u0026gt;data; free(p); return true; }   队列的顺序存储（循环队列）  用一维数组Queue[MAXSIZE]存放从队头到队尾的元素 附设两个指针front和rear，分别指示队头元素和队尾元素在数组中的位置 由于只能在队头出队,在队尾入队，所以会产生假溢出的现象  信息  假溢出是指已经队满，但实际在队列的另一端还是有存储空间的情况。\n例如，当你想乘坐公交时，从上车车门处看见人满了，但从车窗看，发现里面还有空位，但车上的人不往里走，这就产生了所谓的假溢出现象\n   为解决假溢出，将顺序队列的数组Queue[MAXSIZE]看成一个环状的空间，即规定最后一个单元的后继为第一个单元，我们形象地称之为循环队列。\n可通过数学中的取模（求余）运算来实现循环队列rear = (rear+1) mod MAXSIZE。\n当rear+1 = MAXSIZE时，rear = O。也就是说最后一个Queue[MAXSIZE-1]的后继为Queue[0]\n 进队操作时，队尾指针的变化是rear = (rear+1) mod MAXSIZE 出队操作时，队头指针的变化是front = (front+1) mod MAXSIZE  在顺序队列中我们依靠front == rear来判断队列空，但不难看出，仅凭这一点难以判断循环队列的空满。在此，有两种解决办法：\n 损失一个元素空间，当队尾指针所指向的空单元的后继单元是队头元素所在的单元时，则停止入队。  队列满的条件为(rear+1) mod MAXSIZE == front 队列空的条件为rear == front   增设一个标志量，以区别队列是空，还是满  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  #define MAXSIZE 100  typedef struct { int front; int rear; int elem[MAXSIZE]; } SeqQueue; void InitQueue(SeqQueue *Q) { Q-\u0026gt;front = Q-\u0026gt;rear = 0; } bool EnterQueue(SeqQueue *Q,int x) { if ((Q-\u0026gt;rear + 1) % MAXSIZE == Q-\u0026gt;front) return false; Q-\u0026gt;elem[Q-\u0026gt;rear] = x; Q-\u0026gt;rear = (Q-\u0026gt;rear + 1) % MAXSIZE; return true; } bool DeleteQueue(SeqQueue *Q,int *x) { if(Q-\u0026gt;front==Q-\u0026gt;rear) return false; *x = Q-\u0026gt;elem[Q-\u0026gt;front]; Q-\u0026gt;front = (Q-\u0026gt;front + 1) % MAXSIZE; return true; }   问题  大小为 MAXSIZE 的循环队列中，f 为当前队头元素位置，为队尾元素的后一个位置，则任意时刻，队列中的元素个数为？   答案  要考虑到 r 和 f 谁更大的问题，因此要分类讨论。综合可得元素个数为 (r - f + MAXSIZE) % MAXSIZE   队列的应用 杨辉三角 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  void YangHuiTriangle(int N) { SeqQueue Q; int i, x, n, tmp; InitQueue(\u0026amp;Q); EnterQueue(\u0026amp;Q, 1); for (n = 2; n \u0026lt;= N; n++) { EnterQueue(\u0026amp;Q, 1); for (i = 1; i \u0026lt;= n - 2; i++) { DeleteQueue(\u0026amp;Q, \u0026amp;tmp); printf(\u0026#34; %d\u0026#34;, tmp); GetHead(Q, \u0026amp;x); tmp += x; EnterQueue(\u0026amp;Q, tmp); } DeleteQueue(\u0026amp;Q, \u0026amp;x); printf(\u0026#34; %d\u0026#34;, x); printf(\u0026#34;\\n\u0026#34;); EnterQueue(\u0026amp;Q, 1); } while (Q.front != Q.rear) { DeleteQueue(\u0026amp;Q, \u0026amp;x); printf(\u0026#34; %d\u0026#34;, x); } }   键盘输入循环缓冲区问题 问题描述：有两个进程同时存在于一个程序中。其中第一个进程在屏幕上连续显示字符“A”与此同时，程序不断检测键盘是否有输人，如果有的话，就读人用户输人的字符。并保存到输人缓冲区中。在用户输人时，输人的字符并不立即回显在屏幕上。当用户输人一个逗号(,)时，表示第一个进程结束，第二个进程从缓冲区中读取那些已输人的字符并显示在屏幕上。第二个进程结束后程序又进人第一个进程，重新显示字符“A”，同时用户又可以继续输人字符，直到用户输人一个分号(;)键，才结束第一个进程，同时也结束整个程序\n总结","permalink":"https://www.sukun.xyz/data_structure-3/","tags":["数据结构","学习"],"title":"数据结构学习(三)"},{"categories":["数据结构"],"contents":"本系列学习笔记链接  第一章：数据结构学习(一) 第二章：数据结构学习(二) 第三章：数据结构学习(三)  数据结构——用C语言描述(二) 线性结构 线性表 线性表定义 线性表（LinearList）：由 n 个类型相同数据元素的有限序列，记作 $$ (a_1,a_2,···,a_i,a_{i+1},···,a_n) $$ 称 n 为线性表长度，特别的，当 n = 0 时，称为空表。\n每个数据元素只有一个直接前驱和一个直接后继（首尾元素除外），即为一对一的线性关系。\n线性表特点：\n 同一性 有穷性 有序性  对于线性表 ADT：\n数据元素：同类型数据元素的集合 $$ D={ a_i|\\ a_i\\in D0,\\ i=1,2,…,n\\ n≥0 ，D0为某一数据对象} $$ 关系：有序对偶 $$ s={\u0026lt;a_i, a_{i+1}\u0026gt;|\\ a_i, a_{i+1}\\in D0,\\ i=1,2,…, n-1} $$ 有 9 种基本操作运算：\n 初始化InitList(L) 销毁DestroyList(L) 置空ClearList(L) 判空EmptyList(L) 求长度ListLength(L) 查找Locate(L, e) 存取GetData(L, i) 插入InsList(L, i, e) 删除DelList(L, i, \u0026amp;e)  线性表的顺序存储 1 2 3 4 5 6 7 8 9 10 11 12  #define MAXSIZE 100 //线性表数据类型定义 typedef struct { int elem[MAXSIZE]; //线性表占用的数组空间  int last; //线性表中最后一个元素在数组中的位置下标 } SeqList; /* 两种变量定义方式 SeqList L1 使用L1.elem[i-1]访问 SeqList *L2 使用L2-\u0026gt;elem[i-1]访问 */   查找操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  //按内容查找 int Locate(SeqList L, int e) { int i = 0; while ((i \u0026lt;= L.last) \u0026amp;\u0026amp; (L.elem[i] != 0)) i++; if (i \u0026lt;= L.last) retrun i + 1; //若找到值为e的元素，则返回其序号  else return -1; //若没找到，返回空序号 } //按序号查找 int GetData(SeqList L, int i) { if (i \u0026lt;= L.last) return L.elem[i - 1]; else { printf(\u0026#34;序号超过上限\u0026#34;); return 0; } }   插入操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  //在表的第i个位置之前插入一个新元素e int InsList(SeqList *L, int i, int e) { int k; if ((i \u0026lt; 1) || (i \u0026gt; L-\u0026gt;last + 2)) { printf(\u0026#34;插入位置i值不合法\u0026#34;); return 0; } if (L-\u0026gt;last \u0026gt;= MAXSIZE - 1) { printf(\u0026#34;表已满无法插入\u0026#34;); return 0; } for (k = L-\u0026gt;last; k \u0026gt;= i - 1; k--) L-\u0026gt;elem[k + 1] = L-\u0026gt;elem[k]; L-\u0026gt;elem[i - 1] = e; L-\u0026gt;last++; return 1; }   删除操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  //将表的第i个元素删去 int DelList(SeqList *L, int i, int *e) { int k; if ((i \u0026lt; 1) || (i \u0026gt; L-\u0026gt;last + 1)) { printf(\u0026#34;删除位置不合法！\u0026#34;); return 0; } *e = L-\u0026gt;elem[i - 1]; for (k = i; k \u0026lt;= L-\u0026gt;last; k++) L-\u0026gt;elem[k - 1] = L-\u0026gt;elem[k]; L-\u0026gt;last--; return 1; }   顺序表合并算法 有两个顺序表 LA 和 LB，其元素均为递增有序排列，编写算法，将两个有序表合并成一个递增有序的顺序表 LC。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  void merg(SeqList *LA, SeqList *LB, SeqList *LC) { int i, j, k; i = 0; j = 0; k = 0; while (i \u0026lt;= LA-\u0026gt;last \u0026amp;\u0026amp; j \u0026lt;= LB-\u0026gt;last) if (LA-\u0026gt;elem[i] \u0026lt;= LB-\u0026gt;elem[j]) { LC-\u0026gt;elem[k] = LA-\u0026gt;elem[i]; i++; k++; } else { LC-\u0026gt;elem[k] = LB-\u0026gt;elem[j]; j++; k++; } while (i \u0026lt;= LA-\u0026gt;last) //表A长于表B  { LC-\u0026gt;elem[k] = LA-\u0026gt;elem[i]; i++; k++; } while (j \u0026lt;= LB-\u0026gt;last) //表B长于表A  { LC-\u0026gt;elem[k] = LB-\u0026gt;elem[j]; j++; k++; } LC-\u0026gt;last = LA-\u0026gt;last + LB-\u0026gt;last + 1; }   比较循环的时间复杂度为 $$ O(LA-\u0026gt;last+LB-\u0026gt;last) $$ 复制循环时间复杂度为 $$ O(max(LA-\u0026gt;last,LB-\u0026gt;last)) $$\n顺序表优缺点总结  优点  无需为表示结点间的逻辑关系而增加额外的存储空间 可方便地随机存取查找表中的任一元素   缺点  大量插入删除时效率低，除表尾位置外，在其它位置插入删除都必须移动大量元素（平均移动次数为表长度一半） 由于顺序表要求占用连续的存储空间,存储分配只能预先进行静态分配。因此当表长变化较大时，难以确定合适的存储规模。    总结：便于随机存取，不适合动态变化\n线性表的链式存储 单链表 1 2 3 4 5 6  typedef struct { int data; struct Node *next; } Node, *LinkList; LinkList L;   求长度 1 2 3 4 5 6 7 8 9 10 11 12 13  int ListLength(LinkList L) { Node *p; int j; p = L-\u0026gt;next; j = 0; while (p != NULL) { p = p-\u0026gt;next; j++; } return j; }   建立空表 1 2 3 4 5  void InitList(LinkList *L) { *L = (LinkList)malloc(sizeof(Node)); (*L)-\u0026gt;next = NULL; }   建表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  /* 头插法建表eg: 输入：123$ 链表：321 */ LinkList CreateFromHead(LinkList L) { Node *s; char c; int flag = 1; while (flag) { c = getchar(); if (c != \u0026#39;$\u0026#39;) { s = (Node *)malloc(sizeof(Node)); s-\u0026gt;data = c; s-\u0026gt;next = L-\u0026gt;next; L-\u0026gt;next = s; } else flag = 0; } } /* 尾插法建表eg: 输入：123$ 链表：123 */ LinkList CreateFromTail(LinkList L) { Node *r, *s; char c; int flag = 1; r = L; while (flag) { c = getchar(); if (c != \u0026#39;$\u0026#39;) { s = (Node *)malloc(sizeof(Node)); s-\u0026gt;data = c; r-\u0026gt;next = s; r = s; } else { flag = 0; r-\u0026gt;next = NULL; } } }   查找 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  //按序号查找（第i个） Node *Get(LinkList L, int i) { int j; Node *p; p = L; j = 0; while ((p-\u0026gt;next != NULL) \u0026amp;\u0026amp; (j \u0026lt; i)) { p = p-\u0026gt;next; j++; } if (i == j) return p; else return NULL; } //按值查找 Node *Locate(LinkList L, int key) { Node *p; p = L-\u0026gt;next; while (p != NULL) if (p-\u0026gt;data != key) p = p-\u0026gt;next; else break; return p; }   前插 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  int InsList(LinkList L, int i, int e) { Node *pre, *s; int k; pre = L; k = 0; while (pre != NULL \u0026amp;\u0026amp; k \u0026lt; i - 1) { pre = pre-\u0026gt;next; k++; } if (!pre) { printf(\u0026#34;插入位置不合理！\u0026#34;); return 0; } s = (Node *)malloc(sizeof(Node)); s-\u0026gt;data = e; s-\u0026gt;next = pre-\u0026gt;next; pre-\u0026gt;next = s; return 1; }   删除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  void DelList(LinkList L, int i, int *e) { Node *p, *r; int k; p = L; k = 0; while (p-\u0026gt;next != NULL \u0026amp;\u0026amp; k \u0026lt; i - 1) { p = p-\u0026gt;next; k++; } if (k != i - 1) { printf(\u0026#34;删除结点的位置i不合理！\u0026#34;); return; } r = p-\u0026gt;next; p-\u0026gt;next = r-\u0026gt;next; *e = r-\u0026gt;data; free(r); }   示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; typedef struct { int data; struct Node *next; } Node, *LinkList; int ListLength(LinkList L) { Node *p; int j; p = L-\u0026gt;next; j = 0; while (p != NULL) { p = p-\u0026gt;next; j++; } return j; } void InitList(LinkList *L) { *L = (LinkList)malloc(sizeof(Node)); (*L)-\u0026gt;next = NULL; } LinkList CreateFromHead(LinkList L) { Node *s; char c; int flag = 1; while (flag) { c = getchar(); if (c != \u0026#39;$\u0026#39;) { s = (Node *)malloc(sizeof(Node)); s-\u0026gt;data = c; s-\u0026gt;next = L-\u0026gt;next; L-\u0026gt;next = s; } else flag = 0; } } LinkList CreateFromTail(LinkList L) { Node *r, *s; char c; int flag = 1; r = L; while (flag) { c = getchar(); if (c != \u0026#39;$\u0026#39;) { s = (Node *)malloc(sizeof(Node)); s-\u0026gt;data = c; r-\u0026gt;next = s; r = s; } else { flag = 0; r-\u0026gt;next = NULL; } } } Node *Get(LinkList L, int i) { int j; Node *p; p = L; j = 0; while ((p-\u0026gt;next != NULL) \u0026amp;\u0026amp; (j \u0026lt; i)) { p = p-\u0026gt;next; j++; } if (i == j) return p; else return NULL; } Node *Locate(LinkList L, int key) { Node *p; p = L-\u0026gt;next; while (p != NULL) if (p-\u0026gt;data != key) p = p-\u0026gt;next; else break; return p; } int InsList(LinkList L, int i, int e) { Node *pre, *s; int k; pre = L; k = 0; while (pre != NULL \u0026amp;\u0026amp; k \u0026lt; i - 1) { pre = pre-\u0026gt;next; k++; } if (!pre) { printf(\u0026#34;插入位置不合理！\u0026#34;); return 0; } s = (Node *)malloc(sizeof(Node)); s-\u0026gt;data = e; s-\u0026gt;next = pre-\u0026gt;next; pre-\u0026gt;next = s; return 1; } void DelList(LinkList L, int i, int *e) { Node *p, *r; int k; p = L; k = 0; while (p-\u0026gt;next != NULL \u0026amp;\u0026amp; k \u0026lt; i - 1) { p = p-\u0026gt;next; k++; } if (k != i - 1) { printf(\u0026#34;删除结点的位置i不合理！\u0026#34;); return; } r = p-\u0026gt;next; p-\u0026gt;next = r-\u0026gt;next; *e = r-\u0026gt;data; free(r); } void Difference(LinkList LA, LinkList LB) { Node *pre, *p, *q, *r; pre = LA; p = LA-\u0026gt;next; while (p != NULL) { q = LB-\u0026gt;next; while (q != NULL \u0026amp;\u0026amp; q-\u0026gt;data != p-\u0026gt;data) q = q-\u0026gt;next; if (q != NULL) { r = p; pre-\u0026gt;next = p-\u0026gt;next; p = p-\u0026gt;next; free(r); } else { pre = p; p = p-\u0026gt;next; } } } int main() { LinkList L, p; int del; int length; InitList(\u0026amp;L); CreateFromHead(L); length = ListLength(L); printf(\u0026#34;第一次的长度:%d\\t\u0026#34;, length); p = Get(L, 1); printf(\u0026#34;第一个元素值:%c\\n\u0026#34;, p-\u0026gt;data); if (InsList(L, 1, \u0026#39;0\u0026#39;)) { length = ListLength(L); printf(\u0026#34;第二次的长度:%d\\t\u0026#34;, length); p = Get(L, 1); printf(\u0026#34;第一个元素值:%c\\n\u0026#34;, p-\u0026gt;data); } DelList(L, 1, \u0026amp;del); length = ListLength(L); printf(\u0026#34;第三次的长度:%d\\t\u0026#34;, length); printf(\u0026#34;被删除元素值:%c\\n\u0026#34;, del); return 0; } /* 输入： 54321$ 输出： 第一次的长度:5\t第一个元素值:1 第二次的长度:6\t第一个元素值:0 第三次的长度:5\t被删除元素值:0 */   就地逆置算法 1 2 3 4 5 6 7 8 9 10 11 12 13  void ReverseList(LinkList L) { LinkList p, q; p = L-\u0026gt;next; L-\u0026gt;next = NULL; while (p != NULL) { q = p-\u0026gt;next; p-\u0026gt;next = L-\u0026gt;next; L-\u0026gt;next = p; p = q; } }   应用实例——求集合差 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  void Difference(LinkList LA, LinkList LB) { Node *pre, *p, *q, *r; pre = LA; p = LA-\u0026gt;next; while (p != NULL) { q = LB-\u0026gt;next; while (q != NULL \u0026amp;\u0026amp; q-\u0026gt;data != p-\u0026gt;data) q = q-\u0026gt;next; if (q != NULL) { r = p; pre-\u0026gt;next = p-\u0026gt;next; p = p-\u0026gt;next; free(r); } else { pre = p; p = p-\u0026gt;next; } } }   单链表总结   访问单链表 L 中某结点第 i 结点或值为 e 结点时，必须从头开始。\n  表尾控制条件：当前结点p-\u0026gt;next == NULL\n  在处理过程中始终需要维持当前指针p与前驱指针pre的关系。\n  循环链表 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; typedef struct { int data; struct Node *next; } Node, *LinkList; void InitList(LinkList *L) { *L = (LinkList *)malloc(sizeof(Node)); (*L)-\u0026gt;next = *L; } int main() { LinkList L, p; int i; InitList(\u0026amp;L); for (i = 1; i \u0026lt;= 3; i++) { p = (Node *)malloc(sizeof(Node)); p-\u0026gt;data = i; p-\u0026gt;next = L-\u0026gt;next; L-\u0026gt;next = p; } p = L-\u0026gt;next; for (i = 1; i \u0026lt;= 6; i++) { printf(\u0026#34;%d\\t\u0026#34;, p-\u0026gt;data); if (p-\u0026gt;next == L) { printf(\u0026#34;已到达表尾\\n\u0026#34;); p = p-\u0026gt;next; } p = p-\u0026gt;next; } return 0; } /* 输出： 3\t2\t1\t已到达表尾 3\t2\t1\t已到达表尾 */   循环单链表的合并算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  //采用头指针 LinkList merge_1(LinkList LA, LinkList LB) { Node *p, *q; p = LA; q = LB; while (p-\u0026gt;next != LA) p = p-\u0026gt;next; while (q-\u0026gt;next != LB) q = q-\u0026gt;next; q-\u0026gt;next = LA; p-\u0026gt;next = LB-\u0026gt;next; free(LB); return LA; } //采用尾指针 LinkList merge_2(LinkList RA, LinkList RB) { Node *p, *tmp; p = RA-\u0026gt;next; tmp = RB-\u0026gt;next; RA-\u0026gt;next = tmp-\u0026gt;next; free(RB-\u0026gt;next); RB-\u0026gt;next = p; return RB; }   循环单链表总结  特点：首尾相接，可从当前结点遍历所有结点 空表判断条件：L-\u0026gt;next == L 表尾控制条件：当前结点p-\u0026gt;next == L  双向链表 1 2 3 4 5  typedef struct DNode { int data; struct DNode *prior, *next; } DNode, *DoubleList;   前插操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  int DlinkIns(DoubleList L, int i, int e) { DNode *s, *p; int k; p = L; k = 0; while (p != NULL \u0026amp;\u0026amp; k \u0026lt; i - 1) { p = p-\u0026gt;next; k++; } if (!p) { printf(\u0026#34;插入位置不合理！\u0026#34;); return 0; } s = (DNode *)malloc(sizeof(DNode)); if (s) { s-\u0026gt;data = e; s-\u0026gt;prior = p-\u0026gt;prior; p-\u0026gt;prior-\u0026gt;next = s; s-\u0026gt;next = p; p-\u0026gt;prior = s; return 1; } else return 0; }   删除操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  int DlinkDel(DoubleList L, int i, int *e) { DNode *p; int k; p = L; k = 0; while (p-\u0026gt;next != NULL \u0026amp;\u0026amp; k \u0026lt; i - 1) { p = p-\u0026gt;next; k++; } if (k != i - 1) { printf(\u0026#34;删除结点的位置i不合理！\u0026#34;); return 0; } *e = p-\u0026gt;data; p-\u0026gt;prior-\u0026gt;next = p-\u0026gt;next; p-\u0026gt;next-\u0026gt;prior = p-\u0026gt;prior; free(p); return 1; }   循环双向链表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; typedef struct DNode { int data; struct DNode *prior, *next; } DNode, *DoubleList; void DlinkInit(DoubleList *L) { *L = (DoubleList *)malloc(sizeof(DNode)); (*L)-\u0026gt;prior = (*L)-\u0026gt;next = *L; } int main() { DoubleList L, p, r; int i; DlinkInit(\u0026amp;L); r = L; for (i = 1; i \u0026lt;= 3; i++) { p = (DNode *)malloc(sizeof(DNode)); p-\u0026gt;data = i; r-\u0026gt;next-\u0026gt;prior = p; p-\u0026gt;next = r-\u0026gt;next; r-\u0026gt;next = p; p-\u0026gt;prior = r; } while (p-\u0026gt;next != L) { printf(\u0026#34;%d\\t\u0026#34;, p-\u0026gt;data); p = p-\u0026gt;next; } printf(\u0026#34;%d\\t已到表尾\\n\u0026#34;, p-\u0026gt;data); while (p-\u0026gt;prior != L) { printf(\u0026#34;%d\\t\u0026#34;, p-\u0026gt;data); p = p-\u0026gt;prior; } printf(\u0026#34;%d\\t已到表头\\n\u0026#34;, p-\u0026gt;data); return 0; } /* 输出： 3\t2\t1\t已到表尾 1\t2\t3\t已到表头 */   双向链表总结  双向链表可从两个方向访问任一结点，快速，方便。 可以推广至多重链表，其本质上是用空间换时间。  静态链表 由于有些语言并未提供指针类型，我们可以采用数组模拟实现链表，静态模拟动态。\n1 2 3 4 5 6  #define MAXSIZE 100 typedef struct { int data; int cursor; }Component,StaticList[MAXSIZE];   初始化 1 2 3 4 5 6 7 8  void initial(StaticList space, int *av) { space[0].cursor = -1; for (int k = 1; k \u0026lt; MAXSIZE - 1; k++) space[k].cursor = k + 1; space[MAXSIZE].cursor = -1; *av = 1; }   分配结点 1 2 3 4 5 6 7 8  //从备用链表中分配结点给使用者 int getnode(StaticList space, int *av) { int i; i = *av; *av = space[*av].cursor; return i; }   回收结点 1 2 3 4 5 6  //备用链表回收空闲结点 void freenode(StaticList space, int *av, int k) { space[k].cursor = *av; *av = k; }   线性表的链式存储总结   存储结构：用一组任意配置的单元存储，用指针维持结点线性关系\n  类型：\n  动态链表\n单链表，双向链表，多重链表，循环链表\n  静态链表\n    特点：适合动态变化长度操作，需有存储指针附加代价\n  线性表应用——一元多项式表示及相加 一元多项式数学表示： $$ P_n(x)=p_0+p_1x^{e_1}+p2x^{e_2}+…+p_nx^{e_n} $$ 其用线性表表示： $$ P=(p_0,p_1,p_2,…,p_n) $$ 两个一元多项式的相加：(设m\u0026lt;n) $$ P_n(x)+Q_m(x)=R_n(x) $$\n$$ R=(p_0+q_0,p_1+q_1,p_2+q_2,…,p_m+q_m,p_{m+1},…,p_n) $$\n链式存储 只存储非零系数项和指数项。\n所有指数相同的项的对应系数相加，若和不为零则构成“和多项式”中的一项，所有指数不相同的项均按升幂复抄到“和多项式”中。\n完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; typedef struct Polynode { int coef; //系数  int exp; //指数  struct Polynode *next; } Polynode, *Polylist; Polylist PolyCreate(); Polylist AscSort(Polylist L); Polylist PolyAdd(Polylist LA, Polylist LB); void PolyPrint(Polylist L); int main() { Polylist LA, LB, LC; LA = AscSort(PolyCreate()); printf(\u0026#34;f(x)_A=\u0026#34;); PolyPrint(LA); LB = AscSort(PolyCreate()); printf(\u0026#34;f(x)_B=\u0026#34;); PolyPrint(LB); LC = PolyAdd(LA, LB); printf(\u0026#34;f(x)_C=f(x)_A+f(x)_B=\u0026#34;); PolyPrint(LC); return 0; } Polylist PolyCreate() { Polynode *head, *rear, *s; int c, e; head = (Polynode *)malloc(sizeof(Polynode)); rear = head; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;c, \u0026amp;e); while (c != 0) { s = (Polynode *)malloc(sizeof(Polynode)); s-\u0026gt;coef = c; s-\u0026gt;exp = e; rear-\u0026gt;next = s; rear = s; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;c, \u0026amp;e); } rear-\u0026gt;next = NULL; return head; } Polylist AscSort(Polylist L) { Polynode *p, *q; int ctmp, etmp; for (p = L-\u0026gt;next; p != NULL; p = p-\u0026gt;next) for (q = p-\u0026gt;next; q != NULL; q = q-\u0026gt;next) if (p-\u0026gt;exp \u0026gt; q-\u0026gt;exp) { etmp = p-\u0026gt;exp; p-\u0026gt;exp = q-\u0026gt;exp; q-\u0026gt;exp = etmp; ctmp = p-\u0026gt;coef; p-\u0026gt;coef = q-\u0026gt;coef; q-\u0026gt;coef = ctmp; } else if (p-\u0026gt;exp == q-\u0026gt;exp) { p-\u0026gt;coef = p-\u0026gt;coef + q-\u0026gt;coef; p-\u0026gt;next = q-\u0026gt;next; } return L; } Polylist PolyAdd(Polylist LA, Polylist LB) { Polynode *a, *b, *p; a = LA-\u0026gt;next; b = LB-\u0026gt;next; p = LA; while (a != NULL \u0026amp;\u0026amp; b != NULL) { if (a-\u0026gt;exp == b-\u0026gt;exp) { a-\u0026gt;coef = a-\u0026gt;coef + b-\u0026gt;coef; p-\u0026gt;next = a; p = p-\u0026gt;next; a = a-\u0026gt;next; b = b-\u0026gt;next; } else if (a-\u0026gt;exp \u0026lt; b-\u0026gt;exp) { p-\u0026gt;next = a; p = p-\u0026gt;next; a = a-\u0026gt;next; } else { p-\u0026gt;next = b; p = p-\u0026gt;next; b = b-\u0026gt;next; } } if (a != NULL) p-\u0026gt;next = a; else p-\u0026gt;next = b; return LA; } void PolyPrint(Polylist L) { Polynode *p; p = L-\u0026gt;next; while (p != NULL) { if (p-\u0026gt;coef \u0026gt; 0 \u0026amp;\u0026amp; p-\u0026gt;exp == 0 \u0026amp;\u0026amp; p == L-\u0026gt;next) //系数大于0，指数0，首项  printf(\u0026#34;%d\u0026#34;, p-\u0026gt;coef); else if (p-\u0026gt;coef \u0026gt; 0 \u0026amp;\u0026amp; p-\u0026gt;exp == 0 \u0026amp;\u0026amp; p != L-\u0026gt;next) //系数大于0，指数0，非首项  printf(\u0026#34;+%d\u0026#34;, p-\u0026gt;coef); else if (p-\u0026gt;coef \u0026lt; 0 \u0026amp;\u0026amp; p-\u0026gt;exp == 0) //系数小于0，指数0  printf(\u0026#34;%d\u0026#34;, p-\u0026gt;coef); else if (p-\u0026gt;coef == 1 \u0026amp;\u0026amp; p-\u0026gt;exp == 1 \u0026amp;\u0026amp; p == L-\u0026gt;next) //系数1,指数为1，首项  printf(\u0026#34;x\u0026#34;); else if (p-\u0026gt;coef == 1 \u0026amp;\u0026amp; p-\u0026gt;exp == 1 \u0026amp;\u0026amp; p != L-\u0026gt;next) //系数1,指数为1，非首项  printf(\u0026#34;+x\u0026#34;); else if (p-\u0026gt;coef == 1 \u0026amp;\u0026amp; p-\u0026gt;exp != 0 \u0026amp;\u0026amp; p-\u0026gt;exp != 1 \u0026amp;\u0026amp; p == L-\u0026gt;next) //系数1，指数非0非1，首项  printf(\u0026#34;x^%d\u0026#34;, p-\u0026gt;exp); else if (p-\u0026gt;coef == 1 \u0026amp;\u0026amp; p-\u0026gt;exp != 0 \u0026amp;\u0026amp; p-\u0026gt;exp != 1 \u0026amp;\u0026amp; p != L-\u0026gt;next) //系数1，指数非0非1，非首项  printf(\u0026#34;+x^%d\u0026#34;, p-\u0026gt;exp); else if (p-\u0026gt;coef == -1 \u0026amp;\u0026amp; p-\u0026gt;exp == 1) //系数-1,指数1  printf(\u0026#34;-x\u0026#34;); else if (p-\u0026gt;coef == -1 \u0026amp;\u0026amp; p-\u0026gt;exp != 0 \u0026amp;\u0026amp; p-\u0026gt;exp != 1) //系数-1，指数非0非1  printf(\u0026#34;-x^%d\u0026#34;, p-\u0026gt;exp); else if (p-\u0026gt;coef \u0026gt; 0 \u0026amp;\u0026amp; p-\u0026gt;exp == 1 \u0026amp;\u0026amp; p == L-\u0026gt;next) //系数大于0，指数1，首项  printf(\u0026#34;%dx\u0026#34;, p-\u0026gt;coef); else if (p-\u0026gt;coef \u0026gt; 0 \u0026amp;\u0026amp; p-\u0026gt;exp == 1 \u0026amp;\u0026amp; p != L-\u0026gt;next) //系数大于0，指数1，非首项  printf(\u0026#34;+%dx\u0026#34;, p-\u0026gt;coef); else if (p-\u0026gt;coef \u0026lt; 0 \u0026amp;\u0026amp; p-\u0026gt;exp == 1) //系数小于0，指数1  printf(\u0026#34;%dx\u0026#34;, p-\u0026gt;coef); else if (p-\u0026gt;coef \u0026gt; 0 \u0026amp;\u0026amp; p-\u0026gt;exp != 0 \u0026amp;\u0026amp; p-\u0026gt;exp != 1 \u0026amp;\u0026amp; p == L-\u0026gt;next) //系数大于0,指数非0非1，首项  printf(\u0026#34;%dx^%d\u0026#34;, p-\u0026gt;coef, p-\u0026gt;exp); else if (p-\u0026gt;coef \u0026gt; 0 \u0026amp;\u0026amp; p-\u0026gt;exp != 0 \u0026amp;\u0026amp; p-\u0026gt;exp != 1 \u0026amp;\u0026amp; p != L-\u0026gt;next) //系数大于0,指数非0非1，非首项  printf(\u0026#34;+%dx^%d\u0026#34;, p-\u0026gt;coef, p-\u0026gt;exp); else if (p-\u0026gt;coef \u0026lt; 0 \u0026amp;\u0026amp; p-\u0026gt;exp != 0 \u0026amp;\u0026amp; p-\u0026gt;exp != 1) //系数小于0,指数非0非1  printf(\u0026#34;%dx^%d\u0026#34;, p-\u0026gt;coef, p-\u0026gt;exp); p = p-\u0026gt;next; } printf(\u0026#34;\\n\u0026#34;); }   运行截图：\n顺序表与链表的综合比较 基于空间的考虑  顺序表存储是静态分配，程序执行前须定义存储规模。 静态链表是静态分配，同时存在若干个结点类型相同的链表，可共享空间。 动态链表存储是动态分配，只要内存空间尚有空闲就不会产生溢出。  顺序表虽然存储密度更高，但灵活度不够。\n信息  存储密度，指结点数据本身所占的存储量和整个结点结构所占的存储量之比。顺序表存储密度为1，而链表小于1   当线性表的长度变化较大，难以估计其存储规模时，采用动态链表作为存储结构较好。\n基于时间的考虑 顺序表是一种随机存储结构，适合大量元素的查找。\n链表的插入删除只用修改挂链，不需要移动元素，所以适合动态变化。\n若表的插入和删除主要发生在表的首尾两端，则宜采用尾指针表示的单循环链表。\n基于语言的考虑 有些语言提供指针类型，因此可以用链表形式。有些语言不提供指针类型，只能用静态链表来模拟，静态链表在存储分配上有所不足，但也能像动态链表一样灵活插入和删除。\n存储方式比较 线性表例题 顺序表分奇偶 已知顺序表 L 中的数据元素类型为 int。设计算法将其调整为左右两部分，左边的元素（即排在前面的）均为奇数，右边所有元素（即排在后面的）均为偶数，并要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)\n1 2 3 4 5 6  #define MAXSIZE 100 typedef struct { int elem[MAXSIZE]; int last; } SeqList;   WP：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  AdjustSeqlist(SeqList *L) { int i, j, tmp; i = 0; j = L-\u0026gt;last; while (i \u0026lt; j) { while (L-\u0026gt;elem[i] % 2 != 0) i++; while (L-\u0026gt;elem[j] % 2 == 0) j--; if (i \u0026lt; j) { tmp = L-\u0026gt;elem[i]; L-\u0026gt;elem[i] = L-\u0026gt;elem[j]; L-\u0026gt;elem[j] = tmp; } } }   二进制数加一运算 建立了一个带头结点的线性链表，用以存放输入的二进制数，链表中每个结点的 data 域存放一个二进制位。并在此链表上实现对二进制数加1的运算。\n1 2 3 4 5  typedef struct { int data; struct Node *next; } Node, *LinkList;   WP：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  void BinAdd(LinkList L) { Node *q, *r, *tmp, *s; q = L-\u0026gt;next; r = L; while (q != NULL) //找到最后一个值域0的结点，将值赋为1  { if (q-\u0026gt;data == 0) r = q; q = q-\u0026gt;next; } if (r != L) r-\u0026gt;data = 1; else { tmp = r-\u0026gt;next; s = (Node *)malloc(sizeof(Node)); s-\u0026gt;data = 1; //头插  s-\u0026gt;next = tmp; r-\u0026gt;next = s; r = s; } r = r-\u0026gt;next; while (r != NULL) //进位结点后的结点值域置0  { r-\u0026gt;data = 0; r = r-\u0026gt;next; } }   ","permalink":"https://www.sukun.xyz/data_structure-2/","tags":["数据结构","学习"],"title":"数据结构学习(二)"},{"categories":["数据结构"],"contents":"本系列学习笔记链接  第一章：数据结构学习(一) 第二章：数据结构学习(二) 第三章：数据结构学习(三)  数据结构——用C语言描述(一) 数据结构绪论 数据结构基础概念   数据（Data）：描述客观事物的数值、字符，能被机器输入且处理的的各种符号的集合。\n  数据元素（Data Element）：组成数据的基本单位，是数据集合的个体。一条记录就是一个数据元素。\n  数据对象（Data Object）：性质相同的数据元素的集合，是数据的一个子集。\n  数据结构（Data Structure）：指相互之间存在一种或多种特定关系的数据元素集合。即数据元素之间的相互关系，即数据的组织形式。一句话总结：带有结构的数据元素的集合。\n  数据类型（Data Type）：一组性质相同的值集合以及定义在这个值集合上的一组操作的总称。即值域、定义域及运算集合。\n  抽象数据类型（Abstract Data Type）：定义了一个数据对象，数据对象中各元素之间的结构关系，以及一组处理数据的操作。包括定义和实现两方面，其中定义是独立于实现的。\nADT 三要素：\n 数据元素 数据关系 数据操作    数据结构内容   逻辑结构：数据元素之间逻辑关系描述。\n四种基本数据逻辑结构表现为四种数据元素关系：\n 集合结构：属于关系 线性结构：一对一的线性关系 树形结构：一对多的层次关系 图形结构：多对多的任意关系    存储结构（物理结构）：逻辑结构在计算机中存储映像，是逻辑结构在计算机中的实现。包括数据元素的表示和关系的表示。\n数据元素之间关系在计算机中表示方法：\n 顺序映像，一组连续单元，如数组。 非顺序映像，一组任意存储单元，如链表。    运算集合\n  算法与算法描述  算法（algorithm）定义：规则的有限集合，是为解决特定问题而规定一系列操作。 算法特性：  有限性：有限步骤 确定性：无二义性 输入：有多个或0个输入 输出：至少有一个输出 可行性：原则上能精确进行，操作可通过已实现的基本运算执行有限次而完成   算法设计要求：  正确性 可读性 健壮性（鲁棒性）：对非法输入的抵抗能力 高效率与低存储量   算法描述：自然语言、框图、高级语言  算法性能评价   性能评价：问题规模 N 的函数\n  数量关系评价：时间和空间\n  算法执行时间：本质是语句执行次数的比较\n  语句频度：该语句在一个算法中的重复执行的次数\n  算法的时间复杂度: $$ T(n)=O(f(n)) $$ 例如：\n1 2 3  for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; n; j++) x++;   这样的一段代码其时间复杂度为 $$ o(n^2) $$ 再例如，下方有一个算法的执行时间 $$ f(n)=2n^3+2n^2+n $$ 其时间复杂度为 $$ o(n^3) $$ 但这样一个算法只是理论上可行，但实际上不可行，因为其执行次数上升太快，程序无法实现。\n  最坏时间复杂度：算法在最坏情况下基本操作执行时间的上界。\n例如，冒泡排序算法最坏时间复杂度为 $$ o(n^2) $$ 而其最好时间复杂度为 $$ o(n) $$\n  算法空间复杂度：以存储单元个数刻画随问题规模增加的函数 f(n)，是考虑程序运行时占用内存的大小，记作 $$ S(n)=O(f(n)) $$\n   ","permalink":"https://www.sukun.xyz/data_structure-1/","tags":["数据结构","学习"],"title":"数据结构学习(一)"},{"categories":["计算机网络"],"contents":"全双工、半双工、单工 定义 为了便于理解，这里打个比方，全双工就是双向两车道，半双工就是双向单车道，而单工则是单行路。\n全双工 全双工（Full Duplex）是通讯传输的一个术语。通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。全双工指可以同时（瞬时）进行信号的双向传输（A→B且B→A）。指A→B的同时B→A，是瞬时同步的。\n半双工 半双工(Half Duplex)数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输。例如，在一个局域网上使用具有半双工传输的技术，一个工作站可以在线上发送数据，然后立即在线上接收数据，这些数据来自数据刚刚传输的方向。像全双工传输一样，半双工包含一个双向线路（线路可以在两个方向上传递数据）。\n单工 单工（Simplex Communication）模式的数据传输是单向的。通信双方中，一方固定为发送端，一方则固定为接收端。信息只能沿一个方向传输，使用一根传输线。移动通信按照用户的通话状态和频率使用的方法，可分为三种工作方式：单工制、半双工制和双工制。\n","permalink":"https://www.sukun.xyz/%E5%85%A8%E5%8F%8C%E5%B7%A5%E5%8D%8A%E5%8F%8C%E5%B7%A5%E4%B8%8E%E5%8D%95%E5%B7%A5/","tags":["计算机网络"],"title":"全双工，半双工与单工"},{"categories":["计算机网络"],"contents":"Socket网络编程详解 Socket简介 上图表示的是国际标准化组织(ISO)的计算机通信开放系统互连(OSI)模型；\n1、2层随系统提供的设备驱动和网络硬件实现，一般不必关心，网络层 IPv4 或者 IPv6，传输层可以选择 TCP 或者 UDP，OSI 上面的 3 层合并为一层应用层，我们使用的套接口就是应用层到传输层的接口，主要介绍如何使用套接口编写使用 TCP 或者 UDP 的网络应用程序，其实可以绕过传输层，应用直接使用 IPv4 或者 IPv6，称为原始套接口(raw socket);\n上三层（应用层）处理应用程序（如FTP、telnet、HTTP）的细节，不知道通信细节；下四层则不知道应用程序，但能处理所有的通信细节，发送数据、等待确认、给无序到达的数据排序、计算与验证校验和等等；\n上三层通常形成用户进程，而下四层通常作为操作系统内核的一部分。\nUDP 是英文 UserDatagramProtocol 的缩写，即用户数据报协议，主要用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用 UDP 协议。UDP 协议从问世至今已经被使用了很多年，虽然其最初的光彩已经被一些类似协议所掩盖，但是即使是在今天，UDP 仍然不失为一项非常实用和可行的网络传输层协议。\nUDP 和 TCP 的主要区别是两者在如何实现信息的可靠传递方面不同。TCP 中包含了专门的传递保证机制，当数据接收方收到发送方传来的信息时，会自动向发送方发出确认消息；发送方只有在接收到该确认消息之后才继续传送其它信息，否则将一直等待直到收到确认信息为止。\nUDP 并不提供数据传送的保证机制。如果在从发送方到接收方的传递过程中出现数据报的丢失，协议本身并不能做出任何检测或提示。因此，通常人们把 UDP 协议称为不可靠的传输协议。\n相对于 TCP，UDP 的另外一个不同之处在于如何接收突法性的多个数据报。不同于 TCP，UDP 并不能确保数据的发送和接收顺序，事实上，UDP 协议的这种乱序性基本上很少出现，通常只会在网络非常拥挤的情况下才有可能发生 。\nUDP 具有 TCP 所望尘莫及的速度优势 ，TCP 中植入了各种安全保障功能，在实际执行的过程中会占用大量的系统开销，无疑使速度受到严重的影响。UDP 由于排除了信息可靠传递机制，将安全和排序等功能移交给上层应用来完成，极大降低了执行时间，使速度得到了保证。\n只有理解了某些特性，才能更容易的编写更健壮的客户、服务器程序，netstat 工具是调试客户、服务程序最好的工具，tcp 的三路握手、tcp 的连接终止序列、tcp 的 time_wait 状态、套接口的缓冲机制等。\n总结：UDP是一种简单的、不可靠的数据报协议；TCP是一种精致的、可靠的字节流协议\nTCP通信 TCP简介  TCP 提供客户与服务器的连接； TCP 提供可靠性； TCP 通过给所发送数据的字节关联一个序号进行排序； TCP 提供流量控制； TCP 的连接是全双工的。（全双工？半双工？单工？）  一个TCP客户建立与一个给定的服务器的连接，跨越连接与那个服务器交换数据，然后终止连接；\n当TCP向另一端发送数据时，它要求对方返回一个确认。如果没有收到确认，自动重传数据并等待更长时间，在数次重传失败后才放弃；\nTCP总是告诉对方它能够接收多少字节的数据，叫通告窗口；\n在给定的连接上应用进程在任何时刻既可以发送也可以接收数据。\nTCP三次握手","permalink":"https://www.sukun.xyz/socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3/","tags":["socket"],"title":"Socket网络编程详解"},{"categories":["常见问题"],"contents":"各位可能遇见过这样一个：Path 变量字符数超过1023个，无法再继续添加了。\n其实你可以另外新建一个环境变量（比如我的是myEnvExtension），然后在这个变量下添加你要添加的 Path，然后再在 Path 中添加一个变量值为 %myEnvExtension% 即可。\n","permalink":"https://www.sukun.xyz/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%AD%97%E7%AC%A6%E6%95%B0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","tags":["windows"],"title":"环境变量字符数解决方案"},{"categories":["web"],"contents":"Hugo博客系列（二） 本系列教程链接：\n 第一期 第二期  前言 上一期教程讲述了如何利用 GitHub pages 来部署，但我发现这并不是很好用。一是因为 GitHub pages 在国内访问速度较慢，二是百度不会收录 GitHub pages，这就导致了站点流量难以增长，但 Vercel 就不存在这些问题，因此我将本站迁移至了 Vercel。与此同时，还做了一些简单的美化操作。\n从 GitHub pages 迁移至 Vercel 首先前往 Vercel 官网，使用 GitHub 登录。\n未完待续\n","permalink":"https://www.sukun.xyz/hugo-2/","tags":["Hugo"],"title":"Hugo博客系列(二)"},{"categories":null,"contents":"主题作者 本网站采用 Hugo-LoveIt 主题，下方是主题作者的 GitHub 链接。\n\rDillon\r\"LoveIt主题作者\"\r\r\r\r大佬们 JAVA \r雨临Lewis的博客\r\"不想当写手的码农不是好咸鱼_(xз」∠)_\"\r\r\r\r本站友链信息 1 2 3 4  name=\u0026#34;Sukun的博客\u0026#34; url=\u0026#34;https://www.sukun.xyz\u0026#34; logo=\u0026#34;https://www.sukun.xyz/images/avatar.png\u0026#34; word=\u0026#34;Sukun的博客，记录学习历程！\u0026#34;   交换友链 注意  各位大佬想交换友链的话可以在下方留言，我看到后将以回复+邮件的形式通知！   你需要留下以下信息：\n1 2 3 4 5 6 7 8 9 10  //必填 name=\u0026#34;站点名称\u0026#34; //必填 url=\u0026#34;站点地址\u0026#34; //必填 logo=\u0026#34;你的站点图标或个人头像\u0026#34; //必填 word=\u0026#34;站点描述\u0026#34; //选填——默认分组是大佬们 group=\u0026#34;分组\u0026#34;   警告  如果贵站存在以下情况之一：\n链接失效、无法访问、删除本站友链、友链入口不易找到。\n我将删除贵站友链并邮件通知，直至贵站恢复正常为止！\n   ","permalink":"https://www.sukun.xyz/friends/","tags":null,"title":"友链墙"},{"categories":null,"contents":"   new Artitalk({ appId: 'LLhNra6D2fqcyOGJYWIrwoB8-MdYXbMMI', // Your LeanCloud appId appKey: '1m4bN4Gx2xYFmRwyrT1Y1qPa' // Your LeanCloud appKey })  ","permalink":"https://www.sukun.xyz/bbs/%E5%85%AC%E5%91%8A%E7%95%99%E8%A8%80/","tags":null,"title":"公告留言"},{"categories":["生活"],"contents":"站点日志 站点日志  不断更新中    2021年 2021年10月 大一参加学校工作室招新，购买了云服务器，顺便利用 WordPress 开通了我的第一个私人博客。（顺便提一嘴，服务器至今仍在跑青龙面板为我捞点豆子）\n2021年11月 嫌弃 WordPress 过于臃肿，且对技术锻炼程度不高，遂放弃 WordPress 转投 Hexo\n2022年 2022年1月 2022年1月1日 元旦第一天，突然想起那个开通了之后一直没写的博客，又发现 Hugo 在博客上是更好的选择，于是本网站就此诞生！\n2022年1月2日 开始写文章了！\n2022年1月3日 为网站添加了小游戏 mikutap。\n2022年1月4日 加入了抓猫小游戏，一起来抓猫呀！\n2022年1月5日 添加了更丰富的评论功能，采用 Waline 实现。\n添加了站点日志、友链墙。\n添加了 artitalk 实现的 BBS 功能——公告板/留言板！\n2022年1月6日 添加了站点持续时间功能。\n2022年1月7日 添加了搜索、GitHub conrner 、最近更新文章、上次更新时间功能\n把源码和网页文件分开为了两个仓库。\n2022年1月8日 将站点从 GitHub pages 迁移至了 Vercel。\n2022年1月20日 期末考完差不多1周了，寒假开卷！数据结构！大雾！微积分！\n这里分享一下我的数据结构学习资料：（西北大学）数据结构网课，LeetCode 刷题\n","permalink":"https://www.sukun.xyz/logs/","tags":["站点日志","生活"],"title":"站点日志"},{"categories":null,"contents":"一起来抓猫 点击圆点围住猫咪，别让它到达地图边缘！\n    window.game = new CatchTheCatGame({ w: 11, h: 11, r: 20, backgroundColor: 0xeeeeee, parent: 'catch-the-cat', statusBarAlign: 'center', credit: '一起来抓猫！' });  ","permalink":"https://www.sukun.xyz/games/catch-the-cat/","tags":null,"title":"Catch the Cat"},{"categories":["web"],"contents":"Hugo博客系列（一） 本系列教程链接：\n 第一期 第二期  前言 为什么要有自己的博客？ 写博文能很好地分享自己的想法，能记录生活，还能充当一个电子笔记的作用，有效防止今后某一天面对一个以前遇到过的问题但现在不会解决的情况出现。一篇好的博文能为你带来大量的流量，你可以在搜索引擎中搜索到自己，我相信这是一件足够令人雀跃的事情。并且你还能利用他做一篇网页简历，当你找工作时你可以有着更加花里胡哨的简历！除此以外，你还能通过交换友链建立一个优质的社交圈，因为大家都写了很多高质量的文章，你能与他们进行深入交流，这不像同学圈一样脆弱，它能稳定存在很久！\n在其他博客平台写作你讲或多或少地受到限制，想自己 DIY 页面还得向官方申请，甚至不会审批通过。而且你无法使用多种多样的第三方插件，还得面对审查，写的文章有可能被删除、撤回。有广告干扰，任谁也不喜欢看着一篇文章然后突然蹦出来一个广告吧？当然，你也可以自己接点广告在网站上。\n常见博客框架的选择 hexo hexo 以前影响力还不错，但这几年已经不如从前人们预判的那么发展的好了，GitHub 上 hexo 项目有着 34k 个 star 看出，其中最为出名的主题便是 Next，有着 15.7k 个 star，这也是因为 Next 目前是 hexo 主题中功能最齐全最好用的一个。而如此之多的人使用也就意味着 hexo 这个框架的作者用收到非常多的反馈，因此 hexo 更新优化做的很好，作者也很有动力继续做下去。\n但是这样的一个框架缺点也是有的：\n  环境配置麻烦\n因为要使用 hexo 你得在本地安装 Node.js、Git，会熟练使用 GitHub，而且由于 GitHub 的特殊性，你还得学会翻墙，不然还用不了，这就对一点基础都没有的小白不是很友好了。\n  无后端\n这意味着你没有一个后台还方便地对网站进行操作，只能通过先写好 Markdown 文件然后 Git 推送到云端。并且原生的 hexo 是没有评论系统的，想加评论还得找第三方评论系统。除此以外，一旦本地文件被你不小心删除掉了，那当你下次 push 的时候你之前的博文也就跟着丢失了。\n  渲染时间久\n200 篇左右的博文用 Hexo 需要 10 分钟去生成静态网页，当你写博客写的时间久了之后文章多了起来，相信我，你会无法忍受这种折磨。\n  总结：hexo 适合有一定基础的人，然后写博客时间不长或者只是随便写来玩的人。当然尤其其广泛的传播性，当你遇到问题的时候拿到网上去搜一般都是有解决方案的，这也可以为你省下一点力气。\n最后，如果你想用 hexo，我建议主题用 Next。\nHugo Hugo 几年前的影响力是不如 hexo 的，但现在越来越多的人从 hexo 迁移到了 Hugo，Hugo使用人数也多了起来，GitHub 上 Hugo 项目有 56.2k 个 star，已远远超过了 hexo，因此你也不用太担心 Hugo 会不会太小众化的问题，但是 Hugo 上的主题选择会更少一些，其中最受欢迎的是 wowchemy，但也仅有 6.1k 个star，而本站采用的是 LoveIt 主题，它的 star 就更少了，才 1.6k 个。当然，如果你是搞前端开发的，或者乐意自己写主题，那这些就不重要了。\nHugo优点：\n  速度快\nHugo 采用 Go 语言编写，它的速度用作者的话来形容就是世界上最快的构建网站工具。并且 Hugo 是即时渲染的，这意味着你可以边写边改样式，直到你满意为止。即使是你写了几百篇文章，它也能在几秒之内全部渲染完成。\n The world’s fastest framework for building websites\n   配置更为简单\n你需要安装只是 Hugo，不像 hexo 还得安装 Node.js。并且Hugo 中是不区分站点和主题的配置文件的，Hugo 中只有一个位于站点根目录下的 config.toml 配置文件，你只用在这里面进行修改就可以了。\n  方便自定义\n你可以在不修改主题文件的前提下方便地定制主题。在 Hugo 中，如果你想要定制主题，你只需在站点目录下新建相应的文件即可。这是非常利于主题的维护的，你只需使用 Git 的 submodule 的方式安装 Hugo 的主题，然后更新时只需直接在站点根目录下敲一条命令回车即可，非常方便！\n  缺点：\n主题比较少，很可能大家都是用的同一个主题，并且主题作者更新会更少一点。\n总结：如果你喜欢 DIY，我建议使用 Hugo。如果你是个专业博主，写了很多文章需要渲染，我建议使用 Hugo！\nTypecho 这是一个非常轻量级的博客框架，但是需要你拥有一个服务器。并且它对服务器要求极低，即使只有 512M 内存或是更低，它也能跑起来。它可以满足你对博客的基本需求，而且 Typecho 是带后端的，意味着只要你能上网，你就可以自由地写你的文章，不会被设备所拘束。当然，你将免除配置环境的苦恼。\n缺点：\n  更新慢\n奇慢无比，作者已经 9 年没有进行更新了，一些插件也已经不能用了。\n  自由度低\n你不能随心所欲地进行 DIY，当然，如果你只是用来写博客的话问题不是很大。\n  WordPress 世界上最受欢迎的建站工具！具体有多受欢迎？每三个网站就有一个是 WordPress 搭建，并且美国白宫自2017年起，其官网 Whitehouse.gov 网站的內容管理系統（Content management system，CMS）从 Drupal 换成 WordPress！\n WordPress 是一个以 PHP 和 MySQL 为平台的自由开源的博客软件和内容管理系统。WordPress 具有插件架构和模板系统。截至2018年4月，排名前1000万的网站中超过30.6%使用WordPress 。WordPress是最受欢迎的网站内容管理系统。全球有大约30%的网站(7亿5000个)都是使用WordPress架设网站的。WordPress 是目前因特网上最流行的博客系统。\n 并且 WordPress 并不只是可以用来写博客，它能用来打造一切你想要的网站，哪怕是用来建个电商网站也没有问题！\n优点：\n  超广泛传播性\n你在使用 WordPress 遇到的任何问题，你都可以在网上找到对应的解决方案，它的使用人数之多以至于每一个坑都有人替你趟过了！\n  DIY 自由度高，难度低\n你可以随心所欲地添加插件，WordPress 提供了大量的优质插件，甚至有大量的人就以制作 WordPress 上的插件谋生！\n  安装简单\n网上有非常多的 WordPress 一键安装脚本，你可以根据自己的需求进行选择，无需面对安装过程中的问题！并且其安装时间非常短，只需要5分钟就能搞定！\n  缺点：\n  需要有一定性能的服务器\nPHP，MySQL这些对服务器有一定的要求，会占用比较多的内存，它不像 Typecho 一样轻便。\n  太过臃肿，不简洁\n太多的功能与选择造成了页面的繁琐，并且你会对着页面一直修改，这不利于你专心地撰写博文。\n  总结：适合有服务器，懒得折腾环境配置，喜欢开箱即用的人。\nHugo快速上手教程 Hugo安装 首先，请前往 GitHub 上下载最新版的 Hugo 压缩包，Releases · gohugoio/hugo (github.com)，建议选择 extended 版本，这将更有利于后续的 DIY 操作！\n下载完成后解压到一个你认为合适的位置，然后把 hugo.exe 所在的文件夹添加至环境变量中的 Path 中即可。\n当然，你也可以采用源码编译的方式进行安装，这里就采用最简单的方法了。\n注意  如果你的path变量下的字符数达到了上限，你可以查看这篇文章中的解决方案。   检查一下上一步操作是否正确\n1  hugo version   然后找一个合适的文件夹，在该目录下输入以下指令新建一个 Hugo 项目\n1 2  hugo new site my_website cd my_website   Hugo主题选择、安装与快速上手 我这里采用 LoveIt 主题进行演示，事实上还有很多主题也很棒，比如 even、meme、wowchemy。\nLoveIt 主题的仓库是: https://github.com/dillonzq/LoveIt.\n你可以下载主题的 最新版本 .zip 文件 并且解压放到 themes目录.\n另外, 也可以直接把这个主题克隆到 themes 目录:\n1  git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt   或者, 初始化你的项目目录为 git 仓库, 并且把主题仓库作为你的网站目录的子模块:\n1 2  git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt   那么如何更新主题呢？\n1  git submodule update --rebase --remote   把 \\themes\\LoveIt\\exampleSite目录下的config.toml复制下来，替换掉站点根目录下的同名文件。\n然后对这个文件进行一些自定义修改。\n然后进入根目录下的archetypes文件夹中，修改default.md文件为下面的内容（这个文件是模板文件，通过指令创建的文章将以模板为基础内容）\n1 2 3 4 5 6 7 8 9 10 11 12 13  --- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} tags: [\u0026#34;\u0026#34;] categories: [\u0026#34;\u0026#34;] toc: enable: true description: draft: true --- \u0026lt;!--more--\u0026gt;   现在开始撰写文章\n1  hugo new posts/first_post.md   注意，后缀为md，建议使用 Typora 进行编辑。\n首先修改 frontmatter，其中title表示文章标题，date为生成文章当时的时间，tags为标签，categories为目录，toc enable为启用文章目录（需要自己在文章中生成），description为文章摘要，draft表示是否为草稿（写完了文章把这里改为 false 即可），\u0026lt;!--more--\u0026gt;为 LoveIt 主题的摘要标识符，该标识符上方的内容为文章摘要，如果上方为空，则采用 frontmatter 中设置的descriptions为文章摘要。\n例如本文的 frontmatter 为\n1 2 3 4 5 6 7 8  title:\u0026#34;Hugo博客系列(一)\u0026#34;date:2022-01-04T18:40:38+08:00tags:[\u0026#34;Hugo\u0026#34;]categories:[\u0026#34;web\u0026#34;]toc:enable:truedescription:本系列教程第一章讲解了几种常见的博客框架选择，最终以 Hugo 框架为基础，教授了如何在 GitHub pages 上部署个人博客，还使用 GitHub actions 以及一个简单的 bat 脚本实现自动化发布。draft:true  写完了文章进行网页的构建\n1  hugo serve -D -e production   -D表示草稿也要渲染，-serve表示启动一个本地服务器，即时渲染，方便修改。\n注意  hugo serve 的默认运行环境是 development, 而 hugo 的默认运行环境是 production。\n由于本地 development 环境的限制, 评论系统**, **CDN 和 fingerprint 不会在 development 环境下启用。\n你可以使用 hugo serve -e production 命令来开启这些特性。\n   值得一提的是不论输入的是server还是serve都是一样的。\n在浏览器中前往它给出的 http://localhost:1313 就能看到你刚生成的博客了。\n技巧  当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新.   现在再输入指令\n1  hugo -D   这会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上。\n确认无误后就要把它发到公网上了，这里采用 GitHub pages 进行部署（当然，也有很多种方法也能达成这一目的）\nGitHub pages部署 如果你是第一次使用 GitHub，请自行搜索如何配置，这里不做讲解！\n首先确保你有一个 GitHub 账号，然后新建一个仓库，名为yourname.github.io，注意，你应该保证这里的 your name 为你的 GitHub 账号名称！然后再进行以下步骤：\n1 2 3 4 5 6 7  cd public git init git remote add origin https://github.com/yourname/yourname.github.io.git #此URL可在你的repo中找到 git add . git commit -m \u0026#34;update %date%,%time%\u0026#34; git push origin master   如果一切顺利的话打开你的 GitHub repo，你就能看到相应的文件了，接着在 settings 页面中下滑，找到 GitHub pages，选择分支master，root路径，然后保存即可。如果你有自己的域名，还可以在下方的custom domain中输入你的域名，等待一段时间就可以用这个域名访问了。\n当然，在此之前你还需要再次修改config.toml文件中的baseURL为https://yourname.github.io，否则发布到网上也无法访问！\nGitHub actions实现自动部署(CI/CD) 是否觉得这个发布太过于繁琐了？别担心，这里提供两种解决方案！分别是本地 bat 脚本和GitHub actions。\n首先是本地 bat 脚本，这将免除每次发布都要敲至少 5 行指令的痛苦。只需要每次要发布的时候双击运行一下程序即可。\n1 2 3 4 5 6  hugo -D cd public git add . git commit -m \u0026#34;update %date%,%time%\u0026#34; git push origin master pause    另一种方法是前往 GitHub，新建一个仓库。\n点击Actions选择simple workflow，内容如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  name:CI#自动化的名称on:push:# push的时候触发branches:# 那些分支需要触发- masterjobs:build:runs-on:ubuntu-latest# 镜像市场steps:- name:checkout# 步骤的名称uses:actions/checkout@v2.3.4#软件市场的名称with:# 参数submodules:true- name:Setup Hugouses:peaceiris/actions-hugo@v2.4.13with:hugo-version:0.91.2extended:true- name:Buildrun:hugo -D- name:Deployuses:peaceiris/actions-gh-pages@v3with:deploy_key:${{ secrets.ACTIONS_DEPLOY_KEY }}EXTERNAL_REPOSITORY:14772/14772.github.io# 注意要修改本处地址PUBLISH_BRANCH:masterPUBLISH_DIR:./public  值得注意的是在最后一条Deploy中应使用with而非env，应使用deploy_key而非其他的名字。但目前网上大部分教程都没提及这一点，甚至有的还错误地使用！\n然后在本地输入以下命令在当前目录下生成密钥对\n1 2 3 4  ssh-keygen -t rsa -b 4096 -C \u0026#34;$(git config user.email)\u0026#34; -f gh-pages -N \u0026#34;\u0026#34; # You will get 2 files: # gh-pages.pub (public key) # gh-pages (private key)   -t rsa表示 rsa 加密，-b 4096则表示长度为 4096bit，-C后面的是备注，-f后面的是文件名，-N是新密语\n现在前往yourname.github.io仓库，选择Settings \u0026gt; Deploy keys \u0026gt; Add deploy key，勾选 Allow write access，内容为公钥(有pub字样的文件)\n再前往之前存放了master.yml文件的仓库，选择Settings \u0026gt; Secrets \u0026gt; New secret，名称填ACTIONS_DEPLOY_KEY，内容为私钥\n然后在站点根目录下执行以下命令\n1 2  git remote add origin https://github.com/yourname/yourrepo. #此repo为你放了master.yml文件的仓库   现在再来写一个 bat 脚本\n1 2 3  git add . git commit -m \u0026#34;update %date%,%time%\u0026#34; git push origin master   之后直接双击运行它就行了\n注意  如果你自定义了域名，那么你需要在站点根目录static文件夹下新建一个CNAME文件，内容为你的自定义域名！否则每次 deploy 后域名都会变成 yourname.github.io，达不到自定义的目的！   总结：第二种更复杂，但也更好，因为它将源文件也上传到了云端，便于多地更新博客，不至于丢失文章。并且，其在本地占用的内存更小（毕竟网页源代码全在云端），对于文章很多的朋友来说也更友好。\n","permalink":"https://www.sukun.xyz/hugo-1/","tags":["Hugo"],"title":"Hugo博客系列(一)"},{"categories":["计算机网络"],"contents":"浅析“翻墙” 警告  声明   撰写本文是出于学习计算机网络知识，解析技术以及简单普法的目的。不传播、售卖“翻墙”工具，不教授“翻墙”方法，本文也不出现“翻墙”教程。本人对网民浏览本文后做出的不理智行为概不负责！\n什么是“翻墙”？ 首先，我们要知道翻墙翻的是什么？答案是 GFW(Great Fire Wall)也就是长城防火墙。这里借用维基百科来解释：防火长城（英语：Great Firewall，常用简称：GFW），中文也称中国国家防火墙，俗称墙、网络长城、防火墙等等，中国国家互联网信息办公室称为数据跨境安全网关 ，是中华人民共和国政府监控和过滤互联网国际出口内容的软硬件系统集合。随着使用的拓广，“墙”有时也被用作动词，中国网友所说的“被墙”即指网站内容被防火长城所屏蔽或者指服务器的通讯被封阻，“翻墙”也被引申为突破网络审查浏览中国大陆境外被屏蔽的网站或使用服务的行为。\n为什么要“翻墙” 一方面，普通人翻墙原因如下：\n 使用国外的 app 和服务，例如看 YouTube，使用海外版腾讯视频（海外版往往比国内版体验感好，无广告简洁）。 好奇，想见识一下墙外的世界。（这点原因是主要因素，大多数人都是出于这一点） 满足在国内无法实现的欲望，比如逛 P 站（懂的都懂） 与外国人聊天，增长外语水平 做外贸，面外海外经商却不想支付昂贵的官方信道费用 \u0026hellip;\u0026hellip;  另一方面，作为一名程序员，其翻墙原因如下：\n 使用 GitHub，对于一名程序员来说，GitHub 算得上是必需品，根本离不开 逛 StackOverflow 社区，寻找 bug 解决方案 下载、使用专业工具，因为有些工具是海外的，国内没有替代品 查阅文档、学习技术 阅读科研论文、查询数据、与海外团队交流 \u0026hellip;\u0026hellip;  ”翻墙“犯法吗？ 需要明确的是，在这一问题上，国内暂无一个统一见解。但我个人观点是只要不传播、不扩散、不进行违法违规活动，不发表、不转发、不支持反动言论，只是简单地浏览，同时也没有人举报你翻墙了，那么警察也不会闲得来抓你。\n引用  《计算机信息网络国际互联网安全保护管理办法》（以下简称其为“办法”）第5条规定，任何单位和个人不得利用国际互联网制作、复制、查阅和传播下列信息：\n（一）煽动抗拒、破坏宪法和法律、行政法规实施的；\n（二）煽动颠覆国家政权，推翻社会主义制度的；\n（三）煽动分裂国家、破坏国家统一的；\n（四）煽动民族仇恨、民族歧视，破坏民族团结的；\n（五）捏造或者歪曲事实，散布谣言，扰乱社会秩序的；\n（六）宣扬封建迷信、淫秽、色情、赌博、暴力、凶杀、恐怖、教唆犯罪的；\n（七）公然侮辱他人或者捏造事实诽谤他人的；\n（八）损害国家机关信誉的；\n（九）其他违反宪法和法律、行政法规的。\n   如果按照上述规定，那么在翻墙过程中将难免会遇到不良内容，容易触犯该办法。而这也警示我们：不传播、不扩散、不进行有违法律法规的网络活动！\n另一方面，国内翻墙用户众多，所谓法不责众，如果按照翻墙即违法来处办的话，这对于警力要求过高。按照下图显示的份额来看，谷歌 2020 年在中国就有着 3.49% 的市场份额，而 2020 年中国网民共计 9.40亿，不难得出中国有3200万谷歌用户的数据，如果我们保守估计，以其中有一半的人都有着正规渠道访问谷歌（比如各高校、科研实验室、跨国公司、银行等有资质购买专线的），那么具有翻墙能力的人也有 1600 万之巨，这已经是一个庞大的数字，这也是国内对翻墙不再如从前那么敏感的原因之一。\n同时，近些年来国民的民族自豪感、国家认同感大幅提升，这一现象在年轻人身上表现尤为明显，恰如年轻一辈的口号“请党放心，强国有我”。这使得 GFW 封锁国民访问外网的一大原因——防止国外媒体恶意抹黑中国的言论对国民的思想造成影响——不怎么适用，因为国民不再容易被误导了，”国外的空气也不怎么香甜“。并且有能力进行翻墙的人大多数都是接受了高等教育的人，思想较为深刻，有稳固而正确的三观，放他们出去逛一逛问题也不是很大。\n当然了，如果你不是一个普通的翻墙用户，而是以此牟利，那你肯定触犯了法律，必将接受法律的制裁。一方面，你使得国家将面对更多的不可确定因素，因为受传播者不一定遵纪守法，你需要为此负责！\n引用  除了办法中的条例以外，对提供“翻墙”服务的卖家而言，《互联网信息服务管理办法》 规定的惩罚措施更重。\n第 4 条规定：“国家对经营性互联网信息服务实行许可制度；对非经营性互联网信息服务实行备案制度。未取得许可或者未履行备案手续的，不得从事互联网信息服务。”\n第 19 条规定：“违反本办法的规定，未取得经营许可证，擅自从事经营性互联网信息服务，或者超出许可的项目提供服务的，由省、自治区、直辖市电信管理机构责令限期改正，有违法所得的，没收违法所得，处违法所得 3 倍以上 5 倍以下的罚款；没有违法所得或者违法所得不足 5 万元的，处 10 万元以上 100 万元以下的罚款；情节严重的，责令关闭网站。”\n   总结：作为一名普通翻墙用户，只要老老实实地，不犯法。而如果你进行了违法乱纪的活动，或者是翻墙服务提供商或者教授、传播翻墙方法，那就犯法了！\n“翻墙”原理解析 要知道翻墙的原理，我们就得先知道GFW是如何把这堵墙树立起来，如何阻断不正常通信的。\nGFW的封锁 关键字过滤 由于 Http 协议数据包头部是明文的，所以 GFW 一旦发现连接有敏感词，马上就会伪装成连接两方，向真正的对方发送 RST 数据包（重置连接、复位连接），真正的双方一看，出现异常了，TCP连接就会中断掉。表现为有的页面正在打开，然后过了一会又没了，显示无法连接。\nIP封锁 GFW 可以在出境的网关上加一条伪造的路由规则，这样对于一些被过滤了的 IP 的数据包就无法正确地被送达，所以也就无法访问了。GFW 封路由是直接封独立 IP ，这样可能因为某个敏感站点，导致跟他同一台主机的其他站点也无法访问，理解起来就像旁注（从旁注入）。而且 GFW 封 IP 有的时候是直接封 IP 段的，国外几大 VPS 服务商（比如 Bandwagon 搬瓦工）更是重点监测，有时就因为其中一个 IP 不对，GFW 能给你把这整个机房里的服务器的 IP 全封了，当然这样一来难免会有无辜之人中枪。\nDNS污染、劫持 ​\tDNS 也就是域名解析服务，GFW 会对所有经过骨干出口路由的在 UDP 的 53 端口上的域名查询进行检测，一旦发现有黑名单里的域名，它就会伪装成目标域名的解析服务器给查询者返回虚假结果。由于 UDP 是一种无连接不可靠的协议，查询者只能接受最先返回的结果，故而你将看到明明地址栏中的 URL 是对的，但是浏览器渲染的却是不是目标网页或者干脆访问不了。\n特定端口封锁 对于一些特点的 IP ，GFW 会丢弃特定端口上的数据包，使得某些功能无法使用，比如 443 端口 SSL，22 端口的 SSH。\nGWF 曾经干过一件事，针对 Google 的一些 IP 上的 443 端口，实施间歇性封锁，不明所以的用户就会觉得这是 Google 抽风了，久而久之自然不能忍受 “老是出问题” 的产品。同样的还有 GitHub 的 443 端口、前段时间的 steam 的 443 端口也都被间歇性封锁了。\n值得一提的是这个一般是人为干预的，理由就是常发生在白天。加密连接干扰 加密连接不总是加密的，公钥还是明文的，所以 GFW 就能识别出特定服务的证书。然后在遇到 “黑名单” 加密连接时，它会发送RST数据包，干扰双方正常的 TCP 连接，进而切断加密连接的握手。\n主动嗅探 现在我们假设你能伪装你的流量，当它和其他流量混杂在一起时从外观上看没有什么区别，你以为这就可以高枕无忧了？错！事实上，GFW 是被动监测+主动嗅探来实现封锁的，即使一个流量没有任何翻墙特征，但是这股流量太大了，或者时间太长了，GFW 也将主动地发一个连接请求过去，由于这根本就是个假流量，连接返回的内容也不正常，GFW 一看就知道不对劲了，然后再来个人工检测，你不就暴露了么。另一方面，每逢政治敏感时期（比如每年两会、国庆、建党节）或者每年 6 月的大扫除时期，这个时期人工检测大大增多， GFW 敏感系数提升，更容易发现不正常流量，并且从前稳妥起见，只是怀疑还怕误杀的流量，放在这个时期就大概率给你封了。\n对抗GFW的技术 直接访问IP GFW 不是对域名进行各种干扰吗，现在我直接绕过域名解析，对那些还进入监控名单的 IP 直接访问就能躲开 GFW 的干扰。但是很可惜 GFW 对付这种方法的策略也很简单粗暴但有效，那就是见一个封一个。比如早些年谷歌在国内还能正常访问靠的就是大量的镜像 IP，但随着这些年来 GFW 的不懈努力，谷歌服务的 IP 已经被杀绝了。这种办法的失效也就是个时间问题，因为人家封锁只需要找到 IP 然后加入黑名单就行，而被封锁的一方的要付出的努力就大得多了。\nVPN隧道 首先我们明确，虚拟专用网络（VPN）是一门网络技术，而非一个软件，它为我们提供了一种通过公用网络(如最大的公用因特网)安全地对企业内部专用网络进行远程访问的连接方式。在 VPN 隧道中通信能确保通信通道的专用性，并且传输的数据是经过压缩、加密的，所以VPN通信同样具有专用网络的通信安全性。VPN 原本用意是为了让人不在公司也能访问公司内网，但其优越的安全性也让他也有了对抗 GFW 的功能，这里不展开讲解。但是值得注意的是，那些名叫某某加速器、某某 VPN 的翻墙工具往往都不咋地，而且还有跑路的风险，甚至有的还是“家庭小作坊”，而那些大的服务商提供的虽然稳定速度快，但是又是重点监测，譬如某海外服务商的 VPN 长期坚挺，一直加 IP 来对抗 GFW ，但代价就是价格高昂。就像这张图讲的道理：\n代理服务器 这里故意把 VPN 和代理分开，事实上 VPN 也是代理的一种，但其在网络七层协议中跑在数据链路层/第二层，而socks5、Trojan、v2ray之类的则是在OSI七层模型中的第五层/会话层的，（ HTTP 在第七层/应用层， Ping 指令使用 ICMP 协议，工作于第三层/网络层）。而更低层可以代理更高层，更高层代理不了更底层。表现出来的则是你挂了梯子（非 VPN 类）发现依然没法加速 LOL 等游戏（游戏跑网络层），这也是你再挂了梯子之后依然可以用 Ping 来看主机与服务器直接的延迟的原因。但如果开了 VPN ，那他可以加速游戏，可以代理 ICMP 指令。\n说完了 VPN 与这里说的代理的区别，现在再来说常见的几种“翻墙”代理协议。\n注意  世界上没有永远安全的协议，所谓道高一尺，魔高一丈，这是一场长期的军备竞赛，双方都在不断推陈出新！   Socks5 协议与 HTTP 协议 Socks5 把你的网络数据由代理服务器转发到目的地，这个过程中你是没有一条专用通道的，只是数据包的发出，然后被代理服务器收到，然后代理服务器再进行转发，整个过程并没有额外的处理。\n但是在连接建立时、传输流量过程中有着极为明显的流量特征。因此网上也不乏唱衰 Socks5 协议的声音，甚至有流言称 Socks5 协议已被 GFW 攻破，能被其拿捏，但目前暂无明确证据，同时 Socks5协议依然是用的最多的代理协议，因此我对这种观点持保留观点。\n对抗措施：流量加密、反检测、免杀\n Socks5 + HTTP 代理并不会让本来明文传输的浏览加密，但是可以改变请求的 IP，服务器看到访问者的 IP 就是你的代理代理服务器的IP。 如果流量本身没有加密，实战中流控设备很容易识别到客户端连接成功的流量规则。 如果想要加密 Socks5 的流量，则需要安装魔改版 Socks 服务端和客户端，比如著名的 SS/SSR 就是用 Socks5 来实现的，Cobalt Strike 也有相关插件对流量进行加密。  v2ray协议 VMess协议 VMess 协议是由 V2Ray 原创并使用于 V2Ray 的加密传输协议，如同 Shadow socks 一样为了对抗墙的深度包检测而研发的。在 V2Ray 上客户端与服务器的通信主要是通过 VMess 协议通信。\nVLESS协议 VLESS 是一种无状态的轻量级数据传输协议，被定义为下一代 V2ray 数据传输协议。作者对该协议的愿景是“可扩展性空前，适合随意组合、全场景广泛使用，符合很多人的设想、几乎所有人的需求，足以成为 v2ray 的下一代主要协议，乃至整个 XX 界的终极协议。”，由此可见 VLESS 协议的强大。\n注意  VLESS 命名源自“less is more”，写法与 VMess 近似   VLESS和VMESS区别如下：\n VLESS协议不依赖于系统时间，不使用 alterId 。一些人的 V2ray 用不了，最后找出原因是电脑时间和服务器只相差两分钟，简直要让人抓狂；VLESS 协议去掉了时间要求，双手举赞； VLESS 协议不带加密，用于科学上网时要配合TLS等加密手段； VLESS 协议支持分流和回落，比 Nginx 分流转发更简洁、高效和安全； 使用TLS的情况下，VLESS 协议比 VMESS 速度更快，性能更好，因为 VLESS 不会对数据进行加解密； V2ray 官方对 VLESS 的期望更高，约束也更严格。例如要求客户端统一使用 VLESS 标识，而不是 Vless 、vless 等名称；VLESS 分享链接标准将由官方统一制定（尚未出炉）； VLESS 协议的加密更灵活，不像 VMESS 一样高度耦合（仅对开发者有用）  对于普通用户来说，VLESS 协议的主要优势是：1. 不需要客户端和服务器时间一致； 2. VLESS 协议不自带加密，使用 TLS 的情况下性能比 VMESS 更好。\nXTLS协议 XTLS官方库 的介绍仅有一句话：THE FUTURE。V2fly 官网（V2fly 社区是 V2ray 技术的主要推动力量） 称 XTLS为黑科技，VLESS协议作者的形容是：划时代的革命性概念和技术。\nXTLS 的原理是：使用 TLS 代理时，https 数据其实经过了两层 TLS：外层是代理的 TLS，内层是 https 的 TLS。XTLS 无缝拼接了内外两条货真价实的 TLS，使得代理几乎无需再对 https 流量进行数据加解密，只起到流量中转的作用，极大的提高了性能。\nVLESS + XTLS 的组合可以理解为是增强版 ECH，即多支持身份认证、代理转发、明文加密、UDP over TCP 等。但从其原理可知，VLESS + XTLS对http流量是没有多大优势的。好消息是，目前超过 90% 的流量都是 https 的，因此 VLESS + XTLS 能极大的提升性能，无愧于上面的评价。\n注意  需要说明的是，XTLS 是科学上网的 future ，不是 TLS 发展的 future。   Trojan协议 Trojan 协议简单来说是通过 TLS 协议（安全传输层协议）伪装成访问 HTTPS（超文本传输协议）的正常流量。由于 TLS 是一个完整的加密协议通过目前的任何技术手段都无法得到其加密内容，所以 Trojan 的安全性可见一斑。但目前 Trojan 还属于是一个新兴的技术，在各方面都存在问题，但其有着最值得期待的未来，我们需要做的是给予其时间，让其成长。\n在安全性方面，GFW 的主动嗅探主要是其接入目标服务器进行数据检测，而 Trojan 和其他协议不同，当 GFW 接入时不会主动断开介入服务，而是会将接入点连接到一个常规的 web 服务器。这个时候 GWF 就会以为这个服务器是一个常规服务器，从而做出错误的判断。当然，如果是人工来检测，进行了精密的流量分析的话 Trojan 也无能为力。\n找 GFW 的 BUG 这个比较少，就是寻找 GFW 的漏洞，然后依次为突破点来翻墙，这里我也没怎么了解，不做展开。\n注意  最后，如果你有任何想法，欢迎来评论区告诉我！  ","permalink":"https://www.sukun.xyz/%E6%B5%85%E6%9E%90%E7%BF%BB%E5%A2%99/","tags":["翻墙"],"title":"浅析翻墙"},{"categories":["计算机网络"],"contents":"Socket网络编程详解 本部分内容在此不做详细讲解，具体请看这篇文章\n简单的TCP通信代码详解 Server Client TCP网络通信室代码详解","permalink":"https://www.sukun.xyz/tcp%E9%80%9A%E4%BF%A1python%E5%AE%9E%E7%8E%B0/","tags":["python","Socket"],"title":"TCP通信Python实现"},{"categories":null,"contents":"博主相关情况 电科在读学子，软工专业\n兴趣爱好：\n 游戏（PC、手游） 热爱技术 看剧（不多）  主要研究方向：运维\n联系方式：\n email :1477264431@qq.com csdn :https://blog.csdn.net/sk14772 GitHub :https://github.com/14772  创建博客目的 创建本博客主要用于记录学习过程，并防止后面学着学着忘了以前学的内容\n本站相关情况 hugo v0.91.2-1798BD3F+extended windows/amd64 BuildDate=2021-12-23T15:33:34Z VendorInfo=gohugoio\nLoveIt: v0.2.10\n","permalink":"https://www.sukun.xyz/about/","tags":null,"title":"About"},{"categories":["web"],"contents":"快速建站  公网访问 docker部署 SSL证书部署 负载均衡  买好一个 VPS ，拿到 ip 地址和管理员密码，ssh 登录上去\n这里采用 docker 部署，首先利用官方脚本安装 docker 并设置开机自启动\n1 2 3  curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh sudo systemctl enable docker   然后启动 Nginx 镜像的容器，把宿主机8080，8443端口转发到容器的80，443端口\n1  docker run -dit --name web -p 8080:80 -p 8443:443 nginx   然后访问一下ip:8080能看到Nginx欢迎界面\n现在进入容器进行配置，首先是安装 vim ，然后写一个简单的网页文件\n1 2 3 4 5  docker exec -it web bash apt update apt install vim cd /etc/nginx/conf.d vim default.conf   然后修改Nginx配置文件中的 root 位置，修改 server_name 为你要绑定的域名，再重启 Nginx 服务（nginx 配置文件详解见文末）\n1  nginx -s reload   这一步完成后就可以看见你写的网页了\n这里考虑到只有一台服务器，因此我的负载均衡思路是搭建Nginx集群，把刚刚写的配置文件和网页文件拷贝到每一个容器中，配置负载均衡，让其中一个容器成为主服务器\n现在要做的就是把配置文件和网页文件拷贝到宿主机中。(这里我登录的 root 用户，所以拷贝到了 root 目录下)然后再映射这两个文件夹到新创建的Nginx集群的每个容器中去。\n1 2 3 4 5 6  docker cp web:/etc/nginx ~/conf docker cp web:/var/www/html ~/html docker run -d -it -p 8081:80 -p 8444:443 --name web1 -v ~/conf:/etc/nginx -v ~/html:/var/www/html nginx docker run -d -it -p 8082:80 -p 8445:443 --name web2 -v ~/conf:/etc/nginx -v ~/html:/var/www/html nginx   这里以web容器为主服务器，首先查看他们的ip地址，然后编辑web的Nginx配置文件（这里顺手把原来的web容器删除，以映射的方式重建了一下，这样就能直接编辑宿主机中的文件就能编辑到映射到容器中的文件）\n1 2  docker network ls docker network inspect f1c912c35ca8   现在就能根据得到的ip地址编辑web容器的default.conf文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  upstream 172.17.0.2 { server 172.17.0.3 weight=1; server 172.17.0.4 weight=2; } server { listen 80; listen 443 ssl; server_name sukunblog.cn sukunblog.cn 172.17.0.2; ssl_certificate /etc/nginx/sukunblog.cn.pem; ssl_certificate_key /etc/nginx/sukunblog.cn.key; ssl_session_timeout 10m; ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; ssl_ciphers ECDHE-RSA-AES128-GCMSHA256: ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_prefer_server_ciphers on; client_max_body_size 1024m; location / { root /var/www/html; index Hello.html; proxy_set_header HOST $host; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://172.17.0.2; } }   Nginx 配置文件详解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333  ######Nginx配置文件nginx.conf中文详解#####  #定义Nginx运行的用户和用户组 user www www; #nginx进程数，建议设置为等于CPU总核心数。 worker_processes 8; #全局错误日志定义类型，[ debug | info | notice | warn | error | crit ] error_log /usr/local/nginx/logs/error.log info; #进程pid文件 pid /usr/local/nginx/logs/nginx.pid; #指定进程可以打开的最大描述符：数目 #工作模式与连接数上限 #这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。 #现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。 #这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。 worker_rlimit_nofile 65535; events { #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型  #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。  #补充说明：  #与apache相类，nginx针对不同的操作系统，有不同的事件模型  #A）标准事件模型  #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll  #B）高效事件模型  #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。  #Epoll：使用于Linux内核2.6版本及以后的系统。  #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。  #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。  use epoll; #单个进程最大连接数（最大连接数=连接数*进程数）  #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。  worker_connections 65535; #keepalive超时时间。  keepalive_timeout 60; #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。  #分页大小可以用命令getconf PAGESIZE 取得。  #[root@web001 ~]# getconf PAGESIZE  #4096  #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。  client_header_buffer_size 4k; #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。  open_file_cache max=65535 inactive=60s; #这个是指多长时间检查一次缓存的有效信息。  #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.  open_file_cache_valid 80s; #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。  #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location 这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.  open_file_cache_min_uses 1; #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.  open_file_cache_errors on; } #设定http服务器，利用它的反向代理功能提供负载均衡支持 http { #文件扩展名与文件类型映射表  include mime.types; #默认文件类型  default_type application/octet-stream; #默认编码  #charset utf-8;  #服务器名字的hash表大小  #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.  server_names_hash_bucket_size 128; #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。  client_header_buffer_size 32k; #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。  large_client_header_buffers 4 64k; #设定通过nginx上传文件的大小  client_max_body_size 8m; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。  #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。  sendfile on; #开启目录列表访问，合适下载服务器，默认关闭。  autoindex on; #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用  tcp_nopush on; tcp_nodelay on; #长连接超时时间，单位是秒  keepalive_timeout 120; #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。  fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; #gzip模块设置  gzip on; #开启gzip压缩输出  gzip_min_length 1k; #最小压缩文件大小  gzip_buffers 4 16k; #压缩缓冲区  gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）  gzip_comp_level 2; #压缩等级  gzip_types text/plain application/x-javascript text/css application/xml; #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。  gzip_vary on; #开启限制IP连接数的时候需要使用  #limit_zone crawler $binary_remote_addr 10m;  #负载均衡配置  upstream piao.jd.com { #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。  server 192.168.80.121:80 weight=3; server 192.168.80.122:80 weight=2; server 192.168.80.123:80 weight=3; #nginx的upstream目前支持4种方式的分配  #1、轮询（默认）  #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。  #2、weight  #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。  #例如：  #upstream bakend {  # server 192.168.0.14 weight=10;  # server 192.168.0.15 weight=10;  #}  #2、ip_hash  #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。  #例如：  #upstream bakend {  # ip_hash;  # server 192.168.0.14:88;  # server 192.168.0.15:80;  #}  #3、fair（第三方）  #按后端服务器的响应时间来分配请求，响应时间短的优先分配。  #upstream backend {  # server server1;  # server server2;  # fair;  #}  #4、url_hash（第三方）  #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。  #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法  #upstream backend {  # server squid1:3128;  # server squid2:3128;  # hash $request_uri;  # hash_method crc32;  #}  #tips:  #upstream bakend{#定义负载均衡设备的Ip及设备状态}{  # ip_hash;  # server 127.0.0.1:9090 down;  # server 127.0.0.1:8080 weight=2;  # server 127.0.0.1:6060;  # server 127.0.0.1:7070 backup;  #}  #在需要使用负载均衡的server中增加 proxy_pass http://bakend/;  #每个设备的状态设置为:  #1.down表示单前的server暂时不参与负载  #2.weight为weight越大，负载的权重就越大。  #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误  #4.fail_timeout:max_fails次失败后，暂停的时间。  #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。  #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。  #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug  #client_body_temp_path设置记录文件的目录 可以设置最多3层目录  #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡  } #虚拟主机的配置  server { #监听端口  listen 80; #域名可以有多个，用空格隔开  server_name www.jd.com jd.com; index index.html index.htm index.php; root /data/www/jd; #fastcgi解析php  location ~ .*.(php|php5)?$ { #此处有两种方式去和php-fpm交互,一种是9000端口,另一种是使用socket连接  fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; } #图片缓存时间设置  location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$ { expires 10d; } #JS和CSS缓存时间设置  location ~ .*.(js|css)?$ { expires 1h; } #日志格式设定  #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；  #$remote_user：用来记录客户端用户名称；  #$time_local： 用来记录访问时间与时区；  #$request： 用来记录请求的url与http协议；  #$status： 用来记录请求状态；成功是200，  #$body_bytes_sent ：记录发送给客户端文件主体内容大小；  #$http_referer：用来记录从那个页面链接访问过来的；  #$http_user_agent：记录客户浏览器的相关信息；  #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。  log_format access \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; $http_x_forwarded_for\u0026#39;; #定义本虚拟主机的访问日志  access_log /usr/local/nginx/logs/host.access.log main; access_log /usr/local/nginx/logs/host.access.404.log log404; #对 \u0026#34;/\u0026#34; 启用反向代理  location / { proxy_pass http://127.0.0.1:88; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #以下是一些反向代理的配置，可选。  proxy_set_header Host $host; #允许客户端请求的最大单文件字节数  client_max_body_size 10m; #缓冲区代理缓冲用户端请求的最大字节数，  #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。  #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误  client_body_buffer_size 128k; #表示使nginx阻止HTTP应答代码为400或者更高的应答。  proxy_intercept_errors on; #后端服务器连接的超时时间_发起握手等候响应超时时间  #nginx跟后端服务器连接超时时间(代理连接超时)  proxy_connect_timeout 90; #后端服务器数据回传时间(代理发送超时)  #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据  proxy_send_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时)  #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）  proxy_read_timeout 90; #设置代理服务器（nginx）保存用户头信息的缓冲区大小  #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小  proxy_buffer_size 4k; #proxy_buffers缓冲区，网页平均在32k以下的设置  #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k  proxy_buffers 4 32k; #高负荷下缓冲大小（proxy_buffers*2）  proxy_busy_buffers_size 64k; #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长  #设定缓存文件夹大小，大于这个值，将从upstream服务器传  proxy_temp_file_write_size 64k; } #设定查看Nginx状态的地址  location /NginxStatus { stub_status on; access_log on; auth_basic \u0026#34;NginxStatus\u0026#34;; auth_basic_user_file confpasswd; #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。  } #本地动静分离反向代理配置  #所有jsp的页面均交由tomcat或resin处理  location ~ .(jsp|jspx|do)?$ { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080; } #所有静态文件由nginx直接读取不经过tomcat或resin  location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt| pdf|xls|mp3|wma)$ { expires 15d; } location ~ .*.(js|css)?$ { expires 1h; } } } ######Nginx配置文件nginx.conf中文详解#####   ","permalink":"https://www.sukun.xyz/%E7%AE%80%E6%98%93%E5%BB%BA%E7%AB%99/","tags":["Nginx"],"title":"简易建站"},{"categories":null,"contents":"","permalink":"https://www.sukun.xyz/search/","tags":null,"title":"Search"}]