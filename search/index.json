[{"categories":["算法与数据结构"],"contents":"递归时间复杂度求解 master公式使用 $$ T(N)=a*T(\\frac{N}{b})+O(N^d)\\\\ \\log(b,a)\u0026gt;d\\qquad时间复杂度O(N^{\\log(b,a)})\\\\ \\log(b,a)=d\\qquad时间复杂度O(N^d*\\log{N})\\\\ \\log(b,a)\u0026lt;d\\qquad时间复杂度O(N^d)\\\\ $$\nN为母问题的规模级别，子问题规模都是$\\frac{N}{b}$，a是子问题调用次数，$O(N^d)$是除了调用子问题以外的过程的时间复杂度\n举个栗子  1 2 3 4 5 6 7 8 9  int process(int arr[], int L, int R) { if (L == R) return arr[L]; int mid = L + (R - L) \u0026gt;\u0026gt; 1; //求中点  int LMax = process(arr, L, mid); int RMax = process(arr, mid + 1, R); return RMax \u0026gt; LMax ? LMax : RMax; }   该递归算法时间复杂度： $$ T(N)=2*T(\\frac{N}{2})+O(1) $$\n   ","permalink":"https://www.sukun.xyz/%E9%80%92%E5%BD%92%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%B1%82%E8%A7%A3/","tags":["算法","学习"],"title":"递归时间复杂度求解"},{"categories":["笔记"],"contents":"问题一 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;stdio.h\u0026gt; int main() { int i = 0; int arr[10] = {0}; for ( i = 0; i \u0026lt;= 12; i++) { arr[i] = 0; //请问在VS2019编译器下打印多少次hello？  printf(\u0026#34;hello\\n\u0026#34;); } return 0; }   答案  死循环打印hello。\n这是由于 C 语言的栈机制导致的：\n因此，当数组越界时将有可能访问到其他变量，在这里恰好是循环控制条件 i，这也就导致了死循环的发生！\n值得一提的是，VS预留两个空间，GCC是连续空间，VC6.0预留一个空间。\n   类似的还有下面这个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;stdio.h\u0026gt; int main() { char s[] = {\u0026#34;hello world\u0026#34;}; char s1[10]; printf(\u0026#34;%s \\n\u0026#34;, s); printf(\u0026#34;%s\\n\u0026#34;, s1); //请问在VS2019编译器下打印什么？  return 0; } /* 输出： hello world 烫烫烫烫烫烫烫烫烫烫hello world */   同样的道理，在打印s1时，由于未赋值，而 VS 会给其赋0xcccc cccc，也就是烫，又因为没有\\0作为结尾，因此其会一直按栈区顺序寻找，直到遇到\\0为止。\n问题二 给定一个数组，其中有唯二奇数个数的数，其余数均为偶数个数，请找出这两个数。要求时间复杂度$O(n)$，空间复杂度$O(1)$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  int *solution(int nums[], int nums_size) { int i, eor, cur, result[2]; eor = 0; for (i = 0; i \u0026lt; nums_size; i++) eor ^= nums[i]; int rightOne = eor \u0026amp; (~eor + 1); //提取出最右侧的1  int onlyOne = 0; for (i = 0; i \u0026lt; nums_size; i++) { cur = nums[i]; if (!(cur \u0026amp; rightOne)) onlyOne ^= cur; } result[0] = onlyOne; result[1] = onlyOne ^ eor; return result; } /* 输入： [1,2,2,3,3,3,4,4,4,4],10 输出： [1,3] */   ","permalink":"https://www.sukun.xyz/c%E8%AF%AD%E8%A8%80%E9%9A%BE%E9%A2%98%E9%9B%86%E4%B8%80/","tags":["C","学习"],"title":"C语言难题集(一)"},{"categories":["常见问题"],"contents":"本地定时脚本 python脚本 本脚本修改自GitHub开源项目\n本脚本功能：乐健体育跑 3.5km 并活动打卡。\n要执行本脚本，你需要安装legym模块\n1  pip install -i https://test.pypi.org/simple legym==0.4   代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  from _datetime import datetime import legym # 注意修改本处账户密码 def run(activity, username=\u0026#39;#\u0026#39;, password=\u0026#39;#\u0026#39;, distance=\u0026#39;3.5\u0026#39;): print(\u0026#34;Login...\u0026#34;, end=\u0026#34;\u0026#34;) user = legym.login(username, password) print(\u0026#34;success\u0026#34;) print(\u0026#34;Running...\u0026#34;, end=\u0026#34;\u0026#34;) actual_distance, success = user.running(float(distance)) if success: print(f\u0026#34;{actual_distance}km\u0026#34;) else: print(\u0026#34;failed\u0026#34;) print(\u0026#34;Registering...\u0026#34;, end=\u0026#34;\u0026#34;) _, success, _ = user.register(name=activity) if success: print(\u0026#34;success\u0026#34;) else: print(\u0026#34;failed\u0026#34;) print(\u0026#34;Signing...\u0026#34;, end=\u0026#34;\u0026#34;) results = user.sign() for result in results: if result[1]: print(\u0026#34;success\u0026#34;) else: print(\u0026#34;failed\u0026#34;) def weekday(): week = datetime.today().isoweekday() week_chinese = {1: \u0026#39;周一\u0026#39;, 2: \u0026#39;周二\u0026#39;, 3: \u0026#39;周三\u0026#39;, 4: \u0026#39;周四\u0026#39;, 5: \u0026#39;周五\u0026#39;, 6: \u0026#39;周六\u0026#39;, 7: \u0026#39;周日\u0026#39;} return week_chinese[week] if __name__ == \u0026#39;__main__\u0026#39;: act = \u0026#39;第三空间\u0026#39;+weekday()+\u0026#39;沙河校区体育场\u0026#39; run(act)   任务计划程序 打开计算机管理\n点击 系统工具 \u0026raquo;\u0026gt; 任务计划程序 \u0026raquo;\u0026gt; 创建基本任务\n自主填写任务名称与描述 \u0026raquo;\u0026gt; 选择每天 \u0026raquo;\u0026gt; 选择执行时间 \u0026raquo;\u0026gt; 选择启动程序\n 程序或脚本：python.exe 或 pythonw.exe 的路径，选择后者不会出现 IDE 窗口 添加参数：python脚本路径 起始于：Python编译器路径  当然，你也可以用pyinstaller将 python 文件打包为 exe 可执行文件，这样一来只需要将可执行文件路径添加到程序或脚本栏即可。\n完成后可在 任务计划程序库 中查看。\n","permalink":"https://www.sukun.xyz/%E6%9C%AC%E5%9C%B0%E5%AE%9A%E6%97%B6%E8%84%9A%E6%9C%AC/","tags":["windows","python"],"title":"本地定时脚本"},{"categories":["算法与数据结构"],"contents":"数据结构——用C语言描述(九) 技术 排序 内部排序 排序的基本概念 排序 记录序列：{$R_1,R_2,\u0026hellip;,R_n$}\n关键字序列：{$K_1,K_2,\u0026hellip;,K_n$}\n重排记录序列，得{$Rp_1,Rp_2,\u0026hellip;,Rp_n$}，使相应关键字满足非递减（或非递增）关系，\n即$Kp_1≤Kp_2≤\u0026hellip;≤Kp_n$\n内部排序与外部排序 根据排序时数据所占用存储器的不同，可将排序分为两类：\n 内部排序：整个排序过程完全在内存中进行 外部排序：由于待排序数据量太大，内存无法容纳全部数据，排序需借外存才能完成  排序的稳定性  稳定排序：在排序过程中，相同关键字（$K_i=K_j$,i\u0026lt;j）其领先关系不发生变化——需从算法本身步骤中证明 不稳定排序：在排序过程中，相同关键字（$K_i=K_j$,i\u0026lt;j）其领先关系发生变化——仅需举反例即可证明不稳定  基本操作  比较两个关键字的大小 将记录从一个位置移动到另一个位置  存储方法   向量结构：\n将待排序的记录存放在一组地址连续的存储单元中\n  链表结构\n  地址排序\n  插入类排序 插入排序基本思想 已排序记录子集基础上，将下一个待排序记录有序插入到已排序记录子集，直到将所有待排序记录全部插入。\n直接插入排序   算法思想：将第 i 个插入到前 i-1 个有序集合。\n  算法要点：\n 监视哨r[0]保存待插入的记录 方向从后往前查找插入位置 查找与移动用同一循环完成    算法实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  void InsSort(RecordType r[], int length) //对记录数组r做直接插入排序, length为数组的长度 { int i, j; for (i = 2; i \u0026lt; length; i++) //将待插入记录存放到监视哨r[0]中  { r[0] = r[i]; j = i - 1; while (r[0].key \u0026lt; r[j].key) //寻找插入位置  { r[j + 1] = r[j]; j--; } r[j + 1] = r[0]; //将待插入记录插入已排序的序列中}  } }     算法分析：\n  最好情况：\n有序的待排序序列——比较次数 n-1 次，移动次数 2(n-1) 次\n  最坏情况：\n待排序记录为逆序排列——总比较次数： $$ \\sum_{i=2}^ni=\\frac{(n+2)(n-1)}{2} $$ 记录移动次数： $$ \\sum_{i=2}^n(i+1)=\\frac{(n+4)(n-1)}{2} $$ 故直接插入排序的时间复杂度为$T(n)=O(n^2)$\n  直接插入排序是稳定排序：\n从后向前进行算法while(r[0].key\u0026lt;r[j] key)相同元素插入到r[j+1]\n    折半排序   算法改进要点：改进确定插入位置方法\n  算法描述：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  void BinSort(RecordType r[], int length) //对数组r进行折半插入排序，length为数组长度 { int i, j, low, high, mid; RecordType x; for (i = 2; i \u0026lt; length; i++) { x = r[i]; low = 1; high = i - 1; while (low \u0026lt;= high) //确定插入位置  { mid = (low + high) / 2; if (x.key \u0026lt; r[mid].key) high = mid - 1; else low = mid + 1; } for (j = i - 1; j \u0026gt;= low; --j) r[j + 1] = r[j]; //记录依次向后移动  r[low] = x; //插入记录  } }     算法分析：\n折半插入可减少关键字的比较次数，但移动次数没有减少，故折半插入排序的总的时间复杂度仍然是$O(n^2)$。\n每插入一个元素，最大的比较次数为折半判定树的深度。\n插入第 i 个元素，设$i=2^j$，则需进行$\\log_2i$次比较，插入 n-1 个元素的平均关键字的比较次数为$O(n\\log_2n)$\n折半排序是稳定排序：待插入元素 x 位于有序序列之后，经过条件比较，元素相等时，其插入位置low=mid+1右部子表\n  希尔排序（缩小增量排序）   算法改进要点：\n利用直接插入排序的最佳性质：n 比较小、基本有序。\n 将记录序列分成若干个子序列分别进行直接插入排序 经多次调整序列记录已基本有序最后再对记录进行直接插入排序    算法思想：\n 对整个文件，按间隔$d_1$分组，组内排序 取$d_2\u0026lt;d_1$（缩小增量），继续以$d_2$为距离排序，直到$d_t=1$（同直接插入排序）为止    算法描述：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  void ShellInsert(RecordType r[], int length, int delta) //对记录数组r做一趟希尔插入排序，length为数组长度，delta为增量 { int i, j; for (i = 1 + delta; i \u0026lt;= length; i++) // 1+delta为第一个子序列的第二个元素的下标  if (r[i].key \u0026lt; r[i - delta].key) { r[0] = r[i]; //备份r[i]（不做监视哨）  for (j = i - delta; j \u0026gt; 0 \u0026amp;\u0026amp; r[0].key \u0026lt; r[j].key; j -= delta) r[j + delta] = r[j]; r[j + delta] = r[0]; } } void ShellSort(RecordType r[], int length, int delta[], int n) //对记录数组r做希尔排序，length为数组r长度，delta为增量数组，n为delta[]的长度 { for (int i = 0; i \u0026lt;= n - 1; i++) ShellInsert(r, length, delta[i]); }     算法分析：\n信息  逆转数是指在此关键字之前比它大的数据个数\n   待排序序列 46 55 13 42 94 17 05 90     逆转数$B_i$ 0 0 2 2 0 4 6 1         希尔排序比直接插入排序更快：\n直接插入排序：一次比较移动只减少一个逆转数\n希尔排序：一次比较移动减少逆转数有可能不止一个\n  根据经验公式可给出缩小增量的取法：\nShell 提出$d=\\frac{n}{2}$，$d=\\frac{d}{2}$，直到 d=1为止\n奇数位置元素在最后一趟才会与偶数位置比较，效率较低\nknuth 提出$d=\\frac{d}{3}+1$\n  希尔排序时间复杂度为$O(n^{\\frac{3}{2}})$\n  希尔排序是不稳定排序：\n例如待排序列 {2,4,1,2}，进行希尔排序后变为 {1,2,2,4}，其中相同关键字 2 的领先关系发生了变化。\n    交换类排序 交换排序基本思想 通过一系列交换逆序元素进行排序\n冒泡排序（相邻比序法）   算法思想\n顺次比较相邻两元素大小，若逆序就交换位置，反复扫描，直到待排序记录没有逆序为止。\n  算法描述\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  void BubbSort(RecordType r[], int length) //冒泡排序 { int i, j, n, change; RecordType x; n = length; change = true; for (i = 1; i \u0026lt;= n - 1 \u0026amp;\u0026amp; change; i++) { change = false; for (j = 1; j \u0026lt;= n - i; j++) if (r[j].key \u0026gt; r[j + 1].key) { x = r[j]; r[j] = r[j + 1]; r[j + 1] = x; change = true; } } }     算法分析：\n最坏情况——关键字逆序排列，第 i 趟需 n-i 次比较，3(n-i) 次移动经过 n-1 趟冒泡排序：\n 比较次数$\\frac{n(n-1)}{2}$ 移动次数$\\frac{3n(n-1)}{2}$ 时间复杂度$O(n^2)$ 空间复杂度$O(1)$    快速排序   改进要点：\n通过两个不相邻元素的比较，一次交换可能消除多个逆序，大大加快排序速度。\n  算法思想：\n选序列中一个枢轴元（选第 1 个其关键字$K_1$）以枢轴元素为界，分为两个子表小于$K_1$在前部子表，大于$K_1$在后部子表，对两个子表继续如上过程，直到所有子表的表长不超过 1 为止。\n  算法描述：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  int QKPass(RecordType r[], int left, int right) //一趟排序 { int low, high; RecordType x; x = r[left]; low = left; high = right; while (low \u0026lt; high) { while (low \u0026lt; high \u0026amp;\u0026amp; r[high].key \u0026gt;= x.key) high--; //从右到左找小于x.key的记录  if (low \u0026lt; high) { r[low] = r[high]; low++; //置入左r[low]  } while (low \u0026lt; high \u0026amp;\u0026amp; r[low].key \u0026lt;= x.key) low++; //从左到右找大于x.key的记录  if (low \u0026lt; high) { r[high] = r[low]; high--; //置入右r[high]  } } r[low] = x; return low; } void QKSort(RecordType r[], int low, int high) //快速排序 { int pos; if (low \u0026lt; high) { pos = QKPass(r, low, high); //枢轴位置  QKSort(r, low, pos - 1); //前部子表  QKSort(r, pos + 1, high); //后部子表  } }     算法分析：\n  最好情况：\n每趟将序列一分两半，正好在表中间，将表分成两个大小相等的子表，类似折半查找\n时间复杂度$O(n\\log_2n)$\n  最坏情况：\n已经排好序共需进行 n- 1 趟排序,其比较次数为： $$ \\sum_{i=1}^{n-1}(n-i)=\\frac{n(n-1)}{2} $$ 时间复杂度$O(n^2)$\n  平均时间复杂度：$T_{avg}(n)=n\\log_2n$\n    选择类排序 选择排序基本思想 每一趟在 n-i+1 (i=1,2,…n-1) 个记录中选取关键字最小的记录作为有序序列中第 i 个记录\n简单选择排序   算法思想：第 i 趟排序从 n-i+1 个记录中选出关键字最小的记录，并和第 i 个元素进行交换\n  算法描述：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  //对记录数组r做简单选择排序，n为数组长度 void SelectSort(RecordType r[], int n) { int i, j, k; RecordType x; for (i = 1; i \u0026lt;= n - 1; i++) { k = i; for (j = i + 1; j \u0026lt;= n; j++) if (r[j].key \u0026lt; r[k].key) k = j; if (k != i) { x = r[i]; r[i] = r[k]; r[k] = x; } } }     算法分析：\n  最好情况：\n待排序记录初始状态就已经是正序排列了，则不需要移动记录\n  最坏情况：\n待排序记录初始状态是按逆序排列的，则需要移动记录的次数最多为 3(n-1)\n  时间复杂度：\n由于每次都没有利用上次比较的结果，故时间复杂度为$O(n^2)$\n  简单选择排序是不稳定排序：\n例如，待排序列 {3,3,2} 经过简单选择排序变为 {2,3,3}，相同关键字 3 的领先关系发生了变化\n    树形选择排序   算法改进要点：\n把比较过程中的大小关系保存下来以降低比较次数\n  基本思想：\n  把待排序的 n 个记录的关键字两两进行比较，取出较小者\n  在$[\\frac{n}{2}]$个较小者中，采用同样的方法进行比较选出每两个中的较小者。如此反复，直至选出最小关键字记录为止\n    算法分析：\n每趟选出较小关键字需$\\log_2n$次比较，n 趟比较时间复杂度$O(n\\log_2n)$\n移动记录次数不超过比较次数。\n总的时间复杂度为$O(n\\log_2n)$。\n与简单选择排序相比较，其降低了比较次数的数量级，增加了 n-1个非叶子节点的辅助存储空间也就是以空间换时间。\n  堆排序   算法改进要点\n将待排序数组看成一棵完全二叉树，结点r[i]的左孩子是r[2i]，右孩子r[2i+1]，双亲是r[i/2]。\n通过调整完全二叉树建堆及重建堆选择出关键字最小记录及次小记录等实现排序。\n  算法思想\n  堆\n将待排序数组 r 看成一棵完全二叉树的顺序表示，对二叉树进行调整，满足下列条件为堆：\n$r[i].key≥r[2i].key$并且$r[i].key≥r[2i+1].key$ (i=1,2,…)\n或者$r[i].key≤r[2i].key$并且$r[i].key≤r[2i+1].key$ (i=1,2,…)\n  大根堆：完全二叉树中任意节点的关键字大于或等于其左孩子和右孩子的关键字\n  小根堆：完全二叉树中任意节点的关键字小于或等于其左孩子和右孩子的关键字\n    堆排序问题\n以大根堆为例\n  按堆定义建初堆\n  去掉最大元之后重建堆，得到次大元\n  如此类推\n    重建堆：当堆顶记录改变时，如何重建堆？\n  将完全二叉树根结点中关键字 x 移出，此时根结点相当于空结点\n  从左、右孩子中选出关键字最大的记录,如果该记录的关键字大于 x，则将该记录上移至空结点\n  重复上述过程，直到空结点左、右孩子关键字均不大于 x，此时，将待调整记录 x 放入空结点即可\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  //重建堆，r[k..m]是以r[k]为根的完全二叉树，其左右子树为大根堆 void sift(RecordType r[], int k, int m) { RecordType t; KeyType x; int i, j; bool finished; t = r[k]; //暂存根记录r[k]  x = r[k].key; i = k; j = 2 * i; finished = false; while (j \u0026lt;= m \u0026amp;\u0026amp; !finished) { if (j \u0026lt; m \u0026amp;\u0026amp; r[j].key \u0026lt; r[j + 1].key) //若存在右子树且根的关键字大则沿右分支筛选  j++; if (x \u0026gt;= r[j].key) //筛选完备  finished = true; else //继续筛选  { r[i] = r[j]; i = j; j = 2 * i; } } r[i] = t; // r[k]填入到恰当位置 }     建初堆：如何由一个任意序列建初堆？\n筛选需从最后一个子树位置$\\lfloor\\frac{n}{2}\\rfloor$开始，可以反复利用重建堆法自底向上，把所有的子树逐层调整为堆，直至根结点。\n1 2 3 4 5 6 7 8  //对记录数组r重建堆，length为数组长度 void crt_heap(RecordType r[], int length) { int i, n; n = length; for (i = n / 2; i \u0026gt;= 1; i--) //自第i个记录开始筛选建堆  sift(r, i, n); }     堆排序算法：\n 建初堆：从最后一子树$\\frac{n}{2}$直到根建堆 将（堆顶）第一个元素与最后一个元素互换;去掉最后元素，将剩余元素调整建堆，再转出堆顶元素 重复执行步骤 2、3 共 n-1 次，直到序列有序  1 2 3 4 5 6 7 8 9 10 11 12 13 14  //对r[1..n]堆排序，关键字由大到小排序 void HeapSort(RecordType r[], int length) { int i, n; RecordType b; crt_heap(r, length); //建初堆  n = length; for (i = n; i \u0026gt;= 2; i--) //将堆顶记录和堆的最后一个记录互换  { b = r[1]; r[i] = b; sift(r, 1, i - 1); //进行调整，使r[1..i-1]变成堆  } }       算法分析：\n  重建堆的时间复杂度为$O(n\\log_2n)$需 n-1 次重建堆\n建初堆时间复杂度为$O(n\\log_2n)$，堆排序时间复杂度为$O(n\\log_2n)$\n  堆排序与树型排序相比较，排序中只需要存放一个记录的辅助空间，因此也将堆排序称作原地排序\n  堆排序是一种不稳定的排序方法，它不适用于待排序记录个数 n 较少的情况，但对 n 较大的文件还是很有效的\n       选择类排序比较 时间复杂度 空间复杂度     简单选择 $O(n^2)$ $O(1)$   树型选择 $O(n\\log_2n)$ $O(n)$   堆排序 $O(n\\log_2n)$ $O(1)$    归并类排序 基本思想 基于合并的思想，将两个或两个以上有序表合并成一个新的有序表。\n2-路归并排序：\n 初始：n 个记录看成 n 个长度为 1 的有序子序列 两两归并得$\\lfloor\\frac{n}{2}\\rfloor$个长度为 2 的有序子序列 两两归并得到若干个长度为 4 的有序子序列 i 如此重复，直到得到长度为n的有序序列为止  算法描述 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  //初始调用，对数组r[1..n]做归并排序 void MergeSort(RecordType r[], int n) { MSort(r, 1, n, r); } //一趟合并算法 void Merge(RecordType r1[], int low, int mid, int high, RecordType r[]) { int i, j, k; i = low; j = mid + 1; k = low; while ((i \u0026lt;= mid) \u0026amp;\u0026amp; (j \u0026lt;= high)) //对序列的前后两半部分进行比较  { if (r1[i].key \u0026lt;= r1[j].key) { r[k] = r1[i]; i++; } else { r[k] = r1[j]; j++; } k++; } while (i \u0026lt;= mid) //合并两个子序列  { r[k] = r1[i]; k++, i++; } while (j \u0026lt;= high) { r[k] = r1[j]; k++, j++; } } // r1[low..high]归并排序后放入r3[low..high] void MSort(RecordType r1[], int low, int high, RecordType r3[]) { int mid; RecordType r2[N]; //辅助空间  if (low == high) r3[low] = r1[low]; else { mid = (low + high) / 2; MSort(r1, low, mid, r2); //前半部分归并  MSort(r1, mid + 1, high, r2); //后半部分归并  Merge(r2, low, mid, high, r3); // r2合并放入r3  } }   算法分析   一趟归并排序的时间复杂度为$O(n)$，将r1[1..n]前后两个有序子表归并后并存放到r2[1..n]中\n  归并排序的时间复杂度为$O(n\\log_2n)$，整个归并排序进行$\\log_2n$趟2-路归并，每趟归并是$O(n)$\n  归并排序的空间复杂度为$O(n)$，归并排序需用到与待排序序列等量的辅助空间r2[n]\n这也使归并排序适合于外部排序：\n 归并路数取决于外部设备的台数 归并长度取决于内存缓冲区的容量 支持外存分批并行调入内存，提高效率    归并排序是稳定排序：\n在一趟归并算法中，前部相同元素先于后部置入归并排序后的表，使其相同关键字的领先关系不发生变化。\n  分配类排序 利用基于分配的思想通过分配和叫收集两种操作实现排序。\n多关键字排序  高位优先排序法 低位优先排序法  注意  字典就是采用的多关键字排序   链式基数排序   存储结构：用链表存储待排序表\n  排序思想：多趟分配和收集完成排序（趟数为关键字位数）\n  基数 RD：关键字符号的个数（十进制的基数为 0~9）\n  算法思想：\n按最低位的值对记录进行初步排序，在此基础上按次低位的值进行进一步排序，按由低向高，直到最高位，关键字的每一位都排序。\n  算法描述：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  #define RADIX 10 #define KEY_SIZE 6 #define LIST_SIZE 20 typedef struct { KeyType key[KEY_SIZE]; //子关键字数组  OtherType other_data; //其他数据项  int next; //静态链域 } RecordType1; typedef struct { RecordType1 r[LIST_SIZE + 1]; // r[0]为头结点  int length; int keynum; } SLinkList; //静态链表 typedef int PVector[RADIX]; PVector head, tail; void RadixSort(RecordType1 r[], int length, int keynum) { int d, i, n; n = length; for (i = 0; i \u0026lt; n; i++) //构造动态链表  r[i].next = i + 1; r[n].next = 0; d = keynum; for (i = d - 1; i \u0026gt;= 0; i--) //从最低位子关键字开始，进行d趟分配收集  { Distribute(r, i, head, tail); //第i趟分配  Collect(r, head, tail); //第i趟收集  } } void Distribute(RecordType1 r[], int i, PVector head, PVector tail) { int j, p; for (j = 0; j \u0026lt;= RADIX - 1; j++) head[j] = 0; // RADIX个队列初始化为空  p = r[0].next; while (p) { j = Order(r[p].key[i]); //用第i位关键字求相应队列号  if (!head[j]) head[j] = p; //将p结点插入第j个队列  else r[tail[j]].next = p; tail[j] = p; p = r[p].next; } } void Collect(RecordType1 r[], PVector head, PVector tail) { int j, t; while (!head[j]) //找第一个非空队列  j++; r[0].next = head[j]; t = tail[j]; while (j \u0026lt; RADIX - 1) //寻找并串接所有非空队列  { j++; while ((j \u0026lt; RADIX - 1) \u0026amp;\u0026amp; (!head[j])) j++; //找下个非空队列  if (head[j]) //链接非空队列  { r[t].next = head[j]; t = tail[j]; } } r[t].next = 0; }     算法分析：\n n 个记录（每记录含 d 位,每位取值 RD 个值） 一趟分配算法的时间复杂度为$O(n)$ 一趟收集算法的时间复杂度为$O(RD)$ 共进行 d 趟分配与收集，总时间复杂度为$O(d(n+RD))$ 辅助空间为$O(RD)$    基数排序的顺序表实现 按照稀疏矩阵转置中的统计方法实现\n例：待排序序列218，109，063，930，589，184，505，269，008，083\n关键字$k_1、k_2、k_3$，$k_3$位扫描，统计$k_3$位为 0 到 9 的记录个数num[10]\n结果如下：\n    0 1 2 3 4 5 6 7 8 9     num[] 1 0 0 2 1 1 0 0 2 3   cpos[] 0 1 1 1 3 4 5 5 5 7    $k_3$位上值为 i 的记录在排好序向量中第一次出现位置cpos[i]，由cpos[0]=0可确定cpos[i]=cpos[i-1]+num[i-1]，完成按$k_3$位进行的排序。\n$k_2$和$k_1$位以此类推，分别统计、定位与置放，完成基数排序。\n比较 性能比较     平均时间复杂度 最坏时间复杂度 辅助存储空间     简单排序 $O(n^2)$ $O(n^2)$ $O(1)$   快速排序 $O(n\\log_2n)$ $O(n^2)$ $O(1)$   堆排序 $O(n\\log_2n)$ $O(n\\log_2n)$ $O(1)$   归并排序 $O(n\\log_2n)$ $O(n\\log_2n)$ $O(n)$   基数排序 $O(d(n+RD))$ $O(d(n+RD))$ $O(rd)$    稳定性比较     稳定性 反例     直接插入排序 是    冒泡排序 是    简单选择排序 否 (3,3,2)   希尔排序 否 (2,4,1,2)，$d_1$=2,$d_2$=1   快速排序 否 (3,2,2)   堆排序 否 (5,5,3)   归并排序 是    基数排序 是     结论  简单排序一般只用于n较小的情况。当序列中的记录基本有序时，直接插入排序是最佳的排序方法，其常与其他排序方法组合使用 快速排序平均时间性能是最好的 堆排序和归并排序的最坏时间复杂度仍为$O(n\\log_2n)$，当n较大时，归并排序的时间性能优于堆排序，但它所需的辅助空间最多 基数排序最适用于n很大而关键字的位数d较小的序列。 ","permalink":"https://www.sukun.xyz/data_structure-9/","tags":["数据结构","学习"],"title":"数据结构学习(九)"},{"categories":["青龙面板"],"contents":"青龙面板教程 前期准备 首先你要有一台服务器（国内鸡需要有代理），一个域名和 SSL证书（可选）。我这里的服务器系统为 Ubuntu-20.03\nssh 登录上去，安装 docker，此处采用官方脚本一键安装并设置开机自启。\n1 2 3  curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh sudo systemctl enable docker   部署 docker启动容器 启动容器（项目地址：https://github.com/whyour/qinglong）：\n1 2 3 4 5 6 7 8 9 10 11 12  docker run -dit \\  -v $PWD/ql/config:/ql/config \\  -v $PWD/ql/log:/ql/log \\  -v $PWD/ql/db:/ql/db \\  -v $PWD/ql/repo:/ql/repo \\  -v $PWD/ql/raw:/ql/raw \\  -v $PWD/ql/scripts:/ql/scripts \\  -p 5700:5700 \\  --name qinglong \\  --hostname qinglong \\  --restart unless-stopped \\  whyour/qinglong:latest   其中-dit是后台运行、交互式操作、终端，-v是映射，-p是端口转发，--name是容器命名，--hostname是主机名，--restart unless-stopped是容器退出时总是重启，镜像是whyour/qinglong:latest\n接着放行 5700 端口：\n1  ufw allow 5700   在浏览器地址栏键入ip:5700即可访问，由于是第一次访问，需要进行初始化：\n通知设置，可以采用钉钉、server酱等方式\n然后是账号密码设置，本处不赘述。\n反向代理 接着就可以正常使用了，但你肯定不会满足于用ip:5700的方式访问的，于是我还需要用到Nginx反向代理：\n本处默认你已经部署好了 SSL证书，因此只讲解修改Nginx配置文件（可以用nginx -t指令找到配置文件位置）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  server { listen 80; listen [::]:80; listen 81 http2; server_name 你的域名; #修改本处域名  root /usr/share/nginx/html; location / { #反向代理  proxy_ssl_server_name on; proxy_pass http://ip:5700; #修改本处ip  proxy_set_header Accept-Encoding \u0026#39;\u0026#39;; #过滤器模块  sub_filter \u0026#34;ip:5700\u0026#34; \u0026#34;你的域名\u0026#34;; #修改本处  sub_filter_once off; } }   修改完后重启 Nginx 服务\n1  nginx -s reload   这样一来你就可以在浏览器中键入域名来访问青龙面板了！\n配置环境变量 在浏览器地址栏键入m.jd.com访问京东手机版网页，使用手机验证码登录，按下F12在Cookies中找到pt_key、pt_pin，复制下来，在面板中点击环境变量，点击添加变量，将刚刚复制的内容填入对应位置（一行一个 cookie）：\n设置拉取脚本任务 在面板中的定时任务，点击添加任务：\n意为每日 0时0分 执行命令栏中的指令（项目地址：https://github.com/Yun-City/City）：\n1  ql repo https://github.com/Yun-City/City.git \u0026#34;jd_|jx_|gua_|jddj_|getJDCookie\u0026#34; \u0026#34;activity|backUp\u0026#34; \u0026#34;^jd[^_]|USER|function|utils|sendnotify|ZooFaker_Necklace|jd_Cookie|JDJRValidator_|sign_graphics_validate|ql|magic|cleancart_activity\u0026#34;   添加完成后运行一次该任务即可拉取脚本，然后就可以静静等待其运行了。\n常见问题解决 ql指令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  # 更新并重启青龙 ql update # 运行自定义脚本extra.sh ql extra # 添加单个脚本文件 ql raw \u0026lt;file_url\u0026gt; # 添加单个仓库的指定脚本 ql repo \u0026lt;repo_url\u0026gt; \u0026lt;whitelist\u0026gt; \u0026lt;blacklist\u0026gt; \u0026lt;dependence\u0026gt; \u0026lt;branch\u0026gt; # 删除旧日志 ql rmlog \u0026lt;days\u0026gt; # 启动tg-bot ql bot # 检测青龙环境并修复 ql check # 重置登录错误次数 ql resetlet # 禁用两步登录 ql resettfa # 依次执行，如果设置了随机延迟，将随机延迟一定秒数 task \u0026lt;file_path\u0026gt; # 依次执行，无论是否设置了随机延迟，均立即运行，前台会输出日，同时记录在日志文件中 task \u0026lt;file_path\u0026gt; now # 并发执行，无论是否设置了随机延迟，均立即运行，前台不产生日，直接记录在日志文件中，且可指定账号执行 task \u0026lt;file_path\u0026gt; conc \u0026lt;env_name\u0026gt; \u0026lt;account_number\u0026gt;(可选的) # 指定账号执行，无论是否设置了随机延迟，均立即运行  task \u0026lt;file_path\u0026gt; desi \u0026lt;env_name\u0026gt; \u0026lt;account_number\u0026gt;    file_url: 脚本地址 repo_url: 仓库地址 whitelist: 拉取仓库时的白名单，即就是需要拉取的脚本的路径包含的字符串 blacklist: 拉取仓库时的黑名单，即就是需要拉取的脚本的路径不包含的字符串 dependence: 拉取仓库需要的依赖文件，会直接从仓库拷贝到scripts下的仓库目录，不受黑名单影响 branch: 拉取仓库的分支 days: 需要保留的日志的天数 file_path: 任务执行时的文件路径 env_name: 任务执行时需要并发或者指定时的环境变量名称 account_number: 任务执行时指定某个环境变量需要执行的账号序号  依赖 一键安装依赖：\n1  docker exec -it qinglong bash -c \u0026#34;$(curl -fsSL https://ghproxy.com/https://raw.githubusercontent.com/Yun-City/City/main/Shell/QLOneKeyDependency.sh | sh)\u0026#34;   手动安装：\n npm install -g png-js npm install -g date-fns npm install -g axios npm install -g crypto-js npm install -g ts-md5 npm install -g tslib npm install -g @types/node npm install -g requests  当然你也可以在面板的依赖管理处添加\nHTTP2问题 你可能会遇到这样的报错：\nHTTP/2 stream 0 was not closed cleanly: PROTOCOL_ERROR (err 1)\n只需要在容器中执行以下命令即可解决：\n1  git config --global http.version HTTP/1.1   ","permalink":"https://www.sukun.xyz/qinglong/","tags":["青龙面板"],"title":"青龙面板教程"},{"categories":["算法与数据结构"],"contents":"数据结构——用C语言描述(八) 技术 查找 查找的基本概念   列表：由同一类型的数据元素（或记录）构成的集合，可利用任意数据结构实现\n  关键字：数据元素的某个数据项的值可标识列表中的一个数据元素\n主关键字可唯一标识列表中的一个数据元素，否则为次关键字\n  查找：根据给定的关键字值，在特定的列表中确定一个其关键字与给定值相同的数据元素，并返回该数据元素在列表中的位置\n  查找对象 K（找什么）\n  查找范围 L（在哪找）\n  K 在 L 中的位置（查找的结果）\n    平均查找长度（ASL）：查找过程中对关键码的比较次数的平均值 $$ ASL=P_1C_1+P_2C_2+…+P_nC_n=\\sum_{i=1}^nP_iC_i\\\\ P_i为查找概率，C_i为查找次数 $$\n  查找基本方法：\n 线性表查找法 树表式查找法 计算式（哈希）查找法    基于线性表的查找法 顺序查找法 数据类型定义 1 2 3 4 5 6 7 8 9 10 11 12 13  #define KeyType int #define OtherType int #define LIST_SIZE 20 typedef struct { KeyType key; OtherType other_data; } RecordType; typedef struct { RecordType r[LIST_SIZE + 1]; // r[0]为工作单元  int length; } RecordList;   顺序结构算法 此处为从后往前的顺序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  //不设置监视哨，在顺序表中查找关键字等于k的元素 int SeqSearch_1(RecordList L, KeyType k) { int i; for (i = L.length; i \u0026gt;= 1 \u0026amp;\u0026amp; L.r[i].key != k; i--) ; if (i \u0026gt;= 1) return i; else return 0; } //设置监视哨，顺序表L由后往前查找关键字k，查到返回k在L中的位置，否则返0 int SeqSearch_2(RecordList L, KeyType k) { int i; L.r[0].key = k; for (i = L.length; L.r[i].key != k; i--) ; return i; }   性能分析 $$ n为表长，c_i为比较次数\\\\ c_1=n-1+1\\\\ c_2=n-2+1\\\\ …\\\\ c_n=n-n+1\\\\ 即c_i=n-i+1\\\\ 查找每个元素的概率相等，即P_i=\\frac{1}{n}\\\\ 查找成功时平均查找长度为\\\\ ASL_{succ}=\\sum_{i=1}^nP_iC_i=\\frac{1}{n}\\sum_{i=1}^nC_i=\\frac{1}{n}\\sum_{i=1}^n(n-i+1)=\\frac{n+1}{2} $$\n注意  ASL为$O(n)$   折半查找法 定义 折半查找（二分查找），要求：\n 采用顺序存储 关键字有序排列  基本过程 中间记录关键字与查找关键字比较：\n如果两者相等，则查找成功；\n否则如查找关键字小于中间位置关键字，则查前部子表，否则查找后部子表。\n算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  int BinSrchZ(SqList L, KeyType k) { int low, high, mid; low = 1; high = L.length; //置区间初值  while (low \u0026lt;= high) { mid = (low + high) / 2; if (k == L.r[mid].key) return mid; //查找成功  else if (k \u0026lt; L.r[mid].key) high = mid - 1; //继续在前半区间查找  else low = mid + 1; //继续在后半区间查找  } return 0; }   性能分析 折半查找过程可用判定树描述判定树结构：\n 树中每一结点表示表中一记录结点值记录在表中的位置 从根到被查结点路径关键字比较次数为被查结点层数 成功进行最多比较次数不超过树深度$[\\log_2n] +1$  假定表的长度$n=2h-1$，则相应判定树必为深度是 h 的满二叉树，$h=\\log_2(n+1)$\n折半查找成功的平均查找长度： $$ ASL_{bs}=\\sum_{i=1}^nP_iC_i=\\frac{1}{n}\\sum_{j=1}^hj×2^{j-1}=\\frac{n+1}{n}\\log_2(n+1)-1 $$ 每个记录的查找概率相等，j 为每层的比较次数，$2^{j-1}$为每层的元素个数\n注意  ASL为$O(\\log_2n)$    优点：  比较次数少 查找速度快 平均性能好 适用于固定长度频繁查找的有序表   缺点：  要求待查表为有序表 插入删除时需再排序    分块查找法 对所查表要求  等长分块，最后一块可不满 块内无序 块间有序  基本思想  分块构造索引表 定块可用顺序或折半查找关键字 k 与索引表关键字比较，确定该查记录所在块 块内顺序查找  平均查找长度 查找索引表的平均查找长度$L_B$，相应块内顺序查找的平均查找长度$L_W$\n平均查找长度：$ASL_{bs}=L_B+L_W$\n假定将长度为 n 的表分成 b 块，每块含 s 个元素，则$b=\\frac{n}{s}$，\n又假定表中每个元素的查找概率相等，则每个索引项的查找概率为$\\frac{1}{b}$，块中每个元素的查找概率为$\\frac{1}{s}$。则有\n  顺序法平均查找长度： $$ L_B=\\frac{1}{b}\\sum_{j=1}^bj=\\frac{b+1}{2}\\\\ L_W=\\frac{1}{s}\\sum_{i=1}^si=\\frac{s+1}{2}\\\\ $$ 将$b=\\frac{n}{s}$代入得 $$ ASL_{bs}=\\frac{\\frac{n}{s}+1}{2}+1\\\\ =\\frac{b+1+s+1}{2}\\\\ =\\frac{b+s}{2}+1 $$\n  折半法平均查找长度： $$ L_B=\\log_2(b+1)-1\\\\ ASL_{bs}=\\log_2(b+1)-1+\\frac{s+1}{2}\\\\ =\\log_2(\\frac{s}{n}+1)+\\frac{s-1}{2} $$\n  基于树的查找法 步骤：\n 将待查表组织成特定树 在树结构上实现查找  有三种树：\n 二叉排序树 平衡二叉树 B 树  此处重点讲述二叉排序树\n二叉排序树 定义 二叉树排序树或者是一棵空树，或者是具有如下性质的二叉树：\n 若它的左子树非空，则左子树上所有结点的值均小于根结点的值 若它的右子树非空，则右子树上所有结点的值均大于根结点的值 它的左右子树也分别为二叉排序树  插入和生成  若二叉排序树是空树，则key成为二叉排序树的根 若二叉排序树非空，key与二叉排序树的根比较：  key的值小于根结点的值，则将key插入左子树 key的值大于等于根结点的值，则将key插入右子树    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  void CreateBST(BSTree *bst) //从键盘输入元素的值，创建相应的二叉排序树 { KeyType key; *bst = NULL; scanf(\u0026#34;%d\u0026#34;, \u0026amp;key); while (key != ENDKEY) { InsertBST(bst, key); scanf(\u0026#34;%d\u0026#34;, \u0026amp;key); } } void InsertBST(BSTree *bst, KeyType key) // key插入到bst为根的二叉排序树，从根比 { BiTree s; if (!*bst) { s = (BSTree)malloc(sizeof(BSTNode)); s-\u0026gt;key = key; s-\u0026gt;LChild = s-\u0026gt;RChild = NULL; *bst = s; } else if (key \u0026lt; (*bst)-\u0026gt;key) InsertBST(\u0026amp;((*bst)-\u0026gt;LChild), key); else InsertBST(\u0026amp;((*bst)-\u0026gt;RChild), key); }   注意  插入一个结点InsertBST(bst, key)时间复杂度为$O(\\log_2n)$，创建二叉排序树 n 个结点的时间复杂度为$O(n\\log_2n)$。   技巧  对二叉排序树进行中序遍历，一定会得到一个递增有序序列。   查找 方法：\n根据二叉排序树的特点，关键字 k 与根 t 比较：\n key = t：返回根结点地址 key \u0026lt; t：进一步查左子树 key \u0026gt; t：进一步查右子树  算法：\n  递归\n1 2 3 4 5 6 7 8 9 10 11  BSTree SearchBST(BSTree bst, KeyType key) { if (!bst) return NULL; else if (bst-\u0026gt;key == key) return bst; else if (bst-\u0026gt;key \u0026gt; key) return SearchBST(bst-\u0026gt;LChild, key); else return SearchBST(bst-\u0026gt;RChild, key); }     非递归\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  BSTree SearchBST_2(BSTree bst, KeyType key) //非递归查找 { BSTree q; q = bst; while (q) { if (q-\u0026gt;key == key) return q; //查找成功  else if (q-\u0026gt;key \u0026gt; key) q = q-\u0026gt;LChild; else q = q-\u0026gt;RChild; } return NULL; //查找失败 }     查找性能 平均查找长度和二叉排序树的形态有关：\n就平均性能而言，二叉排序树上的查找和二分查找相差不大，并且二叉排序树上的插入和删除结点十分方便，无需移动大量结点\n  最好情况：\n二叉排序树接近二分平衡树，平均查找长度大约是$\\log_2n$\n  最坏情况：\n得到一棵深度为 n 的单支树，平均查找长度和单链表上的顺序查找相同，是$\\frac{n+1}{2} $。\n  平衡二叉树 定义 平衡二叉排序树又称为 AVL 树。\n一棵平衡二叉排序树或者是空树，或者是具有下列性质的二叉排序树：\n 左子树与右子树的高度之差的绝对值小于等于 1 左子树和右子树也是平衡二叉排序树  平衡因子 平衡因子（balance factor）即结点的左子树深度与右子树深度之差。\n对一棵平衡二叉排序树而言，其所有结点的平衡因子只能是-1、0或1。\n计算式查找法——哈希法 哈希的基本思想 比较式查找通过对关键字的一系列查找比较实现，效率与查找表长有关，当关键字可能取值的集合远远大于实际表长时，比较式查找效率低。\n而计算式查找对关键字计算得到对应元素的地址$H(key)=Addr$\n哈希法（散列法、杂凑法）基本思想：\n  哈希函数：\n建立哈希函数$p=H(key)$，计算关键字 key 在哈希表中的存储位置 p。\n  冲突：\n冲突问题:若关键字$key_1 key_2$，哈希函数值$H(key_1)= H(key_2)$，则发生冲突。\n  冲突原因：\n 必然性：由于关键字可能的取值空间远远大于哈希表的地址空间，冲突不可避免 可能性：哈希函数$H(key)$的散列性能不好，可能加剧冲突发生  哈希函数的构造方法 原则：\n 函数本身便于计算 计算出来的地址分布均匀  方法：\n  数字分析法：\n从关键字中选出分布较均匀的若干位，构成哈希地址\n  平方取中法：\n先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址\n  分段叠加法：\n按哈希表地址位数将关键字分成位数相等的几部分(最后一部分可以较短），然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。\n  除留余数法：\n哈希函数为$H(K)=K\\%P$，其中%为模 P 取余运算，表长为 m，P 应为小于等于 m 的最大素数\n  伪随机数法：\n采用一个伪随机函数做哈希函数，即$h(key)=random(key)$。\n  处理冲突的方法   开放定址法\n当关键字 key 的哈希地址$p=H (key)$出现冲突时，以 p 为基础，产生另一个哈希地址$p_1$，如果$p_1$仍然冲突，再以 p 为基础，产生另一个哈希地址$p_2$，…，直到找出一个不冲突的哈希地址$p_i$ ，将相应元素存入其中。通用的再散列函数形式：$H_i=(H(key)+d_i)\\%m$\n形成$d_i$的方法：\n  线性探测再散列\n$d_i=1,2,3,…,m-1$\n冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表\n  二次探测再散列\n$d_i=1^2,-1^2,2^2,-2^2,…,k^2,-k^2$\n特点:冲突发生时，在表的左右进行跳跃式探测，比较灵活\n  伪随机探测再散列\n$d_i=伪随机数序列$\n    再哈希法\n同时构造多个不同的哈希函数：$H_i=RH_1(key)\\ i=1,2,…,k$\n当哈希地址$H_i=RH_1(key)$发生冲突时，再计算$H_i=RH_2(key)$……直到冲突不再产生。\n这种方法不易产生聚集，但增加了计算时间。\n  链地址法\n  建立公共溢出区\n将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表\n  哈希表的查找过程 哈希表的查找过程与哈希表的创建过程规则一致\n注意：查到空单元时表示找不到\n查找过程：\n  计算$p_0=hash(K)$\n  如果单元$p_0$为空，则所查元素不存在\n  如果单元$p_0$中元素的关键字为K，则找到所查元素\n  否则重复下述解决冲突的过程：\n按解决冲突的方法，找出下一个哈希地址$p_i$\n 如果单元$p_i$为空，则所查元素不存在 如果单元$p_i$中元素的关键字为K，则找到所查元素    查找算法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  int HashSearch(HashTable ht, KeyType K) { int i, p0, pi; p0 = hash(K); if (ht[p0].key == NULLKEY) return -1; else if (ht[p0].key == K) return 0; else //线性探测再散列  { for (i = 1; i \u0026lt;= m - 1; i++) { pi = (p0 + i) % m; if (ht[pi].key == NULLKEY) return -1; else if (ht[pi].key == K) return pi; } return -1; } }   哈希法性能分析 影响比较次数的因素：\n  哈希函数\n  处理冲突的方法\n  装填因子\n  哈希表的装填因子 α 的定义： $$ α=\\frac{哈希表中元素个数}{哈希表的长度} $$ α 可描述哈希表的装满程度。显然，α 越小，发生冲突的可能性越小；而 α 越大，发生冲突的可能性也越大。\n等概率情况下查找成功的平均查找长度： $$ ASL_{succ}=\\frac{1}{表中置入元素个数n}\\sum_{i=1}^nC_i $$ 等概率情况下查找不成功的平均查找长度公式 $$ ASL_{unsucc}=\\frac{1}{哈希函数取值个数r}\\sum_{i=0}^{r-1}C_i $$\n  线性探测再散列： $$ ASL_{succ}≈\\frac{1+\\frac{1}{1-α}}{2}\\\\ ASL_{unsucc}=\\frac{1+\\frac{1}{(1-α)^2}}{2} $$\n  伪随机探测再散列、二次探测再散列、再哈希： $$ ASL_{succ}≈-\\frac{\\ln(1-α)}{α}\\\\ ASL_{unsucc}=\\frac{1}{1-α} $$\n  链址法： $$ ASL_{succ}≈1+\\frac{α}{2}\\\\ ASL_{unsucc}=α+e^{-α} $$\n ","permalink":"https://www.sukun.xyz/data_structure-8/","tags":["数据结构","学习"],"title":"数据结构学习(八)"},{"categories":["算法与数据结构"],"contents":"数据结构——用C语言描述(七) 非线性结构 图 图的定义与基本术语 图的定义 图（Graph）是一种网状数据结构，其形式化定义如下：\nGraph=(V,R)\nV={x|x∈DataObject}\nR={VR}\nVR={\u0026lt;x,y\u0026gt;|P(x,y)∧(x,y∈V)}\n其中，\n DataObject：具有相同特性的元素的集合 V：顶点（vertex）集合 VR：顶点间关系的集合 P(x,y)：表示 x 和 y 之间有特定的关联属性 P  图的抽象类型定义 数据对象 V：具有相同特性的元素的集合\n结构关系：多对多\nR={VR}\nVR={\u0026lt;x,y\u0026gt;|P(x,y) (xy∈V)}\n操作集合：\n 创建GreateGraph(G) 销毁DestoryGraph(G) 确定顶点位置LocateVertex (G, v) 取第 i 个顶点GetVertex(G, i) 找顶点 v 的第一个邻接点FirstAdjVertex(G, v) 找顶点 v 的下一个邻接点NextAdjVertex(G, v, w) 插入顶点InsertVertex(G, u) 删除顶点及弧DeleteVertex(G, v) 插入弧lnsertArc (G, v, w) 删除弧DeleteArc (G, v, w) 遍历TraverseGraph(G)  基本术语   图\n 无向图：图中边无方向 有向图：图中边有方向 有向完全图：图中每个顶点和其余 n-1 个顶点都有弧相连（总共$n×(n-1)$条边） 无向完全图：图中每个顶点和其余 n-1 个顶点都有边相连（总共$\\frac{n×(n-1)}{2}$条边） 子图：若 G' 的顶点包含于 G 的顶点，则称图 G' 为 G 的子图 连通图：对于图中任意两个顶点都是连通的 连通分量：无向图中的极大连通子图 强连通图：任意两个顶点之间互相可达 强连通分量：有向图的极大强连通子图    邻接点：两顶点之间存在边，则称其互为邻接点\n  路径和回路\n 路径：顶点序列 路径长度：顶点序列上经过的边的个数 回路或环：起点和终点相同 简单路径：顶点序列中的顶点各不相同的路径 简单回路：除了第一个和最后一个顶点外，其余各顶点均不重复出现的回路    度\n  无向图的度：顶点 V 的度 TD(V)——和 V 相连的边的个数\n  有向图的度：入度+出度\n入度 ID(V)：进来的弧\n出度 OD(V)：出去的弧\n  度的计算公式：n 个顶点，e 条边或弧，则有 $$ 2e=\\sum_{i=1}TD(V_i) $$\n    权和网\n 权：图的边或弧上与它相关的数（可以表示从一个顶点到另一个顶点的距离或耗费等信息） 赋权图（网）：带权的图    生成树：极小连通子图，含有连通图全部顶点 n 并有 n-1 条边\n  顶点在图中的位置：人为排列中的位置序号，可将任一顶点看作图的第一个顶点，对任一顶点其邻接点间不存在顺序关系\n  图的存储结构 显然，我们需要存储顶点和顶点间关系两部分信息，对此我们有如下四种办法\n邻接矩阵表示法（数组表示法） 定义 用两个数组来表示图：存储顶点信息的一维数组、存储顶点关联关系的二维数组（邻接矩阵）\n表示 G 是一具有 n 个顶点的无权图，G 的邻接矩阵是如下性质的 n×n 矩阵 A： $$ A[i,j]= \\begin{cases} 1 \u0026amp;若\u0026lt;v_i,v_j\u0026gt;或(v_i,v_j)∈VR\\\\ 0 \u0026amp;反之 \\end{cases} $$ 若图 G 是一个有 n 个顶点的网，则它的邻接矩阵是具有如下性质的 n×n 矩阵 A： $$ A[i,j]= \\begin{cases} W_{ij} \u0026amp;若\u0026lt;v_i,v_j\u0026gt;或(v_i,v_j)∈VR\\\\ 0或∞ \u0026amp;反之 \\end{cases} $$ 例如：\n$$ A=\\left( \\begin{array}{cccc} 0 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1\\\\ 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\\\ 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1\\\\ 1 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0\\\\ \\end{array} \\right) $$\nC语言类型描述 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #define VRType int #define InfoType char #define VertexType int #define MAX_VERTEX_NUM 20 #define INFINITY 32678 typedef enum { DG, //有向  DN, //有向网  UDG, //无向  UDN //无向网 } GraphKind; typedef struct { VRType adj; //对于无权图，用 1 或 0 表示是否相邻；对于带权图，直接为权值  InfoType *info; //弧或边额外含有的信息指针 } ArcNode; typedef struct { VertexType vexs[MAX_VERTEX_NUM]; //顶点  ArcNode arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM]; //顶点之间的关系  int vexnum, arcnum; //顶点数，弧数  GraphKind kind; //图的种类 } AdjMatrix;   特点  存储空间：    无向图\n邻接矩阵是对称矩阵，可采用下三角压缩存储只需$\\frac{n×(n-1)}{2}$空间\n  有向图\n邻接矩阵不一定是对称矩阵，所以需要$n^2$个存储空间。\n  便于运算：    根据$A[i,j]=0或1$来判定图中任意两个顶点之间是否有边相连\n  便于求各个顶点的度\n  无向图：其邻接矩阵第 i 行元素之和就是图中第i 个顶点的度 $$ TD(v_i)=\\sum_{j=1}^nA[i,j] $$\n  有向图：第 i 行元素之和就是图中第 i 个顶点的出度；第 i 列元素之和就是图中第 i 个顶点的入度。\n  $$ OD(v_i)=\\sum_{j=1}^nA[i,j]\\\\ ID(v_i)=\\sum_{j=1}^nA[j,i] $$\n  便于实现一些基本操作  创建有向网的算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  bool CreateDN(AdjMatrix *G) { int i, j, k, weight; VertexType v1, v2; scanf(\u0026#34;%d,%d\u0026#34;, \u0026amp;G-\u0026gt;arcnum, \u0026amp;G-\u0026gt;vexnum); for (i = 0; i \u0026lt; G-\u0026gt;vexnum; i++) for (j = 0; j \u0026lt; G-\u0026gt;vexnum; j++) G-\u0026gt;arcs[i][j].adj = INFINITY; //初始化  for (i = 0; i \u0026lt; G-\u0026gt;vexnum; i++) scanf(\u0026#34;%c\u0026#34;, \u0026amp;G-\u0026gt;vexs[i]); //读取顶点的一维数组  for (k = 0; k \u0026lt; G-\u0026gt;arcnum; k++) { scanf(\u0026#34;%c,%c,%d\u0026#34;, \u0026amp;v1, \u0026amp;v2, \u0026amp;weight); i = LocateVex_M(G, v1); j = LocateVex_M(G, v2); G-\u0026gt;arcs[i][j].adj = weight; //生成顶点  } return true; }   邻接表表示法 基本思想 采用链式结构存储图，只存储图中有关联的边的信息：\n 对图中 n 个顶点均建有关联的边链表 每个顶点信息与其边链表的头指针构成表头结点表  结构构成   表头结点表：\n由所有表头结点以顺序结构的形式存储，以便可以随机访问任一顶点的邻接点单链表。 $$ \\begin{array}{|c|c|} \\hline vexdata(数据域) \u0026amp; firstarc(链域)\\\\\\hline \\end{array} $$\n  边表：\n由表示图中顶点间邻接关系的 n 个边链表组成。 $$ \\begin{array}{|c|c|c|} \\hline adjvex(邻接点域) \u0026amp; info(数据域) \u0026amp; nextarc(链域)\\\\\\hline \\end{array} $$\n  图例 结构类型定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  #define VertexType int #define InfoType int #define MAX_VERTEX_NUM 20 typedef enum { DG, DN, UDG, UDN } GraphKind; typedef struct ArcNode { int adjvex; //邻接点在数组中的位置下标  struct ArcNode *nextarc; //指向下一个邻接点的指针  InfoType *info; //信息域 } ArcNode; typedef struct VNode { VertexType data; //顶点的数据域  ArcNode *firstarc; //指向邻接点的指针 } VNode; typedef struct { VNode vertex[MAX_VERTEX_NUM]; //存储各链表头结点的数组  int vexnum, arcnum; //顶点数和边或弧数  GraphKind kind; //图的种类 } AdjList;   存储空间 n 个顶点，e 条边的无向图：\n采取邻接表作为存储结构，需要 n 个表头结点和 2e 个表结点。\n无向图的度 在无向图的邻接表中，顶点$V_i$的度恰好就是第 i 个边链表上结点的个数\n有向图的度 有向图中，第 i 个边链表上顶点的个数是顶点$V_i$的出度。\n求该顶点的入度，须遍历整个邻接表。在所有单链表中，查找邻接点域的值为 i 的结点并计数求和。\n解决方案  逆邻接表法：\n对每一顶点$V_i$再建立一个所有以顶点$V_i$为弧头的弧的表（逆邻接表)。求顶点$V_i$的入度即是计算逆邻接表中第 i 个顶点的边链表中节点个数\n正向邻接表求出度，逆向邻接表求入度。\n   十字链表 定义 十字链表是有向图的另一种链式存储结构。它是有向图的邻接表和逆邻接表结合的一种链表。\n有向图中的每一条弧对应十字链表中的一个弧结点，有向图中的每个顶点对应有一个结点，叫做顶点结点。\n结构 用于存储顶点的首元结点结构： $$ \\begin{array}{|c|c|c|} \\hline data \u0026amp; firstin \u0026amp; firstout\\\\\\hline \\end{array} $$\n data数据域 firstin以当前顶点为弧头的其他顶点构成的链表 fitstout以当前顶点为弧尾的其他顶点构成的链表  普通结点的结构： $$ \\begin{array}{|c|c|c|c|c|} \\hline tailvex \u0026amp; headvex \u0026amp; hlink \u0026amp; tlink \u0026amp; info\\\\\\hline \\end{array} $$\n tailvex弧尾顶点的位置下标 headvex弧头顶点的位置下标 hlink下一个以首元节点为弧头的顶点 tlink下一个以首元节点为弧尾的顶点 info数据域  结构类型定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  #define InfoType int #define VertexType int #define MAX_VERTEX_NUM 20 typedef struct ArcBox { int tailvex, headvex; //弧尾、弧头对应顶点在数组中的位置下标  struct ArcBox *hlink, *tlink; //分别指向弧头相同和弧尾相同的下一个弧  InfoType *info; } ArcBox; typedef struct VertexNode { VertexType data; ArcBox *firstin, *firstout; //指向以该顶点为弧头和弧尾的链表首个结点 } VertexNode; typedef struct { VertexNode xlist[MAX_VERTEX_NUM]; int vexnum, arcnum; } OLGraph;   图例 建立算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  void CreateDG(OLGraph *G) { int v1, v2; scanf(\u0026#34;%d,%d\u0026#34;, \u0026amp;G-\u0026gt;vexnum, \u0026amp;G-\u0026gt;arcnum); for (int i = 0; i \u0026lt; G-\u0026gt;vexnum; i++) //初始化  { scanf(\u0026#34;%d\u0026#34;, \u0026amp;G-\u0026gt;xlist[i].data); G-\u0026gt;xlist[i].firstin = NULL; G-\u0026gt;xlist[i].firstout = NULL; } for (int k = 0; k \u0026lt; G-\u0026gt;arcnum; k++) { scanf(\u0026#34;%d,%d\u0026#34;, \u0026amp;v1, \u0026amp;v2); int i = LocateVex(G, v1); int j = LocateVex(G, v2); ArcBox *p = (ArcBox *)malloc(sizeof(ArcBox)); //建立弧的结点  p-\u0026gt;tailvex = i; p-\u0026gt;headvex = j; //采用头插法插入新的p结点  p-\u0026gt;hlink = G-\u0026gt;xlist[j].firstin; p-\u0026gt;tlink = G-\u0026gt;xlist[i].firstout; G-\u0026gt;xlist[j].firstin = G-\u0026gt;xlist[i].firstout = p; } }   优点 在十字链表中能容易地找到以$V_i$为尾的弧，也能容易地找到以$V_i$为头的弧，有向图若采用十字链表作为存储结构，容易求出顶点$V_i$的度。\n邻接多重表 定义 邻接多重表是无向图的另外一种存储结构，它将图中关于一条边的信息用一个结点来表示，能够提供更为方便的边处理信息。\n结构 顶点结构： $$ \\begin{array}{|c|c|} \\hline data \u0026amp; firstedge\\\\\\hline \\end{array} $$ 边结点结构： $$ \\begin{array}{|c|c|c|c|c|c|} \\hline mark \u0026amp; ivex \u0026amp; ilink \u0026amp; jvex \u0026amp; jlink \u0026amp; info\\\\\\hline \\end{array} $$\n结构类型定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #define InfoType int #define VertexType int #define MAX_VERTEX_NUM 20 typedef enum { unvisited, visited } VisitIf; typedef struct EBox { VisitIf mark; //标志域  int ivex, jvex; //边的两顶点在数组中的位置下标  struct EBox *ilink, *jlink; //分别指向与ivex、jvex相关的下一个边  InfoType *info; //边包含的其它的信息 } EBox; typedef struct VexBox { VertexType data; EBox *firstedge; //顶点相关的第一条边 } VexBox; typedef struct { VexBox adjmulist[MAX_VERTEX_NUM]; //顶点数组  int vexnum, edgenum; //顶点数和边数 } AMLGraph;   图例 图的遍历 定义 从图中的某个顶点出发，按某种方法对图中的所有顶点访问且仅访问一次。\n显然我们需要设置访问标志数组visited[]：\n 保证图中的各顶点均被访问 避免重复访问  方法 1 2 3 4 5 6 7 8 9 10  int visited[]; void TraverseGraph(Graph g) //Graph表示图的一种存储结构，如邻接表 { int vi; for (vi = 0; vi \u0026lt; g.vexnum; vi++) visited[vi] = 0; for (vi = 0; vi \u0026lt; g.vexnum; vi++) if (!visited[vi]) search(g, vi); }   此处的search(g, vi)函数分为深度优先搜索（DFS）和广度优先搜索（BFS）两种。\nDFS 深度优先搜索 DFS（Depth_First Search）是指按照深度方向搜索，类似于树的先根遍历：\n 从图中某个顶点$v_0$出发，首先访问$v_0$ 找出刚访问过的顶点$v_i$的第一个未被访问的邻接点，然后访问该顶点。重复此步骤，直到当前的顶点没有未被访问的邻接点为止 返回前一个访问过的顶点，找出该顶点的下一个未被访问的邻接点，访问该顶点。转2  与树的先根遍历一样，DFS 算法是递归技术实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13  void DepthFirstSearch(Graph g, int v0) { int w; visit(v0); visited[v0] = 1; w = FirstAdjVertex(g, v0); //找v0的一个邻接点  while (w != -1) //邻接点存在  { if (!visited[w]) DepthFirstSearch(g, w); w = NextAdjVertex(g, v0, w); //找v0的下一个邻接点  } }   邻接矩阵实现DFS 1 2 3 4 5 6 7 8 9  void DepthFirstSearch(AdjMatrix g, int v0) { int vj; visit(v0); visited[v0] = 1; for (vj = 0; vj \u0026lt; g.vexnum; vj++) if (!visited[vj] \u0026amp;\u0026amp; g.arcs[v0][vj].adj == 1) DepthFirstSearch(g, vj); }   邻接表实现DFS 1 2 3 4 5 6 7 8 9 10 11 12  void DepthFirstSearch(AdjList g, int v0) { visit(v0); visited[v0] = 1; ArcNode *p = g.vertex[v0].firstarc; while (p) { if (!visited[p-\u0026gt;adjvex]) DepthFirstSearch(g, p-\u0026gt;adjvex); p = p-\u0026gt;nextarc; } }   深度优先生成树 显然，DFS 算法将生成一个覆盖 n 个点，有 n-1 条边的访问序列，也就是树，我们可以进一步修改 DFS 算法使其输出深度优先生成树：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  void DepthFirstSearch(Graph g, int v0) { int w; visit(v0); visited[v0] = 1; w = FirstAdjVertex(g, v0); while (w != -1) { if (!visited[w]) { Printf(v0, w); //修改内容  DepthFirstSearch(g, w); } w = NextAdjVertex(g, v0, w); } }   BFS 广度优先搜索 BFS（Breadth_First Search）是指按照广度方向搜索，类似于树的层次遍历：\n 从图中某个顶点$v_0$出发，首先访问$v_0$ 依次访问$v_0$的各个未被访问的邻接点 分别从这些邻接点（端结点）出发，依次访问它们的各个未被访问的邻接点（新的端结点）  与树的层次遍历一样，BFS 算法是队列技术实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  void BreadthFirstSearch(Graph g, int v0) { int v, w; visit(v0); visited[v0] = 1; InitQueue(\u0026amp;Q); EnterQueue(\u0026amp;Q, v0); while (!IsEmpty(Q)) { DeleteQueue(\u0026amp;Q, \u0026amp;v); w = FirstAdjVertex(g, v); while (w != -1) { if (!visited[w]) { visit(w); visited[w] = 1; EnterQueue(\u0026amp;Q, w); } w = NextAdjVertex(g, v, w); } } }   广度优先生成树 类似于深度优先生成树，我们也可以进一步修改 BFS 算法使其输出广度优先生成树：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  void BreadthFirstSearch(Graph g, int v0) { int v, w; visit(v0); visited[v0] = 1; InitQueue(\u0026amp;Q); EnterQueue(\u0026amp;Q, v0); while (!IsEmpty(Q)) { DeleteQueue(\u0026amp;Q, \u0026amp;v); w = FirstAdjVertex(g, v); while (w != -1) { if (!visited[w]) { visit(w); visited[w] = 1; Printf(v, w); //修改内容  EnterQueue(\u0026amp;Q, w); } w = NextAdjVertex(g, v, w); } } }   图的应用 图的连通性问题 无向图的连通分量 调用搜索过程的次数就是该图连通分量的个数。\n 连通图仅调用一次搜索过程——连通分量为 1 非连通图需多次调用搜索过程——连通分量为此处次数  修改图的遍历算法即可实现统计无向图的连通分量：\n1 2 3 4 5 6 7 8 9 10 11 12 13  void TraverseGraph(Graph g) { int vi, count; count = 0; for (vi = 0; vi \u0026lt; g.vexnum; vi++) visited[vi] = 0; for (vi = 0; vi \u0026lt; g.vexnum; vi++) if (!visited[vi]) { search(g, vi); count++; } }   两顶点之间的简单路径 生成树 最小生成树 各边的代价之和最小的生成树称为最小（代价）生成树。\n性质：设$N=(V,{E})$是一连通网，U 是顶点集 V 的一个非空子集。若$(u,v)$是一条具有最小权值的边，存在一棵包含边$(u,v)$的最小生成树。\n由此性质，我们有两种算法实现：\n  普里姆算法（加点法）\n思想：加点不构成回路\n  假设 N=(V,{E}) 是连通网，TE 为最小生成树中边的集合\n  初始 U={$u_0$}($u_0$∈V),TE=∅\n  在所有$u∈U, v∈V-U$的边中选一条代价最小的边$(u_0, v_0)$并入集合 TE，同时将$v_0$并入 U\n  重复第 2 步，n-1 直到 U=V 为止。\n  此时，TE 中必含有 n-1 条边，则 T=(V,{TE}) 为N的最小生成树\n注意  普里姆算法时间复杂度为$O(n^2)$     克鲁斯卡尔算法（加边法）\n思想：加边不构成回路\n  假设 N=(V,{E}) 是连通网，将 N 中的边按权值从小到大的顺序排列\n  将 n 个顶点看成 n 个集合\n  按权值由小到大的顺序选择边，选边应满足两个顶点不在同一个集合内，将该边放到生成树边的集合中。同时将该边的两个顶点所在的顶点集合合并\n  重复第 3 步，直到所有的顶点都在同一个顶点集合内\n    有向无环图的应用1—拓扑排序 AOV-网 顶点表示活动的网：\n 顶点表示活动 弧表示活动间的优先关系  拓扑序列 有向图 G=(v,{E}) 中顶点的线性序列\n图中任意两个顶点$v_i$、$v_j$，有一条从$v_i$到$v_j$的路径，则在拓扑序列中$v_i$必排在$v_j$之前。\n拓扑网的特性  先行关系具有可传递性 拓扑序列不唯一  拓扑排序的基本思想  选一个无前驱顶点输出 删除此点及以它为起点的弧 重复1、2，直到不存在无前驱顶点 输出顶点数小于图中顶点数，则有向图中存在回路，否则输出顶点顺序即为拓扑序列  拓扑排序算法   基于邻接矩阵：\nA 为有向图 G 的邻接矩阵，则有\n 找 G 中无前驱的顶点——在 A 中找到值全为 0 的列 删除以 i 为起点的所有弧——将矩阵中i对应的行置为全 0  即选全 0 列，置全 0 行。\n  基于邻接表：\n附设一个存放各顶点入度的数组indegree[]\n 找 G 中无前驱的顶点——查找indegree[i]为零的顶点$v_i$ 删除以 i 为起点的所有弧——对链在顶点 i 后面的所有邻接顶点 k，将对应的indegree[k]减 1  为避免重复检测入度为零的顶点，设置一个入度为 0 点的栈，若某一顶点的入度减为0，则将它入栈。每当输出某一顶点，便将它从栈中删除。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  bool TopoSort(AdjList G) { int i, k, count, indegree[MAX_VERTEX_NUM]; Stack S; ArcNode *p; FindID(G, indegree); //求各顶点入度  InitStack(\u0026amp;S); for (i = 0; i \u0026lt; G.vexnum; i++) if (!indegree[i]) push(\u0026amp;S, i); //将入度0的顶点入栈  count = 0; while (!IsEmpty(S)) { pop(\u0026amp;S, \u0026amp;i); printf(\u0026#34;%c\u0026#34;, G.vertex[i].data); count++; p = G.vertex[i].firstarc; while (p) { k = p-\u0026gt;adjvex; indegree[k]--; if (!indegree[k]) push(\u0026amp;S, k); p = p-\u0026gt;nextarc; } } if (count \u0026lt; G.vexnum) //有回路  return false; else return true; }     有向无环图的应用2—关键路径 AOE-网 边表示活动的网：\n 顶点表示事件 弧表示活动 弧的权值表示活动所需时间  在AOE-网中的基本概念  源点：唯一入度为零的顶点 汇点：唯一出度为零的顶点 关键路径：从源点到汇点的最长路径 关键活动：关键路径上的活动  几个重要的定义   $ve(i)$：事件$v_i$的最早发生时间——从源点到顶点$v_i$的最长路径长度\n  $vl(i)$：事件$v_i$的最晚发生时间（在保证汇点按其最早发生时间发生的前提下）\n在求出$ve(i)$的基础上，可从汇点开始，按逆拓扑顺序向源点递推：\n$vl(n-1)=ve(n-1)$;\n$vl(i)=min${$vl(k)-dut(\u0026lt;i,k\u0026gt;)$}\n  $e(i)$：活动$a_i$的最早开始时间\n活动$a_i$对应的弧为$\u0026lt;j,k\u0026gt;$，$e(i)$等于从源点到顶点 j 的最长路径的长度，即$e(i)=ve(j)$\n  $l(i)$：活动$a_i$的最晚开始时间\n  活动$a_i$对应的弧为$\u0026lt;j, k\u0026gt;$，其持续时间为$dut(\u0026lt;j, k\u0026gt;)$则$l(i)=vl(k)-dut(\u0026lt;j, k\u0026gt;)$\n  $a_i$的松弛时间（时间余量）：$a_i$的最晚开始时间与$a_i$的最早开始时间之差——$l(i)-e(i)$\n松弛时间（时间余量）为 0 的活动为关键活动\n  求关键路径的基本步骤  在对图中顶点进行拓扑排序过程中按拓扑序列求出每个事件的最早发生时间$ve(i)$ 按逆拓扑序列求每个事件的最晚发生时间$vl(i)$ 求出每个活动$a_i$的最早开始时间$e(i)$和最晚发生时间$l(i)$ 找出$e(i)=l(i)$的活动$a_i$，即为关键活动  修改后的拓扑排序算法 通过拓扑顺序求出事件的最早发生时间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  int ve[MAX_VERTEX_NUM]; //每个顶点的最早发生时间 bool TopoOrder(AdjList G, Stack *T) // T为拓扑序列栈，S为0入度的顶点栈 { int count, i, j, k, indegree[MAX_VERTEX_NUM]; ArcNode *p; Stack S; InitStack(T); InitStack(\u0026amp;S); FindID(G, indegree); for (i = 0; i \u0026lt; G.vexnum; i++) if (!indegree[i]) push(\u0026amp;S, i); //将入度0的顶点入栈  count = 0; for (i = 0; i \u0026lt; G.vexnum; i++) ve[i] = 0; //初始化最早发生时间  while (!IsEmpty(S)) { pop(\u0026amp;S, \u0026amp;j); push(T, j); count++; p = G.vertex[i].firstarc; while (p) { k = p-\u0026gt;adjvex; indegree[k]--; if (!indegree[k]) push(\u0026amp;S, k); if (ve[j] + p-\u0026gt;info \u0026gt; ve[k]) //事件最早发生时间  ve[k] = ve[j] + p-\u0026gt;info; p = p-\u0026gt;nextarc; } } if (count \u0026lt; G.vexnum) return false; else return true; }   求关键路径的实现算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  bool CriticalPath(AdjList G) { ArcNode *p; int i, j, k, dut, ei, li, vl[MAX_VERTEX_NUM]; char tag; Stack T; if (!TopoOrder(G, \u0026amp;T)) //拓扑序列求ve  return false; for (i = 0; i \u0026lt; G.vexnum; i++) vl[i] = ve[i]; //初始化  while (IsEmpty(T)) { pop(\u0026amp;T, \u0026amp;j); //逆拓扑序列求vl  p = G.vertex[j].firstarc; while (p) { k = p-\u0026gt;adjvex; dut = p-\u0026gt;info; if (vl[k] - dut \u0026lt; vl[j]) vl[j] = vl[k] - dut; p = p-\u0026gt;nextarc; } } for (j = 0; j \u0026lt; G.vexnum; j++) //求ei，li和关键活动  { p = G.vertex[j].firstarc; while (p) { k = p-\u0026gt;adjvex; dut = p-\u0026gt;info; ei = ve[j]; li = vl[k] - dut; tag = (ei == li) ? \u0026#39;*\u0026#39; : \u0026#39; \u0026#39;; printf(\u0026#34;%c %c %d %d %d %c\\n\u0026#34;, G.vertex[j].data, G.vertex[k].data, dut, ei, li, tag); //输出关键活动  p = p-\u0026gt;nextarc; } } return true; }   最短路径 求某一顶点到其它各顶点的最短路径 迪杰斯特拉（Dijkstra）算法\n  基本思想：\n下一条最短路径是弧$(v_0,v_x)$或是中间经过 S 的某些顶点到达$v_x$的路径——按路径长度递增顺序产生最短路径\n  算法步骤：\n  g 为邻接矩阵表示的带权图，将$v_0$到其余顶点的路径长度初始化为权值\n  选择$v_k$，使得$v_k$为目前求得的下一条从$v_0$出发最短路径的终点\n  修改从$v_0$出发到集合 V-S 上任一顶点$v_i$的最短路径的长度\n如果$dist [k]+g.arcs[k][i]\u0026lt;dist[i]$则修改$dist[i]=dist[k]+g.arcs[k][i]$\n  重复2、3 n-1 次，即按最短路径长度的递增顺序，逐个求出$v_0$到图中其它每个顶点的最短路径\n    算法描述：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  ShortestPath_DJS(AdjMatrix g, int vo, VRType dist[MAX_VERTEX_NUM], VertexType path[MAX_VERTEX_NUM]) //存放i的当前最短路径长度，存放i的当前最短路径 { VertexType s; //已找到最短路径的终点集合  int i, k, t, min; for (i = 0; i \u0026lt; g.vexnum; i++) //初始化dist[i]、path[i]  { InitList(\u0026amp;path[i]); dist[i] = g.arcs[v0][i]; if (dist[i] \u0026lt; MAX) { AddTail(\u0026amp;path[i], g.vexs[v0]); AddTail(\u0026amp;path[i], g.vexs[i]); InitList(\u0026amp;s); AddTail(\u0026amp;s, g.vexs[v0]); } } for (t = 1; t \u0026lt; g.vexnum - 1; t++) { min = MAX; for (i = 0; i \u0026lt; g.vexnum; i++) if (!Member(g.vexs[i], s) \u0026amp;\u0026amp; dist[i] \u0026lt; min) { k = i; min = dist[i]; } if (min = INFINITY) return; AddTail(\u0026amp;s, g.vexs[k]); //选择最小距离vk  for (i = 0; i \u0026lt; g.vexnum; i++) if (!Member(g.vexs[i], s) \u0026amp;\u0026amp; (dist[k] + g.arcs[k][i] \u0026lt; dist[i])) //基于vk修正距离和路径  { dist[i] = dist[k] + g.arcs[k][i]; path[i] = path[k]; AddTail(\u0026amp;path[i], g.vexs[i]); // path[i]=path[k]∪{vi}  } } }   注意  此算法时间复杂度为$O(n^2)$     求任意一对顶点间的最短路径 佛罗依德算法（Floyd）\n  基本思想\n生成中间顶点序号不大于 0 … 不大于 n一1 的路径矩阵\n图 g 用邻接矩阵法表示，求图 g 中任意一对顶点$v_i$、$v_j$间的最短路径\n将$v_i$到$v_j$的最短的路径长度初始化为$g.arcs[i][j]$，然后进行如下 n 次比较和修正\n  在$v_i$、$v_j$间加入顶点$v_0$，比较$(v_i,v_0,v_j)$和$(v_i,v_j)$路径的长度，取其中较短路径作为$v_i$到$v_j$的且中间顶点号不大于 0 的最短路径\n  在$v_i$，$v_j$间加入顶点$v_1$，得$(v_i,…,v_1)$和$(v_1,…,v_j)$，其中$(v_i,…,v_1)$是$v_i$到$v_1$的且中间顶点号不大于 0 的最短路径，$(v_1,…,v_j)$是$v_1$到$v_j$且中间顶点号不大于 0 的最短路径，这两条路径在上一步中已求出。将$(v_i,…,v_1,v_j)$与$v_i$到$v_j$中间顶点号不大于 0 的最短路径比较，取较短的路径作为$v_i$到$v_j$的且中间顶点号不大于 1 的最短路径\n  依次类推，经过 n 次比较和修正,在第 n-1 步，将求得$v_i$到$v_j$且中间顶点号不大于 n-1 的最短路径，这必是从$v_i$到$v_j$的最短路径\n    算法描述\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  ShortestPath_Floyd(AdjMatrix g, VRType dist[MAX][MAX], VertexType path[MAX][MAX]) { int i, j, k; for (i = 0; i \u0026lt; g.vexnum; i++) for (j = 0; j \u0026lt; g.vexnum; j++) { InitList(\u0026amp;path[i][j]); dist[i][j] = g.arcs[i][j]; //初始化dist[i][j]和path[i][j]  if (dist[i][j] \u0026lt; MAX) { AddTail(\u0026amp;path[i][j], g.vexs[i]); AddTail(\u0026amp;path[i][j], g.vexs[j]); } } for (k = 0; k \u0026lt; g.vexnum; k++) for (i = 0; i \u0026lt; g.vexnum; i++) for (j = 0; j \u0026lt; g.vexnum; j++) if (dist[i][k] + dist[k][j] \u0026lt; dist[i][j]) { dist[i][j] = dist[i][k] + dist[k][j]; path[i][j] = JoinList(path[i][k], path[k][j]); } }     例题 求距离顶点$v_0$的最短路径长度为k的所有顶点 已知无向图 g，设计算法求距离顶点$v_0$的最短路径长度为 k 的所有顶点，要求尽可能节省时间。\n显然，本题应使用广度优先搜索算法（BFS），从顶点$v_0$开始，将一步可达的、两步可达的 … 直至 k 步可达的所有顶点记录下来，同时用一个队列记录每个结点的层号，输出第 k+1 层的所有结点即为所求。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  void BFS_layer(AdjList g, int v0, int k) { Queue Q; int v, w, layer; visit(v0); visited[v0] = 1; InitQueue(\u0026amp;Q); EnterQueue(\u0026amp;Q, v0, 1); while (Q.front != Q.rear) //队列非空  { DeleteQueue(\u0026amp;Q, \u0026amp;v, \u0026amp;layer); if (layer == k + 1) printf(\u0026#34;%d \u0026#34;, v); w = FirstAdjVertex(g, v); while (w != -1) { if (!visited[w]) { visit(w); visited[w] = 1; EnterQueue(\u0026amp;Q, w, layer + 1); } w = NextAdjVertex(g, v, w); } } }   ","permalink":"https://www.sukun.xyz/data_structure-7/","tags":["数据结构","学习"],"title":"数据结构学习(七)"},{"categories":["算法与数据结构"],"contents":"数据结构——用C语言描述(六) 非线性结构 树 树的定义与基本术语 树的基本概念 树（Tree）是n (n≥0）个结点的有限集合T。当n=0时，称为空树；当n\u0026gt;0时，该集合满足如下条件:\n 必有一个称为根（root）的特定结点，它没有直接前驱，但有零个或多个直接后继 其余 n-1 个结点可以划分成 m (m≥0）个互不相交的有限集 T1，T2，T3,\u0026hellip;，Tm，其中 Ti 又是一棵树，称为根 root 的子树。每棵子树的根结点有且仅有一个直接前驱，但有零个或多个直接后继。  树的图解表示  倒置树结构法（树形表示法） 文氏图表示法（嵌套集合形式） 广义表形式（嵌套括号表示法） 凹入表示法  树的相关术语  结点：包括一个数据元素及若干指向其它结点的分支信息。 结点的度：结点的子树个数 叶结点：度为 0 的结点，即无后继的结点，也称为终端结点 分支结点：度不为 0 的结点称为非终端结点 树的度：树中所有结点的度的最大值 结点的层次：从根结点开始定义根结点的层次为 1，根的直接后继的层次为 2，依此类推 树的高度：树中所有结点的层次的最大值 有序树：各子树之间有先后次序 森林：多颗互不相交的树的集合 孩子结点：直接后继结点 双亲结点：直接前驱结点 兄弟结点：同一双亲结点的孩子结点之间互称兄弟结点 祖先结点：从根到该结点路径上的所有结点 孙子结点：直接后继和间接后继  树的抽象数据类型 数据对象 D：该集合中的所有元素具有相同的特性\n结构关系 R：若 D 为空集，则为空树；若 D 中仅含有一个数据元素，则 R 为空集，否则 R={H}，H 是如下的二元关系:\n D中存在唯一的根元素 root，在关系 H 中无前驱 除 root 以外，D 中每个结点在关系 H 下都有且仅有一个前驱  操作集合：\n 初始化树lnitTree(Tree) 销毁树DestoryTree(Tree) 创建树CreateTree(Tree) 判空TreeEmpty(Tree) 求根Root(Tree) 求双亲Parent(Tree，x) 找 x 结点的第一个孩子FirstChild(Tree，x) 找 x 结点的下一个兄弟NextSibling(Tree，x) 插入孩子结点InsertChild(Tree，p, Child) 删除孩子结点DeleteChild(Tree，p, i) 遍历树TraverseTree(Tree，Visit())  二叉树 二叉树的定义与基本操作 二叉树（Binary Tree）：\n 每个结点的度都不大于 2 每个结点的孩子结点次序不能任意颠倒  10 种操作：\n 初始化lnitiate(bt) 创建Create(bt) 销毁Destory(bt） 判空Empty(bt) 求根Root(bt) 求双亲结点Parent(bt, x) 求左孩子LeftChild(bt，x) 求右孩子RightChild(bt，x) 遍历Traverse(bt) 清空Clear(bt)  二叉树性质   在二叉树的第 i 层的最大结点数为$2^{i-1}$\n  深度为 k 的二叉树的最大结点数： $$ \\sum_{i=1}^{k}2^{i-1}=2^{k-1} $$\n  对任意一棵二叉树，若终端结点数为$n_0$，而其度数为 2 的结点数为$n_2$，则$n_0=n_2+1$\n  满二叉树：有最大结点数，即每层结点都是满的\n  完全二叉树：深度为 k，结点数为 n 的二叉树，结点 1~n 的位置序号分别与满二叉树的结点 1~n 的位置序号一一对应\n注意  满二叉树必为完全二叉树，而完全二叉树不一定是满二叉树     具有 n 个结点的完全二叉树的深度为 $$ [\\log_2n]+1\\\\ eg:[\\log_27]+1=3 $$\n  对于有 n 个结点的完全二叉树，按照从上到下和从左到右的顺序编号结点，则序号 i 结点有以下关系：\n  若 i =1，则 i 无双亲结点；\n若 i\u0026gt;1，则 i 的双亲结点为$[\\frac{i}{2}]$\n  若$2×i\u0026gt;n$，则 i 无左孩子;\n    若$2×i≤n$，则 i 结点的左孩子结点为$2×i$\n  若$2×i+1\u0026gt;n$，则 i 无右孩子;\n若$2×i+1≤n$，则 i 的右孩子结点为$2×i+1$\n  二叉树存储结构 顺序存储 以完全二叉树的形式来存储数据元素，但对于一般二叉树，这将造成极大的空间浪费。\n举个栗子  单支树是其极端情况，例如一颗深度 4 的单支树，我们需要用 15 个结点空间来存储这 4 个结点。   链式存储 我们采用二叉链表来存储二叉树，其中每个结点需要有三个域： $$ \\begin{array}{|c|c|c|} \\hline LChild \u0026amp; Data \u0026amp; RChild\\\\\\hline \\end{array} $$\n1 2 3 4 5  typedef struct Node { char data; struct Node *LChild, *RChild; } BiTNode, *BiTree;   有时，为了寻找其双亲结点，我们还会增设Parent域形成三叉链表 $$ \\begin{array}{|c|c|c|c|} \\hline LChild \u0026amp; Data \u0026amp; Parent \u0026amp; RChild\\\\\\hline \\end{array} $$\n二叉树的遍历与线索化 二叉树的遍历 含义：指按一定规律对二叉树中的每个结点访问且仅访问一次。\n目的：将非线性结构经过遍历得到结点访问序列，也就是线性化过程\n按照先左后右，相对于根的顺序，有以下三种方式：\n DLR 先序遍历 LDR 中序遍历 LRD 后序遍历  对于下面这个二叉树，三种遍历方法有不同的结果\nDLR的递归定义 1 2 3 4 5 6 7 8 9  void PreOrder(BiTree root) { if (root) { Visit(root-\u0026gt;data); PreOrder(root-\u0026gt;LChild); PreOrder(root-\u0026gt;RChild); } }   结果：ABDFGCEH\nLDR的递归定义 1 2 3 4 5 6 7 8 9  void InOrder(BiTree root) { if (root) { InOrder(root-\u0026gt;LChild); Visit(root-\u0026gt;data); InOrder(root-\u0026gt;RChild); } }   结果：BFDGACEH\nLRD的递归定义 1 2 3 4 5 6 7 8 9  void PostOrder(BiTree root) { if (root) { PostOrder(root-\u0026gt;LChild); PostOrder(root-\u0026gt;RChild); Visit(root-\u0026gt;data); } }   结果：FGDBHECA\n遍历算法应用 输出二叉树中的结点（先序遍历） 1 2 3 4 5 6 7 8 9  void PreOrder(BiTree root) { if (root) { printf(\u0026#34;%c\u0026#34;,root-\u0026gt;data); PreOrder(root-\u0026gt;LChild); PreOrder(root-\u0026gt;RChild); } }   输出二叉树中的叶子结点（先序遍历） 1 2 3 4 5 6 7 8 9 10  void PreOrder(BiTree root) { if (root) { if (root-\u0026gt;LChild == NULL \u0026amp;\u0026amp; root-\u0026gt;RChild == NULL) printf(\u0026#34;%c\u0026#34;, root-\u0026gt;data); PreOrder(root-\u0026gt;LChild); PreOrder(root-\u0026gt;RChild); } }   统计叶子结点数目（后序遍历） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  //方法一 int LeafCount = 0; void leaf_1(BiTree root) { if (root) { leaf_1(root-\u0026gt;LChild); leaf_1(root-\u0026gt;RChild); if (root-\u0026gt;LChild == NULL \u0026amp;\u0026amp; root-\u0026gt;RChild == NULL) LeafCount++; } } //方法二 int leaf_2(BiTree root) { int LeafCount; if (root) LeafCount = 0; else if (root-\u0026gt;LChild == NULL \u0026amp;\u0026amp; root-\u0026gt;RChild == NULL) LeafCount = 1; else LeafCount = leaf_2(root-\u0026gt;LChild) + leaf_2(root-\u0026gt;RChild); return LeafCount; }   建立二叉链表存储的二叉树 1 2 3 4 5 6 7 8 9 10 11 12 13 14  void CreateBiTree(BiTree *bt) { char ch; ch = getchar(); if (ch == \u0026#39;.\u0026#39;) *bt = NULL; else { *bt = (BiTree)malloc(sizeof(BiTNode)); (*bt)-\u0026gt;data = ch; CreateBiTree(\u0026amp;((*bt)-\u0026gt;LChild)); CreateBiTree(\u0026amp;((*bt)-\u0026gt;RChild)); } }   按树状横向打印二叉树（中序遍历） 1 2 3 4 5 6 7 8 9 10  void PrintTree(BiTree root, int nLayer) { if (!root) return; PrintTree(root-\u0026gt;RChild, nLayer + 1); for (int i = 0; i \u0026lt; nLayer; i++) printf(\u0026#34; \u0026#34;); printf(\u0026#34; %c\\n\u0026#34;, root-\u0026gt;data); PrintTree(root-\u0026gt;LChild, nLayer + 1); }   基于栈的递归消除 在数据结构学习(三)#栈的应用与递归中已经简单地介绍了递归的一系列问题，但并没有介绍基于栈的递归消除方法。本节将讲解此部分内容。\n中序遍历的非递归算法（直接实现栈操作） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  void Inorder(BiTree root) { int top = 0; BiTNode *p; p = root; /************** L1: //遍历左子树 if (p) { top += 2; if (top \u0026gt; m) //溢出处理 return; s[top - 1] = p; //本层参数进栈 s[top] = L2; //返回地址进栈 p = p-\u0026gt;LChild; //给下层参数赋值 goto L1; } L2: //访问根 Visit(p-\u0026gt;data); top += 2; if (top \u0026lt; m) return; //溢出处理 s[top - 1] = p; //遍历右子树 s[top] = L3; p = p-\u0026gt;RChild; goto L2; L3: //退层 if (top) { addr = s[top]; p = s[top - 1]; //取出返回地址 top -= 2; //退出本层参数 goto addr; //恢复上层断点 } ***************/ do { while (p) { if (top \u0026gt; m) return; top++; s[top] = p; p = p-\u0026gt;LChild; } if (top) { p = s[top]; top--; Visit(p-\u0026gt;data); p = p-\u0026gt;RChild; } } while (p || top); }   中序遍历的非递归算法（调用栈操作） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  void InOrder(BiTree root) { SeqStack S; InitStack(\u0026amp;S); BiTNode *p; p = root; while (p || !IsEmpty(S)) { if (p) //进栈，遍历左子树  { push(\u0026amp;S, p); p = p-\u0026gt;LChild; } else //退栈，访问根结点，遍历右子树  { pop(\u0026amp;S, \u0026amp;p); Visit(p-\u0026gt;data); p = p-\u0026gt;RChild; } } }   线索二叉树 通过前面介绍的遍历运算我们将一颗二叉树进行了线性化，但无法直接得到结点在遍历序列中的前驱、后继结点的信息，由此，我们想到两种办法解决这个问题：\n 将二叉树遍历一遍，在遍历过程中便可得结点的前驱和后继，但这种动态访问浪费时间。 充分利用二叉链表中的空链域，将遍历过程中结点的前驱、后继信息保存下来。  问题  n 个结点的二叉树中有多少个空链域？   答案  共有 2n 个链域，其中 n-1 个非空，故有 n+1 个空链域   为了区分孩子结点、前驱结点、后继结点，我们应新增设两个标志域（Ltag、Rtag）： $$ \\begin{array}{|c|c|c|c|c|} \\hline Ltag \u0026amp; LChild \u0026amp; Data \u0026amp; Rtag \u0026amp; RChild\\\\\\hline \\end{array} $$ Ltag：\n Ltag=0——LChild域指示结点的左孩子 Ltag=1——LChild域指示结点的遍历前驱  Rtag：\n Rtag=0——RChild域指示结点的右孩子 Rtag=1——RChild域指示结点的遍历后继  相关术语：\n 线索：指向前驱和后继结点的指针 线索链表：具有线索的二叉链表 线索化：对二叉树遍历并加上线索（修改空链域）的过程 线索二叉树：线索化了的二叉树  中序遍历线索化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  void Inthread(BiTree root) //当前结点root，前驱结点pre { BiTNode *pre = NULL; if (root) { Inthread(root-\u0026gt;LChild); //线索化左子树  if (!root-\u0026gt;LChild) { root-\u0026gt;Ltag = 1; root-\u0026gt;LChild = pre; //前驱线索  } if (pre \u0026amp;\u0026amp; !pre-\u0026gt;RChild) { pre-\u0026gt;Rtag = 1; pre-\u0026gt;RChild = root; //后继线索  } pre = root; Inthread(root-\u0026gt;RChild); //线索化右子树  } }   在中序线索二叉树中找前驱结点 1 2 3 4 5 6 7 8 9 10 11  void InPre(BiTNode *p, BiTNode *pre) //找p的中序前驱pre { BiTNode *q; if (p-\u0026gt;Ltag) pre = p-\u0026gt;LChild; else { for (q = p-\u0026gt;LChild; !q-\u0026gt;Rtag; q = q-\u0026gt;RChild) //在p的左子树中查找“最右下端”结点  pre = q; } }   在中序线索二叉树中找后继结点 1 2 3 4 5 6 7 8 9 10 11  void InSucc(BiTNode *p, BiTNode *succ) //找p的中序后继succ { BiTNode *q; if (p-\u0026gt;Rtag) succ = p-\u0026gt;RChild; else { for (q = p-\u0026gt;RChild; q-\u0026gt;Ltag == 0; q = q-\u0026gt;LChild) //在p的右子树中查找“最左下端”结点  succ = q; } }   在先序线索二叉树中找后继结点 1 2 3 4  if (!p-\u0026gt;Ltag) succ = p-\u0026gt;LChild; else succ = p-\u0026gt;RChild;   在后序线索二叉树中找前驱结点 1 2 3 4  if(!p-\u0026gt;Rtag) pre=p-\u0026gt;RChild; else pre=p-\u0026gt;LChild;   在先序线索二叉树中找前驱结点  P 为 F 的左子，则 P 的先序前驱为 F P 为 F 的右子，且 F 无左子，则 P 的先序前驱为 F P 为 F 的右子，且 F 有左子，则 P 的先序前驱为 F 的左子树的“最右下端”  在后序线索二叉树中找后驱结点  P 为 F 的左子，则 P 的后序后继为 F 的右子树的“最左下端” P 为 F 的左子，且 F 无右子，则 P 的后序后继为 F P 为 F 的右子，则 P 的后序后继为 F  由遍历序列确定二叉树    两种遍历序列的组合 是否能唯一确定二叉树     先序+中序 是   后序+中序 是   先序+后序 否    我们观察前序遍历和中序遍历可知，在前序序列中第一个结点为根结点，而根结点把中序序列分为了左子树和右子树两部分。\n举个栗子  已知一棵二叉树的前序序列为18 14 7 3 11 22 35 27，中序序列为3 7 11 14 18 22 27 35。\n则该二叉树为\n   同理，后序序列中的最后一个结点为根结点，而根结点把中序序列分为了左子树和右子树两部分。\n这里给出由先序和中序序列还原二叉树并横向树状打印的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#define m 25  typedef struct Node { char data; struct Node *LChild, *RChild; } BiTNode, *BiTree; void PrintTree(BiTree root, int nLayer) //横向打印 { if (!root) return; PrintTree(root-\u0026gt;RChild, nLayer + 1); for (int i = 0; i \u0026lt; nLayer; i++) printf(\u0026#34; \u0026#34;); printf(\u0026#34; %c\\n\u0026#34;, root-\u0026gt;data); PrintTree(root-\u0026gt;LChild, nLayer + 1); } BiTree Create(char *pre, char *in, int cnt) { BiTree root; int inPtr, LeftCnt, RightCnt; inPtr = LeftCnt = RightCnt = 0; root = (BiTree)malloc(sizeof(BiTNode)); if (!root) return; root-\u0026gt;data = pre[0]; root-\u0026gt;LChild = NULL; root-\u0026gt;RChild = NULL; if (cnt == 1) return root; while (in[++inPtr] != pre[0]) //找根结点  ; LeftCnt = inPtr; RightCnt = cnt - LeftCnt - 1; root-\u0026gt;LChild = Create(\u0026amp;pre[1], in, LeftCnt); root-\u0026gt;RChild = Create(\u0026amp;pre[LeftCnt + 1], \u0026amp;in[LeftCnt + 1], RightCnt); return root; } int main() { BiTree root; char pre[m], in[m]; printf(\u0026#34;请输入前序序列:\u0026#34;); gets(pre); printf(\u0026#34;请输入中序序列:\u0026#34;); gets(in); root = Create(pre, in, strlen(pre)); PrintTree(root, 0); return 0; } /* 输入： 请输入前序序列:abdecfg 请输入中序序列:dbeafcg 输出： g c f a e b d */   总结 遍历运算是基础，线索是遍历应用，递归机制支持遍历，递归是技术重点。\n树、森林与二叉树的关系 树的存储结构 双亲表示法 用一组连续的空间来存储树中的结点，在保存每个结点的同时附设一个指示器来指示其双亲结点在表中的位置\n$$ \\begin{array}{|c|c|} \\hline Data \u0026amp; Parent\\\\\\hline 1 \u0026amp; -1\\\\\\hline 2 \u0026amp; 0\\\\\\hline 3 \u0026amp; 0\\\\\\hline 4 \u0026amp; 1\\\\\\hline 5 \u0026amp; 1\\\\\\hline 6 \u0026amp; 1\\\\\\hline 7 \u0026amp; 2\\\\\\hline \\end{array} $$\n1 2 3 4 5 6 7 8 9 10 11 12  #define MAX 100 typedef struct TNode { int data; int parent; } TNode; typedef struct { TNode terr[MAX]; int nodenum; //结点数 } parentTree;     优点：\n容易查找双亲结点\n  缺点：\n求孩子结点需要遍历整个数组\n  孩子表示法 每个结点的孩子结点构成一个单链表，即 n 个结点共有 n 个孩子链表。n 个结点的数据和 n 个孩子链表的头指针组成一个顺序表。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  typedef struct ChildNode //孩子链表 { int Child; //孩子结点在线性表中的位置  struct ChildNode *next; } ChildNode; typedef struct //顺序表 { int data; ChildNode *FirstChild; //头指针 } DataNode; typedef struct //树 { DataNode nodes[MAX]; //顺序表  int root, num; //根节点位置，结点数 } ChildTree;   孩子兄弟表示法（最重要） 链表中每个结点设有两个链域，分别指向该结点的第一个孩子结点和下一个兄弟（右兄弟）结点。事实上，这是一种二叉链表。 $$ \\begin{array}{|c|c|c|} \\hline Data \u0026amp; FirstChild \u0026amp; NextSibling\\\\\\hline \\end{array} $$\n1 2 3 4 5  typedef struct CSNode { int data; struct CSNode *FirstChild, *NextSibling; } CSNode, *CSTree;   树、森林与二叉树的相互转换 以下步骤我们不必记忆，我们需要做的是使用孩子兄弟表示法来转换二叉树，也就是用存储来对应\n树转换为二叉树 步骤：\n 树中所有相邻兄弟之间架一条连线 对树中的每个结点，只保留其与第一个孩子结点之间的连线，删去其与其他孩子结点之间的连线 以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明  易看出，在二叉树中，其左孩子为原来的孩子结点，而右孩子为原来的兄弟结点。\n森林转换为二叉树 步骤：\n 将森林中的每棵树转换成相应的二叉树 从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树根结点的右孩子  二叉树还原为树或森林 步骤：\n 若某结点是其双亲的左孩子，则把该结点的右孩子、右孩子的右孩子\u0026hellip;都与该结点的双亲结点用线连起来 删掉原二叉树中所有双亲结点与右孩子结点的连线 整理所得到的树或森林  树与森林的遍历 树的先根遍历 若树非空，则遍历方法为\n 访问根结点 从左到右，依次先根遍历根结点的每一棵子树  树的后根遍历 若树非空，则遍历方法为\n 从左到右依次后根遍历根结点的每一棵子树 访问根节点  森林的先序遍历 若森林非空，则遍历方法为：\n 访问森林中第一棵树的根结点 先序遍历第一棵树的根结点的子树森林 先序遍历除去第一棵树之后剩余的树构成的森林  森林的中序遍历 若森林非空，则遍历方法为：\n 中序遍历森林中第一棵树的根结点的子树森林 访问第一棵树的根结点 中序遍历除去第一棵树之后剩余的树构成的森林  森林的后序遍历 若森林非空，则遍历方法为：\n 后序遍历森林中第一棵树的根结点的子树森林 后序遍历除去第一棵树之后剩余的树构成的森林 访问第一棵树的根结点  哈夫曼树及其应用 哈夫曼树 相关概念：\n  路径：从一个结点到另一个结点之间的分支序列\n  路径长度：从一个结点到另一个结点所经过的分支数目\n  树的路径长度：树中所有结点的路径长度之和为树的路径长度 PL\n  结点的权：给树的每个结点赋予一个具有某种实际意义的实数，我们称该实数为这个结点的权\n  带权路径长度：从树根到某一结点的路径长度与该结点的权的乘积\n  树的带权路径长度：树的带权路径长度为树中所有叶子结点的带权路径长度之和 $$ WPL=\\sum_{i=1}^{n}w_i×l_i $$\n  易看出，二叉树中路径长度为 K 的结点至多有 2^k 个，故而 $$ 结点 n 的路径长度=[\\log_2n]\\\\ 前n项和=\\sum_{i=1}^n[\\log_2k] $$ 由此，我们可得推论：完全二叉树具有最小路径长度的性质，然而哈夫曼树才具有最小带权路径长度的性质。\n哈夫曼树定义 哈夫曼树又叫最优二叉树，它是由 n 个带权叶子结点构成的所有二叉树中带权路径长度 WPL 最短的二叉树。\n构建哈夫曼树 步骤：\n 给定 n 个权值{w1, w2, ..., wn},构造森林F={T1,T2, ...., Tn}，其中 Ti 为单根树，根的权值为 wi 在森林 F 中选择两棵根结点权值最小的二叉树，作为一棵新二叉树的左、右子树，标记新二叉树的根结点权值为其左右子树的根结点权值之和 从F中删除被选中的那两棵二叉树，同时把新构成的二叉树加人到森林F中 重复2、3操作，直到森林中只含有一棵二叉树为止  哈夫曼树类型定义 显然，在哈夫曼树中没有度为 1 的结点，并且一棵叶子树 n 的哈夫曼有 2×(n-1) 个结点，也就是说我们可以用此大小的一维数组来存储哈夫曼树。\n而两两合并我们还需要存储其双亲信息和孩子结点信息，故而需要静态三叉链表 $$ \\begin{array}{|c|c|c|c|} \\hline Weight \u0026amp; Parent \u0026amp; LChild \u0026amp; RChild\\\\\\hline \\end{array} $$\n1 2 3 4  typedef struct { int weight, parent, LChild, RChild; } HTNode, HuffmanTree[M + 1];   哈夫曼树算法实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  void crt_huffmantree(HuffmanTree ht, int w[], int n) // w存放n个字符和指令的权值 { int m, i, s1, s2; m = 2 * n - 1; HuffmanTree *p; for (p = ht, i = 1; i \u0026lt;= n; i++, p++, w++) { (*p)-\u0026gt;weight = *w; (*p)-\u0026gt;parent = (*p)-\u0026gt;LChild = (*p)-\u0026gt;RChild = 0; } for (; i \u0026lt;= m; i++, p++) (*p)-\u0026gt;weight = (*p)-\u0026gt;parent = (*p)-\u0026gt;LChild = (*p)-\u0026gt;RChild = 0; for (i = n + 1; i \u0026lt;= m; i++) { select(ht, i - 1, \u0026amp;s1, \u0026amp;s2); //选择parent为0且weight最小的两个结点, 其序号分别赋值给s1,s2  ht[s1].parent = i; ht[s2].parent = i; ht[i].LChild = s1; ht[i].RChild = s2; ht[i].weight = ht[s1].weight + ht[s2].weight; } }   哈夫曼编码 哈夫曼编码概念  前缀码：如果在一个编码系统中，任一个编码都不是其他任何编码的前缀（最左子串），则称该编码系统中的编码是前缀码 哈夫曼编码：对一棵有 n 个叶子的哈夫曼树，若规定左分支赋 0，右分支赋 1，可得到对应叶子节点的哈夫曼编码  哈夫曼编码特性：\n 哈夫曼编码是前缀码 哈夫曼编码是最优前缀码——能使各种报文（由这 n 种字符构成的文本）对应的二进制串的平均长度最短  哈夫曼编码作用 $$ \\begin{array}{|c|c|c|c|c|c|c|c|} \\hline 指令 \u0026amp; I_1 \u0026amp; I_2 \u0026amp; I_3 \u0026amp; I_4 \u0026amp; I_5 \u0026amp; I_6 \u0026amp; I_7\\\\\\hline 使用频率p_i \u0026amp; 0.40 \u0026amp; 0.30 \u0026amp; 0.15 \u0026amp; 0.05 \u0026amp; 0.04 \u0026amp; 0.03 \u0026amp; 0.03\\\\\\hline \\end{array} $$\n对于上表所示指令频率的模型机，如果我们采用定长编码，我们每条指令都需要 3 位编码（$2^3=8$）。\n为了减少程序的总位数，我们可以采用变长编码，而一个变长编码应该是前缀码，否则容易产生二义性。\n而利用哈夫曼编码，我们可以设计出最优的前缀编码。\n我们以每条指令的使用频率作为权值构造哈夫曼树，又规定左分支记为 1，右分支记为 0。\n由此可得其哈夫曼编码为 $$ \\begin{array}{|c|c|c|c|c|c|c|c|} \\hline 指令 \u0026amp; I_1 \u0026amp; I_2 \u0026amp; I_3 \u0026amp; I_4 \u0026amp; I_5 \u0026amp; I_6 \u0026amp; I_7\\\\\\hline 编码 \u0026amp; 0 \u0026amp; 10 \u0026amp; 110 \u0026amp; 11100 \u0026amp; 11101 \u0026amp; 11110 \u0026amp; 11111\\\\\\hline \\end{array} $$ 举个栗子  我们假设该模型机有1000条指令，其频率按前表所述，若采用定长编码，程序总位数=3×1000=3000。但若采用哈夫曼编码，程序总位数=1×400+2×300+3×150+5×150=2200。且采用哈夫曼编码的平均码长为 $$ \\sum_{i=1}^nl_i=0.4×1+0.3×2+0.15×3+0.15×5=2.20 $$ 由此可见哈夫曼编码的优越性。  \n哈夫曼编码算法实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  ...//已构造哈夫曼树，现从叶子结点到根逆向求每个字符或者指令的哈夫曼编码  int start, c, f, j; hc = (HuffmanCode)malloc(n * sizeof(char *)); //分配n个字符编码的头指针  char *cd = (char *)malloc(n * sizeof(char)); cd[n - 1] = \u0026#39;\\0\u0026#39;; for (j = 0; j \u0026lt; n; j++) { start = n - 1; for (c = j; f = ht[j].parent; f != 0, c = f, f = ht[f].parent) //从叶子到根结点求编码  if (ht[f].LChild == c) cd[--start] = \u0026#39;0\u0026#39;; else cd[--start] = \u0026#39;1\u0026#39;; hc[j] = (char *)malloc((n - start) * sizeof(char)); //为第i个指令编码分配空间  strcpy(hc[j], \u0026amp;cd[start]); } free(cd); }   例题 二叉树相似性判断 1 2 3 4 5 6 7 8 9 10 11 12 13 14  int like(BiTree b1, BiTree b2) //结构相同，值可以不同 { int like1, like2; if (!b1 \u0026amp;\u0026amp; !b2) return 1; //都为空树，相似  else if (!b1 || !b2) return 0; //一空一非空，不相似  else { like1 = like(b1-\u0026gt;LChild, b2-\u0026gt;LChild); //判断b1和b2的左子树是否相似  like2 = like(b1-\u0026gt;RChild, b2-\u0026gt;RChild); //判断b1和b2的右子树是否相似  return (like1 \u0026amp;\u0026amp; like2); } }   层次遍历二叉树 之前我们学习了前序遍历、中序遍历、后序遍历，与其不同的还有层次遍历。\n层次遍历是指从二叉树的第一层（根结点）开始逐层遍历，同一层中，按照从左到右对结点访问直到二叉树中所有结点均被访问且仅访问一次。要实现层次遍历，需用到队列技术。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  bool LayerOrder(BiTree bt) { SeqQueue *Q; BiTree p; InitQueue(Q); if (!bt) return false; EnterQueue(Q, bt); while (Q-\u0026gt;front != Q-\u0026gt;rear) { DeleteQueue(Q, \u0026amp;p); visit(p-\u0026gt;data); if (p-\u0026gt;LChild) EnterQueue(Q, p-\u0026gt;LChild); if (p-\u0026gt;RChild) EnterQueue(Q, p-\u0026gt;RChild); } return true; }   ","permalink":"https://www.sukun.xyz/data_structure-6/","tags":["数据结构","学习"],"title":"数据结构学习(六)"},{"categories":["算法与数据结构"],"contents":"数据结构——用C语言描述(五) 线性结构 数组 数组的定义与运算 数组：是一组有固定个数的数据元素集合，是一般线性表的推广，组成线性表的元素为带有结构信息的元素。\n—维数组为向量形式的线性表;\n二维数组是由一维数组组成的线性表，依次类推可得到多维数组定义。\n对于数组 ADT\n数据对象：高维数组组成的线性表 $$ D={a_{j1j2…jn}|\\ n\u0026gt;0,1≤j_i≤b_i,a_{j1j2…jn}∈ElementSet} $$ 其中，n 称为数组的维数，j 是数组的第 i 维下标，b 是数组第 i 维的长度。\n结构关系：线性序列 $$ R={R_1,R_2,…,R_n} $$ 有 4 种基本操作：\n 初始化InitArray(A, n, bound1,…, boundn) 销毁DestroyArray(A) 取值GetValue(A, e, index1,…, indexn) 修改SetValue(A, e, index1,…, indexn)  数组的顺序存储与实现 数组适合顺序存储：\n 给定数组维数及各维长度，数组元素个数固定 元素存取运算不改变数组大小  同时，计算机内存储器是一维的，可直接顺序存储一维数组，但高维数组则是按照某种次序把高维映射到一维。\n 按行序存储，如 BASIC、C 语言 按列序存储，如 FORTRAN 语言（世界上第一个被正式推广使用的高级语言）  对于数组中，给定下标计算其在一维空间的存储位置有以下公式： $$ 数组元素地址=基址+(该变量线性序号-1)*size $$ 举个栗子  对于一维数组A=(a1,a2,…,an)，每个元素占据size个存储单元。\n则元素 ai 的存储地址为 $$ Loc(a[i])=Loc(a[1])+(i-1)×size $$\n  \n问题  二维数组a[5][4]按行序存放，每个元素占 4 单元,首元素地址是 2000 ，求a[3][2]的内存地址。   答案  类似与举个栗子中一维数组的公式，二维数组（下标从 1 开始）中有 $$ Loc(a[i][j])=Loc(a[1][1])+(n×(i-1)+(j-1))×size $$ 故本题答案为 $$ Loc(a[3][2]) = 2000+(4×(3-1) +(2-1))×4=2036 $$   我们还可以对此推广至一般三维数组，其下限为c1、c2、c3，上限为d1、d2、d3，则 $$ Loc(A[j_1][j_2][j_3])=Loc(A[c_1][c_2][c_3])+((d_2-c_2+1)×(d_3-c_3+1)×(j_1-c_1)+(d3-c3+1)×(j_2-c_2)+(j_3-c_3))×size $$ 信息  上述数组可记作A[c1..d1,c2..d2,c3..d3]  \n再做进一步的推广至 n 维，有 $$ Loc[j_1,j_2,…,j_n]=Loc[c_1,c_2,…,c_n]+\\sum_{i=1}^Na_i×(j_i-c_i) $$ 其中 $$ a_i=size×\\prod_{k=i+1}^n(d_k-c_k+1)\\ (1≤i≤n) $$ 注意  地址计算的题目容易出现在各种考试中，但这些公式不应该去死记硬背，而是重在理解！  \n规律分布特殊矩阵的压缩存储 原则：对有规律的元素和值相同的元素只分配一个存储单元，对于零元素不分配空间。\n思想：按规律找出地址计算公式\n三角矩阵 $$ A= \\begin{pmatrix} a_{11} \u0026amp; \u0026amp; \\\\ a_{21} \u0026amp; a_{22} \u0026amp; \\\\ a_{31} \u0026amp; a_{32} \u0026amp; a_{33}\\\\ \\end{pmatrix} \\rightarrow \\begin{array}{|c|} \\hline a_{11}\\\\\\hline a_{21}\\\\\\hline a_{22}\\\\\\hline ··· \\\\\\hline a_{nn}\\\\\\hline \\end{array} $$\n显然，此一维存储空间的大小以及地址计算公式为： $$ \\sum_{i=1}^ni=\\frac{n(n+1)}{2}\\\\ Loc[i,j]=Loc[1,1]+(\\frac{i(i-1)}{2}+j-1)*size\\ (i\u0026gt;j) $$\n带状矩阵 $$ A_{n×n}= \\begin{pmatrix} a_{11} \u0026amp; a_{12} \u0026amp;\\\\ a_{21} \u0026amp; a_{22} \u0026amp; a_{23}\\\\ \u0026amp; a_{32} \u0026amp; a_{33} \u0026amp; a_{34}\\\\ \u0026amp; \u0026amp; a_{43} \u0026amp; a_{44} \u0026amp; a_{45}\\\\ \u0026amp; \u0026amp; \u0026amp; … \u0026amp; … \u0026amp; … \\end{pmatrix} \\rightarrow \\begin{array}{|c|} \\hline a_{11}\\\\\\hline a_{12}\\\\\\hline a_{21}\\\\\\hline a_{22}\\\\\\hline a_{23}\\\\\\hline ··· \\\\\\hline a_{nn}\\\\\\hline \\end{array} $$\n显然，此一维存储空间的大小为 $$ 3n-2 $$ 又注意到元素下标 i、j 有以下关系： $$ j-i= \\begin{cases} -1 \u0026amp;,j\u0026lt;i对角线下 \\\\ 0 \u0026amp;,j=i对角线 \\\\ 1 \u0026amp;,j\u0026gt;i对角线上 \\end{cases} $$ 故而 $$ 前i-1行元素个数=3(i-1)-1\\\\ 当前行元素序号=j-i+1 $$ 由此，地址计算公式为 $$ Loc(A[i][j])=Loc(A[1][1])+(3(i-1)-1+j-i+1)*size\\\\ =Loc(A[1][1])+(2(i-1)+j-1)*size $$ 举个栗子  基地址为 2000，size 为1，求元素 a23 的地址？\nWP：前 1 行有 3(2-1)-1=2 个元素，第 2 行元素序号为 3-2+1=2，故 $$ Loc(A[2][3])=2000+(2+2)×1=2004 $$\n  \n稀疏矩阵的压缩存储 稀疏矩阵：指矩阵中大多数元素为零的矩阵。一般地，当非零元素个数只占矩阵元素总数的25%~30%，或低于这个百分数时，我们称这样的矩阵为稀疏矩阵。\n三元组表表示法 由于稀疏矩阵中非零元的毫无规律，我们需要在存储值的同时也存储其行号和列号，这样的方法称为三元组表表示法。\n1 2 3 4 5 6 7 8 9 10 11 12 13  #define MAXSIZE 1000  typedef struct { int row, col; int e; } Triple; typedef struct { Triple data[MAXSIZE + 1]; int m, n, len; // m行n列，非零元有len个 } TSmatrix;   经典转置法 1 2 3 4 5 6 7  void TransMatrix(int source[n][m], int dest[m][n]) { int i, j; for (i = 0; i \u0026lt; m; i++) for (j = 0; j \u0026lt; n; j++) dest[i][j] = source[j][i]; }   列序递增转置法 $$ \\begin{pmatrix} 1 \u0026amp; \u0026amp; 2\\\\ \u0026amp; 3 \u0026amp; \\\\ 4 \u0026amp; \u0026amp; 5\\\\ \u0026amp; 6 \u0026amp; \\\\ \\end{pmatrix} $$\n此稀疏矩阵的三元组表为\n    row col e     1 1 1 1   2 1 3 2   3 2 2 3   4 3 1 4   5 3 3 5   6 4 2 6    易于发现，仅做行列互换（交换row和col）并没有完成转置操作，因为行列互换后没有做到以行序为主序，此时还需要对行下标做排序。\n对此，我们有两种方法，其一是依次扫描col为 1 到 n，即列序递增转置法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  void TransposeTSMatrix(TSmatrix A, TSmatrix *B) { int i, j, k; B-\u0026gt;m = A.n; B-\u0026gt;n = A.m; B-\u0026gt;len = A.len; if (B-\u0026gt;len) { j = 1; for (k = 1; k \u0026lt;= A.n; k++) for (i = 1; i \u0026lt;= A.len; i++) if (A.data[i].col == k) { B-\u0026gt;data[j].row = A.data[i].col; B-\u0026gt;data[j].col = A.data[i].row; B-\u0026gt;data[j].e = A.data[i].e; j++; } } }   易得出，该算法时间复杂度为 $$ O(A.n×A.len) $$ 此算法大大降低了存储空间的开销，但时间耗费并未降低，原因在于要多次扫描稀疏矩阵三元组。\n一次定位法 为了提高算法性能，我们想通过一次循环完成转置，即对 A 中非零元“一次定位”直接放到 B 三元表中。\n需设置两个数组存放预先计算的值，实现一次定位：\n num[col]存放 A 三元组 col 列非零元个数 position[col]存放 A 三元组 col 列第一个非零元位置  由此，我们可得出一条递归关系position[col] = position[col-1] + num[col-1]其中 2\u0026lt;=col\u0026lt;=A.n。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  void FastTransposeTSMatrix(TSmatrix A, TSmatrix *B) { int col, t, p, q, num[MAXSIZE], position[MAXSIZE]; B-\u0026gt;len = A.len; B-\u0026gt;m = A.n; B-\u0026gt;n = A.m; if (B-\u0026gt;len) { for (col = 1; col \u0026lt;= A.n; col++) num[col] = 0; for (t = 1; t \u0026lt;= A.len; t++) num[A.data[t].col]++; position[1] = 1; for (col = 2; col \u0026lt;= A.n; col++) position[col] = position[col - 1] + num[col - 1]; for (p = 1; p \u0026lt; A.len; p++) { col = A.data[p].col; q = position[col]; B-\u0026gt;data[q].row = A.data[p].col; B-\u0026gt;data[q].col = A.data[p].row; B-\u0026gt;data[q].e = A.data[p].e; position[col]++; } } }   由于此算法只扫描一次三元组，故时间复杂度为 $$ O(A.n+A.len) $$ 举个栗子  现有一稀疏矩阵A，A.m=100，A.n=500，A.len=100\n 使用列序递增法：时间耗费为 A.n×A.len=50000 次，存储耗费为 A.len×3=300 使用一次定位法：时间耗费为 A.n+A.len+A.n+A.len=1200 次，存储耗费为 A.len×3+A.n×2=1300  可以看出，一次定位法大大降低了时间开销。\n  \n链式存储结构：十字链表 使用链表存储稀疏矩阵可以实现矩阵的动态存储，即灵活地进行矩阵运算操作。\n结点结构示意图：\n1 2 3 4 5 6 7 8 9 10 11 12  typedef struct { int row, col; //非零元的行列下标  int value; struct OLNode *right, *down; //非零元的后继链域 } OLNode, *OLlik; typedef struct { OLlik *row_head, *col_head; //行列链表头指针  int m, n, len; // m行n列，有len个非零元的稀疏矩阵 } CrossList;   $$ \\begin{pmatrix} -3 \u0026amp; 0 \u0026amp; 0 \u0026amp; 5\\\\ 0 \u0026amp; -1 \u0026amp; 0 \u0026amp; 0\\\\ 8 \u0026amp; 0 \u0026amp; 0 \u0026amp; 7\\\\ \\end{pmatrix} $$\n上述矩阵十字链表描的示意图：\n容易看出，该矩阵用十字链表表示需要 4+3+5=12 个结点。\n广义表 广义表是线性表的推广，是 n 个数据元素的有限序列。记作： $$ GL=(d_1,d_2,…,d_n) $$ 称 n 为广义表长度，GL 为广义表名。\n若广义表的元素也是广义表，则称其为子表，也就是说广义表是递归定义的。\n规定：广义表元素大写，单元素小写，d1 为表头，其余元素构成的表 (d2, d3, …, dn) 是表尾。\n广义表的存储结构 广义表的头尾链表存储结构 由于广义表的特性，我们需要有两类结点：单元素结点、表结点。\n对于表结点，需要有三个域：标志域、指向表头的指针域、指向表尾的指针域。\n而对于但元素结点，只需要两个域：标志域、值域。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  typedef enum { ATOM, LIST } ElemTag; // ATOM表示原子默认值0，LIST表示子表默认值1  typedef struct GLNode { ElemTag tag; //标志域  union { int atom; //原子结点值域  struct { struct GLNode *hp, tp; } htp; //表结点  } atom_htp; //联合体域 } * GList;   广义表的同层结点链存储结构 单元素结点和子表结点均由三个域组成。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  typedef enum { ATOM, LIST } ElemTag; typedef struct GLNode { ElemTag tag; //标志域  union { int atom; //原子结点值域  struct GLNode *hp; } atom_hp; //联合体域  struct GLNode *tp; } * GList;   ","permalink":"https://www.sukun.xyz/data_structure-5/","tags":["数据结构","学习"],"title":"数据结构学习(五)"},{"categories":["算法与数据结构"],"contents":"数据结构——用C语言描述(四) 线性结构 串 串的定义   字符串（string）：零个或多个字符组成的有限序列。记为 $$ S=\u0026lsquo;a_1a_2…a_n\u0026rsquo;\\ (n≥0),a_i∈V字符集合 $$ 组成线性表的每个元素就是一个单字符串是特定的线性表\n  串的名字：S\n  串的值：单引号括起来的字符序列，可以是字母，数字或其他字符\n  串的长度：n，串中字符的个数\n  空串（Null String）：n=0 时的串\n  举个栗子  ch='hello world'就是字符串长度为 11 ，串名为 ch 的字符串    子串：串中任意个连续字符组成的子序列。 主串：包含子串的串。 求子串：sub(主串，起始位置，长度)  举个栗子  sub('china',2,2)='in'   模式串在主串中的位置（串的模式匹配）：从主串的起始位置起，模式串在主串中首次出现的位置序号\n举个栗子  主串'Beijing,China'模式串in：\n若起始位置为 0，则模式串第一个字符在主串中的位置为 4；\n若起始位置为 5，则模式串第一个字符在主串中的位置为 10。\n   串相等：当且仅当两个串长度相等且对应位置的字符都相等。\n空串与空格串的区别：\n 空格串：一个或多个空格组成的串，其长度为空格个数。 空串：无任何字符组成的串，其长度为零。  对于串 ADT：\n数据对象：字符集 $$ D={a_i|\\ a_i∈CharacterSet,\\ i=1,2,…,n;\\ n≥0} $$ 数据关系：线性关系 $$ R={\u0026lt;a_{i-1},a_i\u0026gt;|\\ a_{i-1},a_i∈D,\\ i=1,2,…,n;\\ n≥0} $$ 有 13 种基本操作运算：\n 赋值StrAsign(S, str) 插入StrInsert(S, pos, T) 删除StrDelete(S, pos, len) 拷贝StrCopy(S, T) 判空StrEmpty(S) 比较StrCompare(S, T) 求串长StrLength(S) 清空StrClear(S) 连接StrCat(S, T) 求子串SubString(Sub, S, pos, len) 串的模式匹配Strlndex(S, T, pos) 置换StrReplace(S, T, V) 消除StrDestroy(s)  串的顺序存储 定长顺序串 1 2 3 4 5 6  #define MAXLEN 20 typedef struct { char ch[MAXLEN]; int len; } SString;   串插入 在进行串的插人时，插人位置 pos 将串分为两部分（假设为 A、B，长度为 LA、LB），及待插人部分（假设为 C，长度为 LC），则串由插人前的 AB 变为 ACB ，可能有三种情况：\n  插入后串长 (LA+LB+LC) ≤ MAXLEN：\n将 B 后移 LC 个元素位置，再将 C 插人\n  插入后串长 \u0026gt; MAXLEN 且 pos + LC \u0026lt; MAXLEN：\nB 后移时会有部分字符被舍弃\n  插入后串长 \u0026gt; MAXLEN 且 pos + LC \u0026gt; MAXLEN：\nB 的全部字符被舍弃（不需后移），并且在插人时也有部分字符被舍弃\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  bool StrInsert(SString *s, int pos, SString t) //在串s中序号为pos的字符之前插入串t { int i; if (pos \u0026lt; 0 || pos \u0026gt; s-\u0026gt;len) //插入位置不合法  return false; if (s-\u0026gt;len + t.len \u0026lt;= MAXLEN) //插入后串长≤MAXLEN  { for (i = s-\u0026gt;len + t.len - 1; i \u0026gt;= t.len + pos; i--) s-\u0026gt;ch[i] = s-\u0026gt;ch[i - t.len]; for (i = 0; i \u0026lt; t.len; i++) s-\u0026gt;ch[i + pos] = t.ch[i]; s-\u0026gt;len += t.len; } else if (pos + t.len \u0026lt;= MAXLEN) //插入后串长\u0026gt;MAXLEN,但串t可以全部插入  { for (i = MAXLEN - 1; i \u0026gt; t.len + pos - 1; i--) s-\u0026gt;ch[i] = s-\u0026gt;ch[i - t.len]; for (i = 0; i \u0026lt; t.len; i++) s-\u0026gt;ch[i + pos] = t.ch[i]; s-\u0026gt;len = MAXLEN; } else //串t的部分要舍弃  { for (i = 0; i \u0026lt; MAXLEN - pos; i++) s-\u0026gt;ch[i + pos] = t.ch[i]; s-\u0026gt;len = MAXLEN; } return true; }   串的模式匹配 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  int index(SString s, int pos, SString t) //从主串s的pos位置起,与模式串t逐位匹配 { int i, j; if (!t.len) return 0; //空串是任意串的子串  i = pos; j = 0; while (i \u0026lt; s.len \u0026amp;\u0026amp; j \u0026lt; t.len) if (s.ch[i] == t.ch[j]) { i++; j++; } else { i = i - j + 1; //对应字符不等，主串从起始位置下一位起  j = 0; } if (j \u0026gt;= t.len) return i - j; else return -1; //匹配不成功，返回-1 }   注意到时间主要耗费在了 while 循环即回溯中，这种算法也称为 BF 算法（或暴力匹配算法）其时间复杂度为 $$ O(s.len*t.len) $$ 对于该算法的改进，重点在于实现非回溯，其中的佼佼者 KMP 算法能在时间复杂度上达到 $$ O(n+m) $$\n这里仅给出其代码，详解：KMP算法（快速模式匹配算法）C语言详解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; void Next(char *T, int *next) { int i = 1; next[1] = 0; int j = 0; while (i \u0026lt; strlen(T)) { if (j == 0 || T[i - 1] == T[j - 1]) { i++; j++; next[i] = j; } else { j = next[j]; } } } int KMP(char *S, char *T) { int next[10]; Next(T, next); //根据模式串T,初始化next数组  int i = 1; int j = 1; while (i \u0026lt;= strlen(S) \u0026amp;\u0026amp; j \u0026lt;= strlen(T)) { // j==0:代表模式串的第一个字符就和当前测试的字符不相等；S[i-1]==T[j-1],如果对应位置字符相等，两种情况下，指向当前测试的两个指针下标i和j都向后移  if (j == 0 || S[i - 1] == T[j - 1]) { i++; j++; } else { j = next[j]; //如果测试的两个字符不相等，i不动，j变为当前测试字符串的next值  } } if (j \u0026gt; strlen(T)) { //如果条件为真，说明匹配成功  return i - (int)strlen(T); } return -1; } int main() { int i = KMP(\u0026#34;ababcabcacbab\u0026#34;, \u0026#34;abcac\u0026#34;); printf(\u0026#34;%d\u0026#34;, i); return 0; }   堆串 堆：系统将一个地址连续、容量很大的存储空间作为字符串的可用空间。\n每建立新串时，需提供串值的起始位置指针和串长度,示统从堆串区分配空间。\n串的链式存储 块链串是有头尾指针的链表，其中单个结点称为块。\n 结点大小：data 域存放字符个数  结点大小为 1 时，存储密度低，处理简单，是单链表 结点大小大于 1 时，存储密度高，管理复杂   链域大小：next 域占用字符个数  1 2 3 4 5 6 7 8 9 10 11 12 13 14  #define BLOCK_SIZE 4  typedef struct { char ch[BLOCK_SIZE]; struct Block *next; } Block; typedef struct { Block *head; Block *tail; int len; } BLString;   这里仅给出普通模式匹配算法（BF算法）用链式存储的实现，其他内容的具体操作与单链表类似，请看数据结构学习(二)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  Block *StrIndex(BLString *s, BLString *t) { Block *sp, *tp, *start; if (!t-\u0026gt;len) return s-\u0026gt;head-\u0026gt;next; start = s-\u0026gt;head-\u0026gt;next; sp = start; tp = t-\u0026gt;head-\u0026gt;next; while (sp != NULL \u0026amp;\u0026amp; tp != NULL) { if (sp-\u0026gt;ch == tp-\u0026gt;ch) { sp = sp-\u0026gt;next; tp = tp-\u0026gt;next; } else { start = start-\u0026gt;next; sp = start; tp = t-\u0026gt;head-\u0026gt;next; } } if (tp == NULL) return start; else return NULL; }   问题  假设主串S='aaabbbababaabb' ,模式串P='abaa' ，用 BF 算法从主串的第 6 个字符开始进行模式匹配，需要做多少趟匹配，第2趟匹配做多少次比较？   答案  4趟，4次  ","permalink":"https://www.sukun.xyz/data_structure-4/","tags":["数据结构","学习"],"title":"数据结构学习(四)"},{"categories":["算法与数据结构"],"contents":"数据结构——用C语言描述(三) 线性结构 限定性线性表——栈和队列 限定性：限制线性表插入和删除等运算的位置（只允许在端点位置操作）\n栈 栈的定义与实现  栈的定义：把运算位置限制在表尾端 栈顶：允许运算端 栈底：不允许运算端 栈顶指示器：用来指示动态变化的栈顶位置 空栈：表中无任何元素 满栈：无法申请到栈区可用空间 栈的常见运算：进栈（入栈）、退栈（出栈） 上溢：栈已满还入栈 下溢：栈已空还出栈 栈的特性：后进先出（Last In First Out, LIFO）  对于栈 ADT：\n数据元素：同一个数据对象的任意类型数据\n关系：栈中数据元素之间是线性关系\n有 7 种基本操作运算：\n 初始化InitStack(S) 清栈ClearStack(S) 判空IsEmpty(S) 判满IsFull(S) 进栈Push(S, x) 出栈Pop(S, x) 读栈顶GetTop(S, x)  问题  按1，2，3的顺序进栈，则出栈顺序有哪些?   答案  元素在进栈过程中也可以出栈，也就是并非所有元素全部进栈后再出栈。\n因此，出栈顺序有：123，132，213，231，321\n   栈的顺序实现  用一组连续的存储单元依次存放自栈底到栈顶的数据元素 设一个位置指针top（栈顶指针）动态指示栈顶元素在顺序栈中的位置 top = -1 表示空栈  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  #define Stack_Size 50  typedef struct { int elem[Stack_Size]; int top; } SeqStack; void InitStack(SeqStack *S) { S-\u0026gt;top = -1; } bool IsEmpty(SeqStack S) { return S.top == -1; } bool IsFull(SeqStack S) { return S.top == Stack_Size - 1; } bool push(SeqStack *S, int x) { if (IsFull(*S)) return false; S-\u0026gt;top++; S-\u0026gt;elem[S-\u0026gt;top] = x; return true; } bool pop(SeqStack *S, int *x) { if (IsEmpty(*S)) return false; *x = S-\u0026gt;elem[S-\u0026gt;top]; S-\u0026gt;top--; return true; } bool GetTop(SeqStack S, int *x) { if (IsEmpty(S)) return false; *x = S.elem[S.top]; return true; }   顺序实现的两栈共享技术 为两个栈申请一个共享的一维数组空间S[M]，将两个栈的栈底分别为一维数组的两端 0 和 M-1。\n值得注意的是，判满条件应为S-\u0026gt;top[0] + 1 == S-\u0026gt;top[1]即栈顶指示器相邻，并且一个栈空并不会影响另一个栈是否为空。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  #define M 100  typedef struct { int Stack[M]; //栈区  int top[2]; // top[0]、top[1]为两个栈顶指示器 } DqStack; void InitStack(DqStack *S) { S-\u0026gt;top[0] = -1; S-\u0026gt;top[1] = M; } bool push(DqStack *S, int x, int i) { if (S-\u0026gt;top[0] + 1 == S-\u0026gt;top[1]) return false; switch (i) { case 0: S-\u0026gt;top[0]++; S-\u0026gt;Stack[S-\u0026gt;top[0]] = x; break; case 1: S-\u0026gt;top[1]--; S-\u0026gt;Stack[S-\u0026gt;top[1]] = x; break; default: return false; } return true; } bool pop(DqStack *S, int *x, int i) { switch (i) { case 0: if (S-\u0026gt;top[0] == -1) return false; *x = S-\u0026gt;Stack[S-\u0026gt;top[0]]; S-\u0026gt;top[0]--; break; case 1: if (S-\u0026gt;top[1] == M) return false; *x = S-\u0026gt;Stack[S-\u0026gt;top[1]]; S-\u0026gt;top[1]++; break; default: return false; } return true; }   栈的链式实现  采用带头结点的单链表实现链栈 头指针就作为栈顶指针 使用完毕时应释放其空间  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  typedef struct node { int data; struct node *next; } LinkStackNode; typedef LinkStackNode *LinkStack; bool push(LinkStack top, int x) { LinkStackNode *tmp; tmp = (LinkStackNode *)malloc(sizeof(LinkStackNode)); if (tmp == NULL) return false; tmp-\u0026gt;data = x; tmp-\u0026gt;next = top-\u0026gt;next; //头插  top-\u0026gt;next = tmp; return true; } bool pop(LinkStack top, int *x) { LinkStackNode *tmp; tmp = top-\u0026gt;next; if (tmp == NULL) //栈空  return false; top-\u0026gt;next = tmp-\u0026gt;next; *x = tmp-\u0026gt;data; free(tmp); return true; }   链式实现的多栈 top[0]、top[1]、……、top[M-1]分别为 M 个栈的栈顶指针。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdbool.h\u0026gt;#define M 5  typedef struct node { int data; struct node *next; } LinkStackNode; typedef LinkStackNode *LinkStack; void InitStack(LinkStack *top) { *top = (LinkStack *)malloc(sizeof(LinkStackNode)); (*top)-\u0026gt;next = NULL; } bool push(LinkStack top, int x) { LinkStackNode *tmp; tmp = (LinkStackNode *)malloc(sizeof(LinkStackNode)); if (tmp == NULL) return false; tmp-\u0026gt;data = x; tmp-\u0026gt;next = top-\u0026gt;next; //头插  top-\u0026gt;next = tmp; return true; } bool pop(LinkStack top, int *x) { LinkStackNode *tmp; tmp = top-\u0026gt;next; if (tmp == NULL) //栈空  return false; top-\u0026gt;next = tmp-\u0026gt;next; *x = tmp-\u0026gt;data; free(tmp); return true; } int main() { LinkStack top[M]; int tmp; for (int i = 0; i \u0026lt; 5; i++) { InitStack(\u0026amp;top[i]); push(top[i], i + 1); pop(top[i], \u0026amp;tmp); printf(\u0026#34;栈%d顶元素值%d\\n\u0026#34;, i + 1, tmp); } return 0; } /* 输出： 栈1顶元素值1 栈2顶元素值2 栈3顶元素值3 栈4顶元素值4 栈5顶元素值5 */   两种存储结构的栈满  顺序栈判满与数组定义长度有关 链栈判满与可否申请系统空间有关  栈的应用与递归 括号匹配 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdbool.h\u0026gt;#include \u0026lt;ctype.h\u0026gt;#define Stack_Size 50  typedef struct { char elem[Stack_Size]; int top; } Stack; void InitStack(Stack *S) { S-\u0026gt;top = -1; } bool IsEmpty(Stack S) { return S.top == -1; } bool IsFull(Stack S) { return S.top == Stack_Size - 1; } bool push(Stack *S, char x) { if (IsFull(*S)) return false; S-\u0026gt;top++; S-\u0026gt;elem[S-\u0026gt;top] = x; return true; } bool pop(Stack *S, char *x) { if (IsEmpty(*S)) return false; *x = S-\u0026gt;elem[S-\u0026gt;top]; S-\u0026gt;top--; return true; } bool GetTop(Stack S, char *x) { if (IsEmpty(S)) return false; *x = S.elem[S.top]; return true; } int read_line(char str[], int n) { int ch, i = 0; while (isspace(ch = getchar())) ; while (ch != \u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; ch != EOF) { if (i \u0026lt; n) { str[i++] = ch; ch = getchar(); } } str[i] = \u0026#39;\\0\u0026#39;; return i; } void BracketMatch(char *str) { Stack S; int i; char ch; InitStack(\u0026amp;S); for (i = 0; str[i] != 0; i++) { switch (str[i]) { case \u0026#39;(\u0026#39;: case \u0026#39;[\u0026#39;: case \u0026#39;{\u0026#39;: push(\u0026amp;S, str[i]); break; case \u0026#39;)\u0026#39;: case \u0026#39;]\u0026#39;: case \u0026#39;}\u0026#39;: if (IsEmpty(S)) { printf(\u0026#34;右括号多余\\n\u0026#34;); return; } else { GetTop(S, \u0026amp;ch); if ((ch == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; str[i] == \u0026#39;)\u0026#39;) || (ch == \u0026#39;[\u0026#39; \u0026amp;\u0026amp; str[i] == \u0026#39;]\u0026#39;) || (ch == \u0026#39;{\u0026#39; \u0026amp;\u0026amp; str[i] == \u0026#39;}\u0026#39;)) pop(\u0026amp;S, \u0026amp;ch); else { printf(\u0026#34;对应的左右括号不同类\\n\u0026#34;); return; } } } } if (IsEmpty(S)) printf(\u0026#34;括号匹配\\n\u0026#34;); else printf(\u0026#34;左括号多余\\n\u0026#34;); } int main() { char str[50]; read_line(str, 50); BracketMatch(str); return 0; }   运行截图：\n栈与递归 递归：在定义自身的同时又出现了对自身的调用\n递归定义的数学函数：斐波那契数列\n阿克曼函数\n例如递归求解汉诺塔：\n1 2 3 4 5 6 7 8 9 10 11 12  //将A塔座上1到n编号的由小到大圆盘按规则搬到C塔座上，B柱作为辅助塔座 void Hanoi(int n, char A, char B, char C) { if (n == 1) move(A, C); else if (n \u0026gt; 1) { Hanoi(n - 1, A, C, B); move(A, C); Hanoi(n - 1, B, A, C); } }   使用递归的前提：\n 原问题可以层层分解为类似的子问题，且子问题比原问题的规模更小 规模最小的子问题具有直接解  递归过程的实现：\n 递归进程（i-\u0026gt;i+1 层）  保留本层参数与返回地址 给下层参数赋值 将程序转移到被调函数的人口   递归退程（i+1-\u0026gt;i 层）  保存被调函数的计算结果 恢复上层参数〈释放被调函数的数据区) 依照被调函数保存的返回地址，将控制转移回调用函数    而上述过程实质上是利用栈机制实现的。\n但递归算法有缺陷：\n 时间效率低 可能栈溢出。由于递归是用栈实现的，而每个进程的栈容量有限，当调用层次过多，可能发生栈溢出 部分语言不支持递归（如 basic 语言）  基此原因，我们需要消除递归：\n 第一类，简单递归问题的转换。对于尾递归、单向递归的算法，使用循环代替 第二类，基于栈的方式。将隐性栈转化为受用户控制的显性栈  信息  尾递归：递归调用语句只有一个且处于算法的最后，尾递归是单向递归的特例。   斐波那契数列的非递归实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  int fib(int n) { int x = 0, y = 1, z; if (n == 0 || n == 1) return n; else for (int i = 2; i \u0026lt;= n; i++) { z = y; y = x + y; x = z; } return y; }   循环结构表示阶乘问题的尾递归算法：\n1 2 3 4 5 6 7  long fact(int n) { int fac = 1; for (int i = 1; i \u0026lt;= n; i++) fac *= i; return fac; }   队列 队列的定义与实现  队列（Queue）定义：只允许在表的一端插人元素，而在另一端删除元素的一种限定性线性表。 队头：允许删除的一端 队尾：允许插入的一端 特性：先进先出（ Fist In Fist Out, FIFO）  对于队列 ADT：\n数据元素：同一个数据对象的任意类型数据\n关系：队列中数据元素之间是线性关系\n有 8 种基本操作运算：\n 初始化InitQueue(\u0026amp;Q) 判空IsEmpty(Q) 判满IsFull(Q) 进队EnterQueue(\u0026amp;Q, x) 出队DeleteQueue(\u0026amp;Q, \u0026amp;x) 取队头GetHead(Q, \u0026amp;x) 清队ClearQueue(\u0026amp;Q) 删除队列DestroyQueue(\u0026amp;Q)  队列的链式实现  队首指针front、队尾指针rear为队首、队尾指示器 队尾进，队首出  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  typedef struct Node { int data; struct Node *next; } LinkQueueNode; typedef struct { LinkQueueNode *front; LinkQueueNode *rear; } LinkQueue; bool InitQueue(LinkQueue *Q) { Q-\u0026gt;front = (LinkQueueNode *)malloc(sizeof(LinkQueueNode)); if (Q-\u0026gt;front != NULL) { Q-\u0026gt;rear = Q-\u0026gt;front; Q-\u0026gt;front-\u0026gt;next = NULL; return true; } else return false; } bool EnterQueue(LinkQueue *Q, int x) { LinkQueueNode *NewNode; NewNode = (LinkQueueNode *)malloc(sizeof(LinkQueueNode)); if (NewNode != NULL) { NewNode-\u0026gt;data = x; NewNode-\u0026gt;next = NULL; Q-\u0026gt;rear-\u0026gt;next = NewNode; Q-\u0026gt;rear = NewNode; return true; } return false; } bool DeleteQueue(LinkQueue *Q, int *x) { LinkQueueNode *p; if (Q-\u0026gt;front == Q-\u0026gt;rear) //空队  return false; p = Q-\u0026gt;front-\u0026gt;next; Q-\u0026gt;front-\u0026gt;next = p-\u0026gt;next; if (Q-\u0026gt;rear == p) Q-\u0026gt;rear = Q-\u0026gt;front; *x = p-\u0026gt;data; free(p); return true; }   队列的顺序存储（循环队列）  用一维数组Queue[MAXSIZE]存放从队头到队尾的元素 附设两个指针front和rear，分别指示队头元素和队尾元素在数组中的位置 由于只能在队头出队,在队尾入队，所以会产生假溢出的现象  信息  假溢出是指已经队满，但实际在队列的另一端还是有存储空间的情况。\n例如，当你想乘坐公交时，从上车车门处看见人满了，但从车窗看，发现里面还有空位，但车上的人不往里走，这就产生了所谓的假溢出现象\n   为解决假溢出，将顺序队列的数组Queue[MAXSIZE]看成一个环状的空间，即规定最后一个单元的后继为第一个单元，我们形象地称之为循环队列。\n可通过数学中的取模（求余）运算来实现循环队列rear = (rear+1) mod MAXSIZE。\n当rear+1 = MAXSIZE时，rear = O。也就是说最后一个Queue[MAXSIZE-1]的后继为Queue[0]\n 进队操作时，队尾指针的变化是rear = (rear+1) mod MAXSIZE 出队操作时，队头指针的变化是front = (front+1) mod MAXSIZE  在顺序队列中我们依靠front == rear来判断队列空，但不难看出，仅凭这一点难以判断循环队列的空满。在此，有两种解决办法：\n 损失一个元素空间，当队尾指针所指向的空单元的后继单元是队头元素所在的单元时，则停止入队。  队列满的条件为(rear+1) mod MAXSIZE == front 队列空的条件为rear == front   增设一个标志量，以区别队列是空，还是满  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  #define MAXSIZE 100  typedef struct { int front; int rear; int elem[MAXSIZE]; } SeqQueue; void InitQueue(SeqQueue *Q) { Q-\u0026gt;front = Q-\u0026gt;rear = 0; } bool EnterQueue(SeqQueue *Q,int x) { if ((Q-\u0026gt;rear + 1) % MAXSIZE == Q-\u0026gt;front) return false; Q-\u0026gt;elem[Q-\u0026gt;rear] = x; Q-\u0026gt;rear = (Q-\u0026gt;rear + 1) % MAXSIZE; return true; } bool DeleteQueue(SeqQueue *Q,int *x) { if(Q-\u0026gt;front==Q-\u0026gt;rear) return false; *x = Q-\u0026gt;elem[Q-\u0026gt;front]; Q-\u0026gt;front = (Q-\u0026gt;front + 1) % MAXSIZE; return true; }   问题  大小为 MAXSIZE 的循环队列中，f 为当前队头元素位置，为队尾元素的后一个位置，则任意时刻，队列中的元素个数为？   答案  要考虑到 r 和 f 谁更大的问题，因此要分类讨论。综合可得元素个数为 (r - f + MAXSIZE) % MAXSIZE   队列的应用 杨辉三角 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  void YangHuiTriangle(int N) { SeqQueue Q; int i, x, n, tmp; InitQueue(\u0026amp;Q); EnterQueue(\u0026amp;Q, 1); for (n = 2; n \u0026lt;= N; n++) { EnterQueue(\u0026amp;Q, 1); for (i = 1; i \u0026lt;= n - 2; i++) { DeleteQueue(\u0026amp;Q, \u0026amp;tmp); printf(\u0026#34; %d\u0026#34;, tmp); GetHead(Q, \u0026amp;x); tmp += x; EnterQueue(\u0026amp;Q, tmp); } DeleteQueue(\u0026amp;Q, \u0026amp;x); printf(\u0026#34; %d\u0026#34;, x); printf(\u0026#34;\\n\u0026#34;); EnterQueue(\u0026amp;Q, 1); } while (Q.front != Q.rear) { DeleteQueue(\u0026amp;Q, \u0026amp;x); printf(\u0026#34; %d\u0026#34;, x); } }   总结 堆栈和队列的异同 都是操作受限制的线性表，它们的共同点是操作的位置限制在表的端点。\n 堆栈具有 LIFO 的特性，限定元素的运算位置只在表尾（栈顶）端进行。 队列具有 FIFO 的特性。限定元素的运算位置分别在表的两端进行。  顺序和链式两种存储方式  顺序栈受到事先开辟的栈区容量限制，以避免上溢。 链栈方式下，只有当整个系统无法申请到可用空间时，才无法进栈。  队列操作也一样。\n例题 求最大公约数——非递归实现 1 2 3 4 5 6 7 8 9 10 11  int fun(int m, int n) { int r; do { r = m % n; m = n; n = r; } while (r); return m; }   ","permalink":"https://www.sukun.xyz/data_structure-3/","tags":["数据结构","学习"],"title":"数据结构学习(三)"},{"categories":["算法与数据结构"],"contents":"数据结构——用C语言描述(二) 线性结构 线性表 线性表定义 线性表（LinearList）：由 n 个类型相同数据元素的有限序列，记作 $$ (a_1,a_2,···,a_i,a_{i+1},···,a_n) $$ 称 n 为线性表长度，特别的，当 n = 0 时，称为空表。\n每个数据元素只有一个直接前驱和一个直接后继（首尾元素除外），即为一对一的线性关系。\n线性表特点：\n 同一性 有穷性 有序性  对于线性表 ADT：\n数据元素：同类型数据元素的集合 $$ D={ a_i|\\ a_i\\in D0,\\ i=1,2,…,n\\ n≥0 ，D0为某一数据对象} $$ 关系：有序对偶 $$ s={\u0026lt;a_i, a_{i+1}\u0026gt;|\\ a_i, a_{i+1}\\in D0,\\ i=1,2,…, n-1} $$ 有 9 种基本操作运算：\n 初始化InitList(L) 销毁DestroyList(L) 置空ClearList(L) 判空EmptyList(L) 求长度ListLength(L) 查找Locate(L, e) 存取GetData(L, i) 插入InsList(L, i, e) 删除DelList(L, i, \u0026amp;e)  线性表的顺序存储 1 2 3 4 5 6 7 8 9 10 11 12  #define MAXSIZE 100 //线性表数据类型定义 typedef struct { int elem[MAXSIZE]; //线性表占用的数组空间  int last; //线性表中最后一个元素在数组中的位置下标 } SeqList; /* 两种变量定义方式 SeqList L1 使用L1.elem[i-1]访问 SeqList *L2 使用L2-\u0026gt;elem[i-1]访问 */   查找操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  //按内容查找 int Locate(SeqList L, int e) { int i = 0; while ((i \u0026lt;= L.last) \u0026amp;\u0026amp; (L.elem[i] != 0)) i++; if (i \u0026lt;= L.last) retrun i + 1; //若找到值为e的元素，则返回其序号  else return -1; //若没找到，返回空序号 } //按序号查找 int GetData(SeqList L, int i) { if (i \u0026lt;= L.last) return L.elem[i - 1]; else { printf(\u0026#34;序号超过上限\u0026#34;); return 0; } }   插入操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  //在表的第i个位置之前插入一个新元素e int InsList(SeqList *L, int i, int e) { int k; if ((i \u0026lt; 1) || (i \u0026gt; L-\u0026gt;last + 2)) { printf(\u0026#34;插入位置i值不合法\u0026#34;); return 0; } if (L-\u0026gt;last \u0026gt;= MAXSIZE - 1) { printf(\u0026#34;表已满无法插入\u0026#34;); return 0; } for (k = L-\u0026gt;last; k \u0026gt;= i - 1; k--) L-\u0026gt;elem[k + 1] = L-\u0026gt;elem[k]; L-\u0026gt;elem[i - 1] = e; L-\u0026gt;last++; return 1; }   删除操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  //将表的第i个元素删去 int DelList(SeqList *L, int i, int *e) { int k; if ((i \u0026lt; 1) || (i \u0026gt; L-\u0026gt;last + 1)) { printf(\u0026#34;删除位置不合法！\u0026#34;); return 0; } *e = L-\u0026gt;elem[i - 1]; for (k = i; k \u0026lt;= L-\u0026gt;last; k++) L-\u0026gt;elem[k - 1] = L-\u0026gt;elem[k]; L-\u0026gt;last--; return 1; }   顺序表合并算法 有两个顺序表 LA 和 LB，其元素均为递增有序排列，编写算法，将两个有序表合并成一个递增有序的顺序表 LC。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  void merg(SeqList *LA, SeqList *LB, SeqList *LC) { int i, j, k; i = 0; j = 0; k = 0; while (i \u0026lt;= LA-\u0026gt;last \u0026amp;\u0026amp; j \u0026lt;= LB-\u0026gt;last) if (LA-\u0026gt;elem[i] \u0026lt;= LB-\u0026gt;elem[j]) { LC-\u0026gt;elem[k] = LA-\u0026gt;elem[i]; i++; k++; } else { LC-\u0026gt;elem[k] = LB-\u0026gt;elem[j]; j++; k++; } while (i \u0026lt;= LA-\u0026gt;last) //表A长于表B  { LC-\u0026gt;elem[k] = LA-\u0026gt;elem[i]; i++; k++; } while (j \u0026lt;= LB-\u0026gt;last) //表B长于表A  { LC-\u0026gt;elem[k] = LB-\u0026gt;elem[j]; j++; k++; } LC-\u0026gt;last = LA-\u0026gt;last + LB-\u0026gt;last + 1; }   比较循环的时间复杂度为 $$ O(LA-\u0026gt;last+LB-\u0026gt;last) $$ 复制循环时间复杂度为 $$ O(max(LA-\u0026gt;last,LB-\u0026gt;last)) $$\n顺序表优缺点总结  优点  无需为表示结点间的逻辑关系而增加额外的存储空间 可方便地随机存取查找表中的任一元素   缺点  大量插入删除时效率低，除表尾位置外，在其它位置插入删除都必须移动大量元素（平均移动次数为表长度一半） 由于顺序表要求占用连续的存储空间,存储分配只能预先进行静态分配。因此当表长变化较大时，难以确定合适的存储规模。    总结：便于随机存取，不适合动态变化\n线性表的链式存储 单链表 1 2 3 4 5 6  typedef struct { int data; struct Node *next; } Node, *LinkList; LinkList L;   求长度 1 2 3 4 5 6 7 8 9 10 11 12 13  int ListLength(LinkList L) { Node *p; int j; p = L-\u0026gt;next; j = 0; while (p != NULL) { p = p-\u0026gt;next; j++; } return j; }   建立空表 1 2 3 4 5  void InitList(LinkList *L) { *L = (LinkList)malloc(sizeof(Node)); (*L)-\u0026gt;next = NULL; }   建表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  /* 头插法建表eg: 输入：123$ 链表：321 */ LinkList CreateFromHead(LinkList L) { Node *s; char c; int flag = 1; while (flag) { c = getchar(); if (c != \u0026#39;$\u0026#39;) { s = (Node *)malloc(sizeof(Node)); s-\u0026gt;data = c; s-\u0026gt;next = L-\u0026gt;next; L-\u0026gt;next = s; } else flag = 0; } } /* 尾插法建表eg: 输入：123$ 链表：123 */ LinkList CreateFromTail(LinkList L) { Node *r, *s; char c; int flag = 1; r = L; while (flag) { c = getchar(); if (c != \u0026#39;$\u0026#39;) { s = (Node *)malloc(sizeof(Node)); s-\u0026gt;data = c; r-\u0026gt;next = s; r = s; } else { flag = 0; r-\u0026gt;next = NULL; } } }   查找 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  //按序号查找（第i个） Node *Get(LinkList L, int i) { int j; Node *p; p = L; j = 0; while ((p-\u0026gt;next != NULL) \u0026amp;\u0026amp; (j \u0026lt; i)) { p = p-\u0026gt;next; j++; } if (i == j) return p; else return NULL; } //按值查找 Node *Locate(LinkList L, int key) { Node *p; p = L-\u0026gt;next; while (p != NULL) if (p-\u0026gt;data != key) p = p-\u0026gt;next; else break; return p; }   前插 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  int InsList(LinkList L, int i, int e) { Node *pre, *s; int k; pre = L; k = 0; while (pre != NULL \u0026amp;\u0026amp; k \u0026lt; i - 1) { pre = pre-\u0026gt;next; k++; } if (!pre) { printf(\u0026#34;插入位置不合理！\u0026#34;); return 0; } s = (Node *)malloc(sizeof(Node)); s-\u0026gt;data = e; s-\u0026gt;next = pre-\u0026gt;next; pre-\u0026gt;next = s; return 1; }   删除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  void DelList(LinkList L, int i, int *e) { Node *p, *r; int k; p = L; k = 0; while (p-\u0026gt;next != NULL \u0026amp;\u0026amp; k \u0026lt; i - 1) { p = p-\u0026gt;next; k++; } if (k != i - 1) { printf(\u0026#34;删除结点的位置i不合理！\u0026#34;); return; } r = p-\u0026gt;next; p-\u0026gt;next = r-\u0026gt;next; *e = r-\u0026gt;data; free(r); }   示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; typedef struct { int data; struct Node *next; } Node, *LinkList; int ListLength(LinkList L) { Node *p; int j; p = L-\u0026gt;next; j = 0; while (p != NULL) { p = p-\u0026gt;next; j++; } return j; } void InitList(LinkList *L) { *L = (LinkList)malloc(sizeof(Node)); (*L)-\u0026gt;next = NULL; } LinkList CreateFromHead(LinkList L) { Node *s; char c; int flag = 1; while (flag) { c = getchar(); if (c != \u0026#39;$\u0026#39;) { s = (Node *)malloc(sizeof(Node)); s-\u0026gt;data = c; s-\u0026gt;next = L-\u0026gt;next; L-\u0026gt;next = s; } else flag = 0; } } LinkList CreateFromTail(LinkList L) { Node *r, *s; char c; int flag = 1; r = L; while (flag) { c = getchar(); if (c != \u0026#39;$\u0026#39;) { s = (Node *)malloc(sizeof(Node)); s-\u0026gt;data = c; r-\u0026gt;next = s; r = s; } else { flag = 0; r-\u0026gt;next = NULL; } } } Node *Get(LinkList L, int i) { int j; Node *p; p = L; j = 0; while ((p-\u0026gt;next != NULL) \u0026amp;\u0026amp; (j \u0026lt; i)) { p = p-\u0026gt;next; j++; } if (i == j) return p; else return NULL; } Node *Locate(LinkList L, int key) { Node *p; p = L-\u0026gt;next; while (p != NULL) if (p-\u0026gt;data != key) p = p-\u0026gt;next; else break; return p; } int InsList(LinkList L, int i, int e) { Node *pre, *s; int k; pre = L; k = 0; while (pre != NULL \u0026amp;\u0026amp; k \u0026lt; i - 1) { pre = pre-\u0026gt;next; k++; } if (!pre) { printf(\u0026#34;插入位置不合理！\u0026#34;); return 0; } s = (Node *)malloc(sizeof(Node)); s-\u0026gt;data = e; s-\u0026gt;next = pre-\u0026gt;next; pre-\u0026gt;next = s; return 1; } void DelList(LinkList L, int i, int *e) { Node *p, *r; int k; p = L; k = 0; while (p-\u0026gt;next != NULL \u0026amp;\u0026amp; k \u0026lt; i - 1) { p = p-\u0026gt;next; k++; } if (k != i - 1) { printf(\u0026#34;删除结点的位置i不合理！\u0026#34;); return; } r = p-\u0026gt;next; p-\u0026gt;next = r-\u0026gt;next; *e = r-\u0026gt;data; free(r); } void Difference(LinkList LA, LinkList LB) { Node *pre, *p, *q, *r; pre = LA; p = LA-\u0026gt;next; while (p != NULL) { q = LB-\u0026gt;next; while (q != NULL \u0026amp;\u0026amp; q-\u0026gt;data != p-\u0026gt;data) q = q-\u0026gt;next; if (q != NULL) { r = p; pre-\u0026gt;next = p-\u0026gt;next; p = p-\u0026gt;next; free(r); } else { pre = p; p = p-\u0026gt;next; } } } int main() { LinkList L, p; int del; int length; InitList(\u0026amp;L); CreateFromHead(L); length = ListLength(L); printf(\u0026#34;第一次的长度:%d\\t\u0026#34;, length); p = Get(L, 1); printf(\u0026#34;第一个元素值:%c\\n\u0026#34;, p-\u0026gt;data); if (InsList(L, 1, \u0026#39;0\u0026#39;)) { length = ListLength(L); printf(\u0026#34;第二次的长度:%d\\t\u0026#34;, length); p = Get(L, 1); printf(\u0026#34;第一个元素值:%c\\n\u0026#34;, p-\u0026gt;data); } DelList(L, 1, \u0026amp;del); length = ListLength(L); printf(\u0026#34;第三次的长度:%d\\t\u0026#34;, length); printf(\u0026#34;被删除元素值:%c\\n\u0026#34;, del); return 0; } /* 输入： 54321$ 输出： 第一次的长度:5\t第一个元素值:1 第二次的长度:6\t第一个元素值:0 第三次的长度:5\t被删除元素值:0 */   就地逆置算法 1 2 3 4 5 6 7 8 9 10 11 12 13  void ReverseList(LinkList L) { LinkList p, q; p = L-\u0026gt;next; L-\u0026gt;next = NULL; while (p != NULL) { q = p-\u0026gt;next; p-\u0026gt;next = L-\u0026gt;next; L-\u0026gt;next = p; p = q; } }   应用实例——求集合差 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  void Difference(LinkList LA, LinkList LB) { Node *pre, *p, *q, *r; pre = LA; p = LA-\u0026gt;next; while (p != NULL) { q = LB-\u0026gt;next; while (q != NULL \u0026amp;\u0026amp; q-\u0026gt;data != p-\u0026gt;data) q = q-\u0026gt;next; if (q != NULL) { r = p; pre-\u0026gt;next = p-\u0026gt;next; p = p-\u0026gt;next; free(r); } else { pre = p; p = p-\u0026gt;next; } } }   单链表总结   访问单链表 L 中某结点第 i 结点或值为 e 结点时，必须从头开始。\n  表尾控制条件：当前结点p-\u0026gt;next == NULL\n  在处理过程中始终需要维持当前指针p与前驱指针pre的关系。\n  循环链表 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; typedef struct { int data; struct Node *next; } Node, *LinkList; void InitList(LinkList *L) { *L = (LinkList *)malloc(sizeof(Node)); (*L)-\u0026gt;next = *L; } int main() { LinkList L, p; int i; InitList(\u0026amp;L); for (i = 1; i \u0026lt;= 3; i++) { p = (Node *)malloc(sizeof(Node)); p-\u0026gt;data = i; p-\u0026gt;next = L-\u0026gt;next; L-\u0026gt;next = p; } p = L-\u0026gt;next; for (i = 1; i \u0026lt;= 6; i++) { printf(\u0026#34;%d\\t\u0026#34;, p-\u0026gt;data); if (p-\u0026gt;next == L) { printf(\u0026#34;已到达表尾\\n\u0026#34;); p = p-\u0026gt;next; } p = p-\u0026gt;next; } return 0; } /* 输出： 3\t2\t1\t已到达表尾 3\t2\t1\t已到达表尾 */   循环单链表的合并算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  //采用头指针 LinkList merge_1(LinkList LA, LinkList LB) { Node *p, *q; p = LA; q = LB; while (p-\u0026gt;next != LA) p = p-\u0026gt;next; while (q-\u0026gt;next != LB) q = q-\u0026gt;next; q-\u0026gt;next = LA; p-\u0026gt;next = LB-\u0026gt;next; free(LB); return LA; } //采用尾指针 LinkList merge_2(LinkList RA, LinkList RB) { Node *p, *tmp; p = RA-\u0026gt;next; tmp = RB-\u0026gt;next; RA-\u0026gt;next = tmp-\u0026gt;next; free(RB-\u0026gt;next); RB-\u0026gt;next = p; return RB; }   循环单链表总结  特点：首尾相接，可从当前结点遍历所有结点 空表判断条件：L-\u0026gt;next == L 表尾控制条件：当前结点p-\u0026gt;next == L  双向链表 1 2 3 4 5  typedef struct DNode { int data; struct DNode *prior, *next; } DNode, *DoubleList;   前插操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  int DlinkIns(DoubleList L, int i, int e) { DNode *s, *p; int k; p = L; k = 0; while (p != NULL \u0026amp;\u0026amp; k \u0026lt; i - 1) { p = p-\u0026gt;next; k++; } if (!p) { printf(\u0026#34;插入位置不合理！\u0026#34;); return 0; } s = (DNode *)malloc(sizeof(DNode)); if (s) { s-\u0026gt;data = e; s-\u0026gt;prior = p-\u0026gt;prior; p-\u0026gt;prior-\u0026gt;next = s; s-\u0026gt;next = p; p-\u0026gt;prior = s; return 1; } else return 0; }   删除操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  int DlinkDel(DoubleList L, int i, int *e) { DNode *p; int k; p = L; k = 0; while (p-\u0026gt;next != NULL \u0026amp;\u0026amp; k \u0026lt; i - 1) { p = p-\u0026gt;next; k++; } if (k != i - 1) { printf(\u0026#34;删除结点的位置i不合理！\u0026#34;); return 0; } *e = p-\u0026gt;data; p-\u0026gt;prior-\u0026gt;next = p-\u0026gt;next; p-\u0026gt;next-\u0026gt;prior = p-\u0026gt;prior; free(p); return 1; }   循环双向链表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; typedef struct DNode { int data; struct DNode *prior, *next; } DNode, *DoubleList; void DlinkInit(DoubleList *L) { *L = (DoubleList *)malloc(sizeof(DNode)); (*L)-\u0026gt;prior = (*L)-\u0026gt;next = *L; } int main() { DoubleList L, p, r; int i; DlinkInit(\u0026amp;L); r = L; for (i = 1; i \u0026lt;= 3; i++) { p = (DNode *)malloc(sizeof(DNode)); p-\u0026gt;data = i; r-\u0026gt;next-\u0026gt;prior = p; p-\u0026gt;next = r-\u0026gt;next; r-\u0026gt;next = p; p-\u0026gt;prior = r; } while (p-\u0026gt;next != L) { printf(\u0026#34;%d\\t\u0026#34;, p-\u0026gt;data); p = p-\u0026gt;next; } printf(\u0026#34;%d\\t已到表尾\\n\u0026#34;, p-\u0026gt;data); while (p-\u0026gt;prior != L) { printf(\u0026#34;%d\\t\u0026#34;, p-\u0026gt;data); p = p-\u0026gt;prior; } printf(\u0026#34;%d\\t已到表头\\n\u0026#34;, p-\u0026gt;data); return 0; } /* 输出： 3\t2\t1\t已到表尾 1\t2\t3\t已到表头 */   双向链表总结  双向链表可从两个方向访问任一结点，快速，方便。 可以推广至多重链表，其本质上是用空间换时间。  静态链表 由于有些语言并未提供指针类型，我们可以采用数组模拟实现链表，静态模拟动态。\n1 2 3 4 5 6  #define MAXSIZE 100 typedef struct { int data; int cursor; }Component,StaticList[MAXSIZE];   初始化 1 2 3 4 5 6 7 8  void initial(StaticList space, int *av) { space[0].cursor = -1; for (int k = 1; k \u0026lt; MAXSIZE - 1; k++) space[k].cursor = k + 1; space[MAXSIZE].cursor = -1; *av = 1; }   分配结点 1 2 3 4 5 6 7 8  //从备用链表中分配结点给使用者 int getnode(StaticList space, int *av) { int i; i = *av; *av = space[*av].cursor; return i; }   回收结点 1 2 3 4 5 6  //备用链表回收空闲结点 void freenode(StaticList space, int *av, int k) { space[k].cursor = *av; *av = k; }   线性表的链式存储总结   存储结构：用一组任意配置的单元存储，用指针维持结点线性关系\n  类型：\n  动态链表\n单链表，双向链表，多重链表，循环链表\n  静态链表\n    特点：适合动态变化长度操作，需有存储指针附加代价\n  线性表应用——一元多项式表示及相加 一元多项式数学表示： $$ P_n(x)=p_0+p_1x^{e_1}+p2x^{e_2}+…+p_nx^{e_n} $$ 其用线性表表示： $$ P=(p_0,p_1,p_2,…,p_n) $$ 两个一元多项式的相加：(设m\u0026lt;n) $$ P_n(x)+Q_m(x)=R_n(x) $$\n$$ R=(p_0+q_0,p_1+q_1,p_2+q_2,…,p_m+q_m,p_{m+1},…,p_n) $$\n链式存储 只存储非零系数项和指数项。\n所有指数相同的项的对应系数相加，若和不为零则构成“和多项式”中的一项，所有指数不相同的项均按升幂复抄到“和多项式”中。\n完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; typedef struct Polynode { int coef; //系数  int exp; //指数  struct Polynode *next; } Polynode, *Polylist; Polylist PolyCreate(); Polylist AscSort(Polylist L); Polylist PolyAdd(Polylist LA, Polylist LB); void PolyPrint(Polylist L); int main() { Polylist LA, LB, LC; LA = AscSort(PolyCreate()); printf(\u0026#34;f(x)_A=\u0026#34;); PolyPrint(LA); LB = AscSort(PolyCreate()); printf(\u0026#34;f(x)_B=\u0026#34;); PolyPrint(LB); LC = PolyAdd(LA, LB); printf(\u0026#34;f(x)_C=f(x)_A+f(x)_B=\u0026#34;); PolyPrint(LC); return 0; } Polylist PolyCreate() { Polynode *head, *rear, *s; int c, e; head = (Polynode *)malloc(sizeof(Polynode)); rear = head; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;c, \u0026amp;e); while (c != 0) { s = (Polynode *)malloc(sizeof(Polynode)); s-\u0026gt;coef = c; s-\u0026gt;exp = e; rear-\u0026gt;next = s; rear = s; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;c, \u0026amp;e); } rear-\u0026gt;next = NULL; return head; } Polylist AscSort(Polylist L) { Polynode *p, *q; int ctmp, etmp; for (p = L-\u0026gt;next; p != NULL; p = p-\u0026gt;next) for (q = p-\u0026gt;next; q != NULL; q = q-\u0026gt;next) if (p-\u0026gt;exp \u0026gt; q-\u0026gt;exp) { etmp = p-\u0026gt;exp; p-\u0026gt;exp = q-\u0026gt;exp; q-\u0026gt;exp = etmp; ctmp = p-\u0026gt;coef; p-\u0026gt;coef = q-\u0026gt;coef; q-\u0026gt;coef = ctmp; } else if (p-\u0026gt;exp == q-\u0026gt;exp) { p-\u0026gt;coef = p-\u0026gt;coef + q-\u0026gt;coef; p-\u0026gt;next = q-\u0026gt;next; } return L; } Polylist PolyAdd(Polylist LA, Polylist LB) { Polynode *a, *b, *p; a = LA-\u0026gt;next; b = LB-\u0026gt;next; p = LA; while (a != NULL \u0026amp;\u0026amp; b != NULL) { if (a-\u0026gt;exp == b-\u0026gt;exp) { a-\u0026gt;coef = a-\u0026gt;coef + b-\u0026gt;coef; p-\u0026gt;next = a; p = p-\u0026gt;next; a = a-\u0026gt;next; b = b-\u0026gt;next; } else if (a-\u0026gt;exp \u0026lt; b-\u0026gt;exp) { p-\u0026gt;next = a; p = p-\u0026gt;next; a = a-\u0026gt;next; } else { p-\u0026gt;next = b; p = p-\u0026gt;next; b = b-\u0026gt;next; } } if (a != NULL) p-\u0026gt;next = a; else p-\u0026gt;next = b; return LA; } void PolyPrint(Polylist L) { Polynode *p; p = L-\u0026gt;next; while (p != NULL) { if (p-\u0026gt;coef \u0026gt; 0 \u0026amp;\u0026amp; p-\u0026gt;exp == 0 \u0026amp;\u0026amp; p == L-\u0026gt;next) //系数大于0，指数0，首项  printf(\u0026#34;%d\u0026#34;, p-\u0026gt;coef); else if (p-\u0026gt;coef \u0026gt; 0 \u0026amp;\u0026amp; p-\u0026gt;exp == 0 \u0026amp;\u0026amp; p != L-\u0026gt;next) //系数大于0，指数0，非首项  printf(\u0026#34;+%d\u0026#34;, p-\u0026gt;coef); else if (p-\u0026gt;coef \u0026lt; 0 \u0026amp;\u0026amp; p-\u0026gt;exp == 0) //系数小于0，指数0  printf(\u0026#34;%d\u0026#34;, p-\u0026gt;coef); else if (p-\u0026gt;coef == 1 \u0026amp;\u0026amp; p-\u0026gt;exp == 1 \u0026amp;\u0026amp; p == L-\u0026gt;next) //系数1,指数为1，首项  printf(\u0026#34;x\u0026#34;); else if (p-\u0026gt;coef == 1 \u0026amp;\u0026amp; p-\u0026gt;exp == 1 \u0026amp;\u0026amp; p != L-\u0026gt;next) //系数1,指数为1，非首项  printf(\u0026#34;+x\u0026#34;); else if (p-\u0026gt;coef == 1 \u0026amp;\u0026amp; p-\u0026gt;exp != 0 \u0026amp;\u0026amp; p-\u0026gt;exp != 1 \u0026amp;\u0026amp; p == L-\u0026gt;next) //系数1，指数非0非1，首项  printf(\u0026#34;x^%d\u0026#34;, p-\u0026gt;exp); else if (p-\u0026gt;coef == 1 \u0026amp;\u0026amp; p-\u0026gt;exp != 0 \u0026amp;\u0026amp; p-\u0026gt;exp != 1 \u0026amp;\u0026amp; p != L-\u0026gt;next) //系数1，指数非0非1，非首项  printf(\u0026#34;+x^%d\u0026#34;, p-\u0026gt;exp); else if (p-\u0026gt;coef == -1 \u0026amp;\u0026amp; p-\u0026gt;exp == 1) //系数-1,指数1  printf(\u0026#34;-x\u0026#34;); else if (p-\u0026gt;coef == -1 \u0026amp;\u0026amp; p-\u0026gt;exp != 0 \u0026amp;\u0026amp; p-\u0026gt;exp != 1) //系数-1，指数非0非1  printf(\u0026#34;-x^%d\u0026#34;, p-\u0026gt;exp); else if (p-\u0026gt;coef \u0026gt; 0 \u0026amp;\u0026amp; p-\u0026gt;exp == 1 \u0026amp;\u0026amp; p == L-\u0026gt;next) //系数大于0，指数1，首项  printf(\u0026#34;%dx\u0026#34;, p-\u0026gt;coef); else if (p-\u0026gt;coef \u0026gt; 0 \u0026amp;\u0026amp; p-\u0026gt;exp == 1 \u0026amp;\u0026amp; p != L-\u0026gt;next) //系数大于0，指数1，非首项  printf(\u0026#34;+%dx\u0026#34;, p-\u0026gt;coef); else if (p-\u0026gt;coef \u0026lt; 0 \u0026amp;\u0026amp; p-\u0026gt;exp == 1) //系数小于0，指数1  printf(\u0026#34;%dx\u0026#34;, p-\u0026gt;coef); else if (p-\u0026gt;coef \u0026gt; 0 \u0026amp;\u0026amp; p-\u0026gt;exp != 0 \u0026amp;\u0026amp; p-\u0026gt;exp != 1 \u0026amp;\u0026amp; p == L-\u0026gt;next) //系数大于0,指数非0非1，首项  printf(\u0026#34;%dx^%d\u0026#34;, p-\u0026gt;coef, p-\u0026gt;exp); else if (p-\u0026gt;coef \u0026gt; 0 \u0026amp;\u0026amp; p-\u0026gt;exp != 0 \u0026amp;\u0026amp; p-\u0026gt;exp != 1 \u0026amp;\u0026amp; p != L-\u0026gt;next) //系数大于0,指数非0非1，非首项  printf(\u0026#34;+%dx^%d\u0026#34;, p-\u0026gt;coef, p-\u0026gt;exp); else if (p-\u0026gt;coef \u0026lt; 0 \u0026amp;\u0026amp; p-\u0026gt;exp != 0 \u0026amp;\u0026amp; p-\u0026gt;exp != 1) //系数小于0,指数非0非1  printf(\u0026#34;%dx^%d\u0026#34;, p-\u0026gt;coef, p-\u0026gt;exp); p = p-\u0026gt;next; } printf(\u0026#34;\\n\u0026#34;); }   运行截图：\n顺序表与链表的综合比较 基于空间的考虑  顺序表存储是静态分配，程序执行前须定义存储规模。 静态链表是静态分配，同时存在若干个结点类型相同的链表，可共享空间。 动态链表存储是动态分配，只要内存空间尚有空闲就不会产生溢出。  顺序表虽然存储密度更高，但灵活度不够。\n信息  存储密度，指结点数据本身所占的存储量和整个结点结构所占的存储量之比。顺序表存储密度为1，而链表小于1   当线性表的长度变化较大，难以估计其存储规模时，采用动态链表作为存储结构较好。\n基于时间的考虑 顺序表是一种随机存储结构，适合大量元素的查找。\n链表的插入删除只用修改挂链，不需要移动元素，所以适合动态变化。\n若表的插入和删除主要发生在表的首尾两端，则宜采用尾指针表示的单循环链表。\n基于语言的考虑 有些语言提供指针类型，因此可以用链表形式。有些语言不提供指针类型，只能用静态链表来模拟，静态链表在存储分配上有所不足，但也能像动态链表一样灵活插入和删除。\n存储方式比较    操作名称/链表名称 找首元素结点 找表尾结点 找Р结点前驱结点     带头结点单链表 L L-\u0026gt;next，时间耗费 O(1) ―重循环，时间耗费 O(n) 顺 Р 结点的 next 域无法找到 P 结点的前驱   带头结点循环单链表（头指针）L L-\u0026gt;next，时间耗费 O(1) ―重循环，时间耗费 O(n) 顺 Р 结点的 next 域可以找到 P 结点的前驱，时间耗费 O(n)   带尾指针的循环单链表 R R-\u0026gt;next，时间耗费 O(1) R，时间耗费 O(1) 顺 Р 结点的 next 域可以找到 P 结点的前驱，时间耗费 O(n)   带头结点双向循环链表 L L-\u0026gt;next，时间耗费 O(1) L-\u0026gt;prior，时间耗费 O(1) P-\u0026gt;prior，时间耗费 O(1)    线性表例题 顺序表分奇偶 已知顺序表 L 中的数据元素类型为 int。设计算法将其调整为左右两部分，左边的元素（即排在前面的）均为奇数，右边所有元素（即排在后面的）均为偶数，并要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)\n1 2 3 4 5 6  #define MAXSIZE 100 typedef struct { int elem[MAXSIZE]; int last; } SeqList;   WP：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  AdjustSeqlist(SeqList *L) { int i, j, tmp; i = 0; j = L-\u0026gt;last; while (i \u0026lt; j) { while (L-\u0026gt;elem[i] % 2 != 0) i++; while (L-\u0026gt;elem[j] % 2 == 0) j--; if (i \u0026lt; j) { tmp = L-\u0026gt;elem[i]; L-\u0026gt;elem[i] = L-\u0026gt;elem[j]; L-\u0026gt;elem[j] = tmp; } } }   二进制数加一运算 建立了一个带头结点的线性链表，用以存放输入的二进制数，链表中每个结点的 data 域存放一个二进制位。并在此链表上实现对二进制数加1的运算。\n1 2 3 4 5  typedef struct { int data; struct Node *next; } Node, *LinkList;   WP：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  void BinAdd(LinkList L) { Node *q, *r, *tmp, *s; q = L-\u0026gt;next; r = L; while (q != NULL) //找到最后一个值域0的结点，将值赋为1  { if (q-\u0026gt;data == 0) r = q; q = q-\u0026gt;next; } if (r != L) r-\u0026gt;data = 1; else { tmp = r-\u0026gt;next; s = (Node *)malloc(sizeof(Node)); s-\u0026gt;data = 1; //头插  s-\u0026gt;next = tmp; r-\u0026gt;next = s; r = s; } r = r-\u0026gt;next; while (r != NULL) //进位结点后的结点值域置0  { r-\u0026gt;data = 0; r = r-\u0026gt;next; } }   ","permalink":"https://www.sukun.xyz/data_structure-2/","tags":["数据结构","学习"],"title":"数据结构学习(二)"},{"categories":["算法与数据结构"],"contents":"数据结构——用C语言描述(一) 数据结构绪论 数据结构基础概念   数据（Data）：描述客观事物的数值、字符，能被机器输入且处理的的各种符号的集合。\n  数据元素（Data Element）：组成数据的基本单位，是数据集合的个体。一条记录就是一个数据元素。\n  数据对象（Data Object）：性质相同的数据元素的集合，是数据的一个子集。\n  数据结构（Data Structure）：指相互之间存在一种或多种特定关系的数据元素集合。即数据元素之间的相互关系，即数据的组织形式。一句话总结：带有结构的数据元素的集合。\n  数据类型（Data Type）：一组性质相同的值集合以及定义在这个值集合上的一组操作的总称。即值域、定义域及运算集合。\n  抽象数据类型（Abstract Data Type）：定义了一个数据对象，数据对象中各元素之间的结构关系，以及一组处理数据的操作。包括定义和实现两方面，其中定义是独立于实现的。\nADT 三要素：\n 数据元素 数据关系 数据操作    数据结构内容   逻辑结构：数据元素之间逻辑关系描述。\n四种基本数据逻辑结构表现为四种数据元素关系：\n 集合结构：属于关系 线性结构：一对一的线性关系 树形结构：一对多的层次关系 图形结构：多对多的任意关系    存储结构（物理结构）：逻辑结构在计算机中存储映像，是逻辑结构在计算机中的实现。包括数据元素的表示和关系的表示。\n数据元素之间关系在计算机中表示方法：\n 顺序映像，一组连续单元，如数组。 非顺序映像，一组任意存储单元，如链表。    运算集合\n  算法与算法描述  算法（algorithm）定义：规则的有限集合，是为解决特定问题而规定一系列操作。 算法特性：  有限性：有限步骤 确定性：无二义性 输入：有多个或0个输入 输出：至少有一个输出 可行性：原则上能精确进行，操作可通过已实现的基本运算执行有限次而完成   算法设计要求：  正确性 可读性 健壮性（鲁棒性）：对非法输入的抵抗能力 高效率与低存储量   算法描述：自然语言、框图、高级语言  算法性能评价   性能评价：问题规模 N 的函数\n  数量关系评价：时间和空间\n  算法执行时间：本质是语句执行次数的比较\n  语句频度：该语句在一个算法中的重复执行的次数\n  算法的时间复杂度: $$ T(n)=O(f(n)) $$ 例如：\n1 2 3  for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; n; j++) x++;   这样的一段代码其时间复杂度为 $$ o(n^2) $$ 再例如，下方有一个算法的执行时间 $$ f(n)=2n^3+2n^2+n $$ 其时间复杂度为 $$ o(n^3) $$ 但这样一个算法只是理论上可行，但实际上不可行，因为其执行次数上升太快，程序无法实现。\n  最坏时间复杂度：算法在最坏情况下基本操作执行时间的上界。\n例如，冒泡排序算法最坏时间复杂度为 $$ o(n^2) $$ 而其最好时间复杂度为 $$ o(n) $$\n  算法空间复杂度：以存储单元个数刻画随问题规模增加的函数 f(n)，是考虑程序运行时占用内存的大小，记作 $$ S(n)=O(f(n)) $$\n   ","permalink":"https://www.sukun.xyz/data_structure-1/","tags":["数据结构","学习"],"title":"数据结构学习(一)"},{"categories":["计算机网络"],"contents":"全双工、半双工、单工 定义 为了便于理解，这里打个比方，全双工就是双向两车道，半双工就是双向单车道，而单工则是单行路。\n全双工 全双工（Full Duplex）是通讯传输的一个术语。通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。全双工指可以同时（瞬时）进行信号的双向传输（A→B且B→A）。指A→B的同时B→A，是瞬时同步的。\n半双工 半双工(Half Duplex)数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输。例如，在一个局域网上使用具有半双工传输的技术，一个工作站可以在线上发送数据，然后立即在线上接收数据，这些数据来自数据刚刚传输的方向。像全双工传输一样，半双工包含一个双向线路（线路可以在两个方向上传递数据）。\n单工 单工（Simplex Communication）模式的数据传输是单向的。通信双方中，一方固定为发送端，一方则固定为接收端。信息只能沿一个方向传输，使用一根传输线。移动通信按照用户的通话状态和频率使用的方法，可分为三种工作方式：单工制、半双工制和双工制。\n","permalink":"https://www.sukun.xyz/%E5%85%A8%E5%8F%8C%E5%B7%A5%E5%8D%8A%E5%8F%8C%E5%B7%A5%E4%B8%8E%E5%8D%95%E5%B7%A5/","tags":["计算机网络"],"title":"全双工，半双工与单工"},{"categories":["计算机网络"],"contents":"Socket网络编程详解 Socket简介 上图表示的是国际标准化组织(ISO)的计算机通信开放系统互连(OSI)模型；\n1、2层随系统提供的设备驱动和网络硬件实现，一般不必关心，网络层 IPv4 或者 IPv6，传输层可以选择 TCP 或者 UDP，OSI 上面的 3 层合并为一层应用层，我们使用的套接口就是应用层到传输层的接口，主要介绍如何使用套接口编写使用 TCP 或者 UDP 的网络应用程序，其实可以绕过传输层，应用直接使用 IPv4 或者 IPv6，称为原始套接口(raw socket);\n上三层（应用层）处理应用程序（如FTP、telnet、HTTP）的细节，不知道通信细节；下四层则不知道应用程序，但能处理所有的通信细节，发送数据、等待确认、给无序到达的数据排序、计算与验证校验和等等；\n上三层通常形成用户进程，而下四层通常作为操作系统内核的一部分。\nUDP 是英文 UserDatagramProtocol 的缩写，即用户数据报协议，主要用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用 UDP 协议。UDP 协议从问世至今已经被使用了很多年，虽然其最初的光彩已经被一些类似协议所掩盖，但是即使是在今天，UDP 仍然不失为一项非常实用和可行的网络传输层协议。\nUDP 和 TCP 的主要区别是两者在如何实现信息的可靠传递方面不同。TCP 中包含了专门的传递保证机制，当数据接收方收到发送方传来的信息时，会自动向发送方发出确认消息；发送方只有在接收到该确认消息之后才继续传送其它信息，否则将一直等待直到收到确认信息为止。\nUDP 并不提供数据传送的保证机制。如果在从发送方到接收方的传递过程中出现数据报的丢失，协议本身并不能做出任何检测或提示。因此，通常人们把 UDP 协议称为不可靠的传输协议。\n相对于 TCP，UDP 的另外一个不同之处在于如何接收突法性的多个数据报。不同于 TCP，UDP 并不能确保数据的发送和接收顺序，事实上，UDP 协议的这种乱序性基本上很少出现，通常只会在网络非常拥挤的情况下才有可能发生 。\nUDP 具有 TCP 所望尘莫及的速度优势 ，TCP 中植入了各种安全保障功能，在实际执行的过程中会占用大量的系统开销，无疑使速度受到严重的影响。UDP 由于排除了信息可靠传递机制，将安全和排序等功能移交给上层应用来完成，极大降低了执行时间，使速度得到了保证。\n只有理解了某些特性，才能更容易的编写更健壮的客户、服务器程序，netstat 工具是调试客户、服务程序最好的工具，tcp 的三路握手、tcp 的连接终止序列、tcp 的 time_wait 状态、套接口的缓冲机制等。\n总结：UDP是一种简单的、不可靠的数据报协议；TCP是一种精致的、可靠的字节流协议\nTCP通信 TCP简介  TCP 提供客户与服务器的连接； TCP 提供可靠性； TCP 通过给所发送数据的字节关联一个序号进行排序； TCP 提供流量控制； TCP 的连接是全双工的。（全双工？半双工？单工？）  一个TCP客户建立与一个给定的服务器的连接，跨越连接与那个服务器交换数据，然后终止连接；\n当TCP向另一端发送数据时，它要求对方返回一个确认。如果没有收到确认，自动重传数据并等待更长时间，在数次重传失败后才放弃；\nTCP总是告诉对方它能够接收多少字节的数据，叫通告窗口；\n在给定的连接上应用进程在任何时刻既可以发送也可以接收数据。\nTCP三次握手","permalink":"https://www.sukun.xyz/socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3/","tags":["socket"],"title":"Socket网络编程详解"},{"categories":["常见问题"],"contents":"各位可能遇见过这样一个：Path 变量字符数超过1023个，无法再继续添加了。\n其实你可以另外新建一个环境变量（比如我的是myEnvExtension），然后在这个变量下添加你要添加的 Path，然后再在 Path 中添加一个变量值为 %myEnvExtension% 即可。\n","permalink":"https://www.sukun.xyz/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%AD%97%E7%AC%A6%E6%95%B0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","tags":["windows"],"title":"环境变量字符数解决方案"},{"categories":["web"],"contents":"Hugo博客系列（二） 本系列教程链接：\n 第一期 第二期  前言 上一期教程讲述了如何利用 GitHub pages 来部署，但我发现这并不是很好用。一是因为 GitHub pages 在国内访问速度较慢，二是百度不会收录 GitHub pages，这就导致了站点流量难以增长，但 Vercel 就不存在这些问题，因此我将本站迁移至了 Vercel。与此同时，还做了一些简单的美化操作。\n从 GitHub pages 迁移至 Vercel 首先前往 Vercel 官网，使用 GitHub 登录。\n未完待续\n","permalink":"https://www.sukun.xyz/hugo-2/","tags":["Hugo"],"title":"Hugo博客系列(二)"},{"categories":null,"contents":"主题作者 本网站采用 Hugo-LoveIt 主题，下方是主题作者的 GitHub 链接。\n\rDillon\r\"LoveIt主题作者\"\r\r\r\r大佬们 JAVA \r雨临Lewis的博客\r\"不想当写手的码农不是好咸鱼_(xз」∠)_\"\r\r\r\r本站友链信息 1 2 3 4  name=\u0026#34;Sukun的博客\u0026#34; url=\u0026#34;https://www.sukun.xyz\u0026#34; logo=\u0026#34;https://www.sukun.xyz/images/avatar.png\u0026#34; word=\u0026#34;Sukun的博客，记录学习历程！\u0026#34;   交换友链 注意  各位大佬想交换友链的话可以在下方留言，我看到后将以回复+邮件的形式通知！   你需要留下以下信息：\n1 2 3 4 5 6 7 8 9 10  //必填 name=\u0026#34;站点名称\u0026#34; //必填 url=\u0026#34;站点地址\u0026#34; //必填 logo=\u0026#34;你的站点图标或个人头像\u0026#34; //必填 word=\u0026#34;站点描述\u0026#34; //选填——默认分组是大佬们 group=\u0026#34;分组\u0026#34;   警告  如果贵站存在以下情况之一：\n链接失效、无法访问、删除本站友链、友链入口不易找到。\n我将删除贵站友链并邮件通知，直至贵站恢复正常为止！\n   ","permalink":"https://www.sukun.xyz/friends/","tags":null,"title":"友链墙"},{"categories":null,"contents":"   new Artitalk({ appId: 'LLhNra6D2fqcyOGJYWIrwoB8-MdYXbMMI', // Your LeanCloud appId appKey: '1m4bN4Gx2xYFmRwyrT1Y1qPa' // Your LeanCloud appKey })  ","permalink":"https://www.sukun.xyz/bbs/%E5%85%AC%E5%91%8A%E7%95%99%E8%A8%80/","tags":null,"title":"公告留言"},{"categories":["生活"],"contents":"站点日志 站点日志  不断更新中    2021年 2021年10月 大一参加学校工作室招新，购买了云服务器，顺便利用 WordPress 开通了我的第一个私人博客。（顺便提一嘴，服务器至今仍在跑青龙面板为我捞点豆子）\n2021年11月 嫌弃 WordPress 过于臃肿，且对技术锻炼程度不高，遂放弃 WordPress 转投 Hexo\n2022年 2022年1月 2022年1月1日 元旦第一天，突然想起那个开通了之后一直没写的博客，又发现 Hugo 在博客上是更好的选择，于是本网站就此诞生！\n2022年1月2日 开始写文章了！\n2022年1月3日 为网站添加了小游戏 mikutap。\n2022年1月4日 加入了抓猫小游戏，一起来抓猫呀！\n2022年1月5日 添加了更丰富的评论功能，采用 Waline 实现。\n添加了站点日志、友链墙。\n添加了 artitalk 实现的 BBS 功能——公告板/留言板！\n2022年1月6日 添加了站点持续时间功能。\n2022年1月7日 添加了搜索、GitHub conrner 、最近更新文章、上次更新时间功能\n把源码和网页文件分开为了两个仓库。\n2022年1月8日 将站点从 GitHub pages 迁移至了 Vercel。\n2022年1月20日 期末考完差不多1周了，寒假开卷！数据结构！大雾！微积分！\n这里分享一下我的数据结构学习资料：（西北大学）数据结构网课，LeetCode 刷题\n2022年1月27日 制作了两个小网页，有兴趣的可以看看第一个，第二个（都是拿大佬的作品改的，做着玩，代码里都有作者的链接）\n","permalink":"https://www.sukun.xyz/logs/","tags":["站点日志","生活"],"title":"站点日志"},{"categories":null,"contents":"一起来抓猫 点击圆点围住猫咪，别让它到达地图边缘！\n    window.game = new CatchTheCatGame({ w: 11, h: 11, r: 20, backgroundColor: 0xeeeeee, parent: 'catch-the-cat', statusBarAlign: 'center', credit: '一起来抓猫！' });  ","permalink":"https://www.sukun.xyz/games/catch-the-cat/","tags":null,"title":"Catch the Cat"},{"categories":["web"],"contents":"Hugo博客系列（一） 本系列教程链接：\n 第一期 第二期  前言 为什么要有自己的博客？ 写博文能很好地分享自己的想法，能记录生活，还能充当一个电子笔记的作用，有效防止今后某一天面对一个以前遇到过的问题但现在不会解决的情况出现。一篇好的博文能为你带来大量的流量，你可以在搜索引擎中搜索到自己，我相信这是一件足够令人雀跃的事情。并且你还能利用他做一篇网页简历，当你找工作时你可以有着更加花里胡哨的简历！除此以外，你还能通过交换友链建立一个优质的社交圈，因为大家都写了很多高质量的文章，你能与他们进行深入交流，这不像同学圈一样脆弱，它能稳定存在很久！\n在其他博客平台写作你讲或多或少地受到限制，想自己 DIY 页面还得向官方申请，甚至不会审批通过。而且你无法使用多种多样的第三方插件，还得面对审查，写的文章有可能被删除、撤回。有广告干扰，任谁也不喜欢看着一篇文章然后突然蹦出来一个广告吧？当然，你也可以自己接点广告在网站上。\n常见博客框架的选择 hexo hexo 以前影响力还不错，但这几年已经不如从前人们预判的那么发展的好了，GitHub 上 hexo 项目有着 34k 个 star 看出，其中最为出名的主题便是 Next，有着 15.7k 个 star，这也是因为 Next 目前是 hexo 主题中功能最齐全最好用的一个。而如此之多的人使用也就意味着 hexo 这个框架的作者用收到非常多的反馈，因此 hexo 更新优化做的很好，作者也很有动力继续做下去。\n但是这样的一个框架缺点也是有的：\n  环境配置麻烦\n因为要使用 hexo 你得在本地安装 Node.js、Git，会熟练使用 GitHub，而且由于 GitHub 的特殊性，你还得学会翻墙，不然还用不了，这就对一点基础都没有的小白不是很友好了。\n  无后端\n这意味着你没有一个后台还方便地对网站进行操作，只能通过先写好 Markdown 文件然后 Git 推送到云端。并且原生的 hexo 是没有评论系统的，想加评论还得找第三方评论系统。除此以外，一旦本地文件被你不小心删除掉了，那当你下次 push 的时候你之前的博文也就跟着丢失了。\n  渲染时间久\n200 篇左右的博文用 Hexo 需要 10 分钟去生成静态网页，当你写博客写的时间久了之后文章多了起来，相信我，你会无法忍受这种折磨。\n  总结：hexo 适合有一定基础的人，然后写博客时间不长或者只是随便写来玩的人。当然尤其其广泛的传播性，当你遇到问题的时候拿到网上去搜一般都是有解决方案的，这也可以为你省下一点力气。\n最后，如果你想用 hexo，我建议主题用 Next。\nHugo Hugo 几年前的影响力是不如 hexo 的，但现在越来越多的人从 hexo 迁移到了 Hugo，Hugo使用人数也多了起来，GitHub 上 Hugo 项目有 56.2k 个 star，已远远超过了 hexo，因此你也不用太担心 Hugo 会不会太小众化的问题，但是 Hugo 上的主题选择会更少一些，其中最受欢迎的是 wowchemy，但也仅有 6.1k 个star，而本站采用的是 LoveIt 主题，它的 star 就更少了，才 1.6k 个。当然，如果你是搞前端开发的，或者乐意自己写主题，那这些就不重要了。\nHugo优点：\n  速度快\nHugo 采用 Go 语言编写，它的速度用作者的话来形容就是世界上最快的构建网站工具。并且 Hugo 是即时渲染的，这意味着你可以边写边改样式，直到你满意为止。即使是你写了几百篇文章，它也能在几秒之内全部渲染完成。\n The world’s fastest framework for building websites\n   配置更为简单\n你需要安装只是 Hugo，不像 hexo 还得安装 Node.js。并且Hugo 中是不区分站点和主题的配置文件的，Hugo 中只有一个位于站点根目录下的 config.toml 配置文件，你只用在这里面进行修改就可以了。\n  方便自定义\n你可以在不修改主题文件的前提下方便地定制主题。在 Hugo 中，如果你想要定制主题，你只需在站点目录下新建相应的文件即可。这是非常利于主题的维护的，你只需使用 Git 的 submodule 的方式安装 Hugo 的主题，然后更新时只需直接在站点根目录下敲一条命令回车即可，非常方便！\n  缺点：\n主题比较少，很可能大家都是用的同一个主题，并且主题作者更新会更少一点。\n总结：如果你喜欢 DIY，我建议使用 Hugo。如果你是个专业博主，写了很多文章需要渲染，我建议使用 Hugo！\nTypecho 这是一个非常轻量级的博客框架，但是需要你拥有一个服务器。并且它对服务器要求极低，即使只有 512M 内存或是更低，它也能跑起来。它可以满足你对博客的基本需求，而且 Typecho 是带后端的，意味着只要你能上网，你就可以自由地写你的文章，不会被设备所拘束。当然，你将免除配置环境的苦恼。\n缺点：\n  更新慢\n奇慢无比，作者已经 9 年没有进行更新了，一些插件也已经不能用了。\n  自由度低\n你不能随心所欲地进行 DIY，当然，如果你只是用来写博客的话问题不是很大。\n  WordPress 世界上最受欢迎的建站工具！具体有多受欢迎？每三个网站就有一个是 WordPress 搭建，并且美国白宫自2017年起，其官网 Whitehouse.gov 网站的內容管理系統（Content management system，CMS）从 Drupal 换成 WordPress！\n WordPress 是一个以 PHP 和 MySQL 为平台的自由开源的博客软件和内容管理系统。WordPress 具有插件架构和模板系统。截至2018年4月，排名前1000万的网站中超过30.6%使用WordPress 。WordPress是最受欢迎的网站内容管理系统。全球有大约30%的网站(7亿5000个)都是使用WordPress架设网站的。WordPress 是目前因特网上最流行的博客系统。\n 并且 WordPress 并不只是可以用来写博客，它能用来打造一切你想要的网站，哪怕是用来建个电商网站也没有问题！\n优点：\n  超广泛传播性\n你在使用 WordPress 遇到的任何问题，你都可以在网上找到对应的解决方案，它的使用人数之多以至于每一个坑都有人替你趟过了！\n  DIY 自由度高，难度低\n你可以随心所欲地添加插件，WordPress 提供了大量的优质插件，甚至有大量的人就以制作 WordPress 上的插件谋生！\n  安装简单\n网上有非常多的 WordPress 一键安装脚本，你可以根据自己的需求进行选择，无需面对安装过程中的问题！并且其安装时间非常短，只需要5分钟就能搞定！\n  缺点：\n  需要有一定性能的服务器\nPHP，MySQL这些对服务器有一定的要求，会占用比较多的内存，它不像 Typecho 一样轻便。\n  太过臃肿，不简洁\n太多的功能与选择造成了页面的繁琐，并且你会对着页面一直修改，这不利于你专心地撰写博文。\n  总结：适合有服务器，懒得折腾环境配置，喜欢开箱即用的人。\nHugo快速上手教程 Hugo安装 首先，请前往 GitHub 上下载最新版的 Hugo 压缩包，Releases · gohugoio/hugo (github.com)，建议选择 extended 版本，这将更有利于后续的 DIY 操作！\n下载完成后解压到一个你认为合适的位置，然后把 hugo.exe 所在的文件夹添加至环境变量中的 Path 中即可。\n当然，你也可以采用源码编译的方式进行安装，这里就采用最简单的方法了。\n注意  如果你的path变量下的字符数达到了上限，你可以查看这篇文章中的解决方案。   检查一下上一步操作是否正确\n1  hugo version   然后找一个合适的文件夹，在该目录下输入以下指令新建一个 Hugo 项目\n1 2  hugo new site my_website cd my_website   Hugo主题选择、安装与快速上手 我这里采用 LoveIt 主题进行演示，事实上还有很多主题也很棒，比如 even、meme、wowchemy。\nLoveIt 主题的仓库是: https://github.com/dillonzq/LoveIt.\n你可以下载主题的 最新版本 .zip 文件 并且解压放到 themes目录.\n另外, 也可以直接把这个主题克隆到 themes 目录:\n1  git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt   或者, 初始化你的项目目录为 git 仓库, 并且把主题仓库作为你的网站目录的子模块:\n1 2  git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt   那么如何更新主题呢？\n1  git submodule update --rebase --remote   把 \\themes\\LoveIt\\exampleSite目录下的config.toml复制下来，替换掉站点根目录下的同名文件。\n然后对这个文件进行一些自定义修改。\n然后进入根目录下的archetypes文件夹中，修改default.md文件为下面的内容（这个文件是模板文件，通过指令创建的文章将以模板为基础内容）\n1 2 3 4 5 6 7 8 9 10 11 12 13  --- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} tags: [\u0026#34;\u0026#34;] categories: [\u0026#34;\u0026#34;] toc: enable: true description: draft: true --- \u0026lt;!--more--\u0026gt;   现在开始撰写文章\n1  hugo new posts/first_post.md   注意，后缀为md，建议使用 Typora 进行编辑。\n首先修改 frontmatter，其中title表示文章标题，date为生成文章当时的时间，tags为标签，categories为目录，toc enable为启用文章目录（需要自己在文章中生成），description为文章摘要，draft表示是否为草稿（写完了文章把这里改为 false 即可），\u0026lt;!--more--\u0026gt;为 LoveIt 主题的摘要标识符，该标识符上方的内容为文章摘要，如果上方为空，则采用 frontmatter 中设置的descriptions为文章摘要。\n例如本文的 frontmatter 为\n1 2 3 4 5 6 7 8  title:\u0026#34;Hugo博客系列(一)\u0026#34;date:2022-01-04T18:40:38+08:00tags:[\u0026#34;Hugo\u0026#34;]categories:[\u0026#34;web\u0026#34;]toc:enable:truedescription:本系列教程第一章讲解了几种常见的博客框架选择，最终以 Hugo 框架为基础，教授了如何在 GitHub pages 上部署个人博客，还使用 GitHub actions 以及一个简单的 bat 脚本实现自动化发布。draft:true  写完了文章进行网页的构建\n1  hugo serve -D -e production   -D表示草稿也要渲染，-serve表示启动一个本地服务器，即时渲染，方便修改。\n注意  hugo serve 的默认运行环境是 development, 而 hugo 的默认运行环境是 production。\n由于本地 development 环境的限制, 评论系统**, **CDN 和 fingerprint 不会在 development 环境下启用。\n你可以使用 hugo serve -e production 命令来开启这些特性。\n   值得一提的是不论输入的是server还是serve都是一样的。\n在浏览器中前往它给出的 http://localhost:1313 就能看到你刚生成的博客了。\n技巧  当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新.   现在再输入指令\n1  hugo -D   这会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上。\n确认无误后就要把它发到公网上了，这里采用 GitHub pages 进行部署（当然，也有很多种方法也能达成这一目的）\nGitHub pages部署 如果你是第一次使用 GitHub，请自行搜索如何配置，这里不做讲解！\n首先确保你有一个 GitHub 账号，然后新建一个仓库，名为yourname.github.io，注意，你应该保证这里的 your name 为你的 GitHub 账号名称！然后再进行以下步骤：\n1 2 3 4 5 6 7  cd public git init git remote add origin https://github.com/yourname/yourname.github.io.git #此URL可在你的repo中找到 git add . git commit -m \u0026#34;update %date%,%time%\u0026#34; git push origin master   如果一切顺利的话打开你的 GitHub repo，你就能看到相应的文件了，接着在 settings 页面中下滑，找到 GitHub pages，选择分支master，root路径，然后保存即可。如果你有自己的域名，还可以在下方的custom domain中输入你的域名，等待一段时间就可以用这个域名访问了。\n当然，在此之前你还需要再次修改config.toml文件中的baseURL为https://yourname.github.io，否则发布到网上也无法访问！\nGitHub actions实现自动部署(CI/CD) 是否觉得这个发布太过于繁琐了？别担心，这里提供两种解决方案！分别是本地 bat 脚本和GitHub actions。\n首先是本地 bat 脚本，这将免除每次发布都要敲至少 5 行指令的痛苦。只需要每次要发布的时候双击运行一下程序即可。\n1 2 3 4 5 6  hugo -D cd public git add . git commit -m \u0026#34;update %date%,%time%\u0026#34; git push origin master pause    另一种方法是前往 GitHub，新建一个仓库。\n点击Actions选择simple workflow，内容如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  name:CI#自动化的名称on:push:# push的时候触发branches:# 那些分支需要触发- masterjobs:build:runs-on:ubuntu-latest# 镜像市场steps:- name:checkout# 步骤的名称uses:actions/checkout@v2.3.4#软件市场的名称with:# 参数submodules:true- name:Setup Hugouses:peaceiris/actions-hugo@v2.4.13with:hugo-version:0.91.2extended:true- name:Buildrun:hugo -D- name:Deployuses:peaceiris/actions-gh-pages@v3with:deploy_key:${{ secrets.ACTIONS_DEPLOY_KEY }}EXTERNAL_REPOSITORY:14772/14772.github.io# 注意要修改本处地址PUBLISH_BRANCH:masterPUBLISH_DIR:./public  值得注意的是在最后一条Deploy中应使用with而非env，应使用deploy_key而非其他的名字。但目前网上大部分教程都没提及这一点，甚至有的还错误地使用！\n然后在本地输入以下命令在当前目录下生成密钥对\n1 2 3 4  ssh-keygen -t rsa -b 4096 -C \u0026#34;$(git config user.email)\u0026#34; -f gh-pages -N \u0026#34;\u0026#34; # You will get 2 files: # gh-pages.pub (public key) # gh-pages (private key)   -t rsa表示 rsa 加密，-b 4096则表示长度为 4096bit，-C后面的是备注，-f后面的是文件名，-N是新密语\n现在前往yourname.github.io仓库，选择Settings \u0026gt; Deploy keys \u0026gt; Add deploy key，勾选 Allow write access，内容为公钥(有pub字样的文件)\n再前往之前存放了master.yml文件的仓库，选择Settings \u0026gt; Secrets \u0026gt; New secret，名称填ACTIONS_DEPLOY_KEY，内容为私钥\n然后在站点根目录下执行以下命令\n1 2  git remote add origin https://github.com/yourname/yourrepo. #此repo为你放了master.yml文件的仓库   现在再来写一个 bat 脚本\n1 2 3  git add . git commit -m \u0026#34;update %date%,%time%\u0026#34; git push origin master   之后直接双击运行它就行了\n注意  如果你自定义了域名，那么你需要在站点根目录static文件夹下新建一个CNAME文件，内容为你的自定义域名！否则每次 deploy 后域名都会变成 yourname.github.io，达不到自定义的目的！   总结：第二种更复杂，但也更好，因为它将源文件也上传到了云端，便于多地更新博客，不至于丢失文章。并且，其在本地占用的内存更小（毕竟网页源代码全在云端），对于文章很多的朋友来说也更友好。\n","permalink":"https://www.sukun.xyz/hugo-1/","tags":["Hugo"],"title":"Hugo博客系列(一)"},{"categories":["计算机网络"],"contents":"浅析“翻墙” 警告  声明   撰写本文是出于学习计算机网络知识，解析技术以及简单普法的目的。不传播、售卖“翻墙”工具，不教授“翻墙”方法，本文也不出现“翻墙”教程。本人对网民浏览本文后做出的不理智行为概不负责！\n什么是“翻墙”？ 首先，我们要知道翻墙翻的是什么？答案是 GFW(Great Fire Wall)也就是长城防火墙。这里借用维基百科来解释：防火长城（英语：Great Firewall，常用简称：GFW），中文也称中国国家防火墙，俗称墙、网络长城、防火墙等等，中国国家互联网信息办公室称为数据跨境安全网关 ，是中华人民共和国政府监控和过滤互联网国际出口内容的软硬件系统集合。随着使用的拓广，“墙”有时也被用作动词，中国网友所说的“被墙”即指网站内容被防火长城所屏蔽或者指服务器的通讯被封阻，“翻墙”也被引申为突破网络审查浏览中国大陆境外被屏蔽的网站或使用服务的行为。\n为什么要“翻墙” 一方面，普通人翻墙原因如下：\n 使用国外的 app 和服务，例如看 YouTube，使用海外版腾讯视频（海外版往往比国内版体验感好，无广告简洁）。 好奇，想见识一下墙外的世界。（这点原因是主要因素，大多数人都是出于这一点） 满足在国内无法实现的欲望，比如逛 P 站（懂的都懂） 与外国人聊天，增长外语水平 做外贸，面外海外经商却不想支付昂贵的官方信道费用 \u0026hellip;\u0026hellip;  另一方面，作为一名程序员，其翻墙原因如下：\n 使用 GitHub，对于一名程序员来说，GitHub 算得上是必需品，根本离不开 逛 StackOverflow 社区，寻找 bug 解决方案 下载、使用专业工具，因为有些工具是海外的，国内没有替代品 查阅文档、学习技术 阅读科研论文、查询数据、与海外团队交流 \u0026hellip;\u0026hellip;  ”翻墙“犯法吗？ 需要明确的是，在这一问题上，国内暂无一个统一见解。但我个人观点是只要不传播、不扩散、不进行违法违规活动，不发表、不转发、不支持反动言论，只是简单地浏览，同时也没有人举报你翻墙了，那么警察也不会闲得来抓你。\n引用  《计算机信息网络国际互联网安全保护管理办法》（以下简称其为“办法”）第5条规定，任何单位和个人不得利用国际互联网制作、复制、查阅和传播下列信息：\n（一）煽动抗拒、破坏宪法和法律、行政法规实施的；\n（二）煽动颠覆国家政权，推翻社会主义制度的；\n（三）煽动分裂国家、破坏国家统一的；\n（四）煽动民族仇恨、民族歧视，破坏民族团结的；\n（五）捏造或者歪曲事实，散布谣言，扰乱社会秩序的；\n（六）宣扬封建迷信、淫秽、色情、赌博、暴力、凶杀、恐怖、教唆犯罪的；\n（七）公然侮辱他人或者捏造事实诽谤他人的；\n（八）损害国家机关信誉的；\n（九）其他违反宪法和法律、行政法规的。\n   如果按照上述规定，那么在翻墙过程中将难免会遇到不良内容，容易触犯该办法。而这也警示我们：不传播、不扩散、不进行有违法律法规的网络活动！\n另一方面，国内翻墙用户众多，所谓法不责众，如果按照翻墙即违法来处办的话，这对于警力要求过高。按照下图显示的份额来看，谷歌 2020 年在中国就有着 3.49% 的市场份额，而 2020 年中国网民共计 9.40亿，不难得出中国有3200万谷歌用户的数据，如果我们保守估计，以其中有一半的人都有着正规渠道访问谷歌（比如各高校、科研实验室、跨国公司、银行等有资质购买专线的），那么具有翻墙能力的人也有 1600 万之巨，这已经是一个庞大的数字，这也是国内对翻墙不再如从前那么敏感的原因之一。\n同时，近些年来国民的民族自豪感、国家认同感大幅提升，这一现象在年轻人身上表现尤为明显，恰如年轻一辈的口号“请党放心，强国有我”。这使得 GFW 封锁国民访问外网的一大原因——防止国外媒体恶意抹黑中国的言论对国民的思想造成影响——不怎么适用，因为国民不再容易被误导了，”国外的空气也不怎么香甜“。并且有能力进行翻墙的人大多数都是接受了高等教育的人，思想较为深刻，有稳固而正确的三观，放他们出去逛一逛问题也不是很大。\n当然了，如果你不是一个普通的翻墙用户，而是以此牟利，那你肯定触犯了法律，必将接受法律的制裁。一方面，你使得国家将面对更多的不可确定因素，因为受传播者不一定遵纪守法，你需要为此负责！\n引用  除了办法中的条例以外，对提供“翻墙”服务的卖家而言，《互联网信息服务管理办法》 规定的惩罚措施更重。\n第 4 条规定：“国家对经营性互联网信息服务实行许可制度；对非经营性互联网信息服务实行备案制度。未取得许可或者未履行备案手续的，不得从事互联网信息服务。”\n第 19 条规定：“违反本办法的规定，未取得经营许可证，擅自从事经营性互联网信息服务，或者超出许可的项目提供服务的，由省、自治区、直辖市电信管理机构责令限期改正，有违法所得的，没收违法所得，处违法所得 3 倍以上 5 倍以下的罚款；没有违法所得或者违法所得不足 5 万元的，处 10 万元以上 100 万元以下的罚款；情节严重的，责令关闭网站。”\n   总结：作为一名普通翻墙用户，只要老老实实地，不犯法。而如果你进行了违法乱纪的活动，或者是翻墙服务提供商或者教授、传播翻墙方法，那就犯法了！\n“翻墙”原理解析 要知道翻墙的原理，我们就得先知道GFW是如何把这堵墙树立起来，如何阻断不正常通信的。\nGFW的封锁 关键字过滤 由于 Http 协议数据包头部是明文的，所以 GFW 一旦发现连接有敏感词，马上就会伪装成连接两方，向真正的对方发送 RST 数据包（重置连接、复位连接），真正的双方一看，出现异常了，TCP连接就会中断掉。表现为有的页面正在打开，然后过了一会又没了，显示无法连接。\nIP封锁 GFW 可以在出境的网关上加一条伪造的路由规则，这样对于一些被过滤了的 IP 的数据包就无法正确地被送达，所以也就无法访问了。GFW 封路由是直接封独立 IP ，这样可能因为某个敏感站点，导致跟他同一台主机的其他站点也无法访问，理解起来就像旁注（从旁注入）。而且 GFW 封 IP 有的时候是直接封 IP 段的，国外几大 VPS 服务商（比如 Bandwagon 搬瓦工）更是重点监测，有时就因为其中一个 IP 不对，GFW 能给你把这整个机房里的服务器的 IP 全封了，当然这样一来难免会有无辜之人中枪。\nDNS污染、劫持 ​\tDNS 也就是域名解析服务，GFW 会对所有经过骨干出口路由的在 UDP 的 53 端口上的域名查询进行检测，一旦发现有黑名单里的域名，它就会伪装成目标域名的解析服务器给查询者返回虚假结果。由于 UDP 是一种无连接不可靠的协议，查询者只能接受最先返回的结果，故而你将看到明明地址栏中的 URL 是对的，但是浏览器渲染的却是不是目标网页或者干脆访问不了。\n特定端口封锁 对于一些特点的 IP ，GFW 会丢弃特定端口上的数据包，使得某些功能无法使用，比如 443 端口 SSL，22 端口的 SSH。\nGWF 曾经干过一件事，针对 Google 的一些 IP 上的 443 端口，实施间歇性封锁，不明所以的用户就会觉得这是 Google 抽风了，久而久之自然不能忍受 “老是出问题” 的产品。同样的还有 GitHub 的 443 端口、前段时间的 steam 的 443 端口也都被间歇性封锁了。\n值得一提的是这个一般是人为干预的，理由就是常发生在白天。加密连接干扰 加密连接不总是加密的，公钥还是明文的，所以 GFW 就能识别出特定服务的证书。然后在遇到 “黑名单” 加密连接时，它会发送RST数据包，干扰双方正常的 TCP 连接，进而切断加密连接的握手。\n主动嗅探 现在我们假设你能伪装你的流量，当它和其他流量混杂在一起时从外观上看没有什么区别，你以为这就可以高枕无忧了？错！事实上，GFW 是被动监测+主动嗅探来实现封锁的，即使一个流量没有任何翻墙特征，但是这股流量太大了，或者时间太长了，GFW 也将主动地发一个连接请求过去，由于这根本就是个假流量，连接返回的内容也不正常，GFW 一看就知道不对劲了，然后再来个人工检测，你不就暴露了么。另一方面，每逢政治敏感时期（比如每年两会、国庆、建党节）或者每年 6 月的大扫除时期，这个时期人工检测大大增多， GFW 敏感系数提升，更容易发现不正常流量，并且从前稳妥起见，只是怀疑还怕误杀的流量，放在这个时期就大概率给你封了。\n对抗GFW的技术 直接访问IP GFW 不是对域名进行各种干扰吗，现在我直接绕过域名解析，对那些还进入监控名单的 IP 直接访问就能躲开 GFW 的干扰。但是很可惜 GFW 对付这种方法的策略也很简单粗暴但有效，那就是见一个封一个。比如早些年谷歌在国内还能正常访问靠的就是大量的镜像 IP，但随着这些年来 GFW 的不懈努力，谷歌服务的 IP 已经被杀绝了。这种办法的失效也就是个时间问题，因为人家封锁只需要找到 IP 然后加入黑名单就行，而被封锁的一方的要付出的努力就大得多了。\nVPN隧道 首先我们明确，虚拟专用网络（VPN）是一门网络技术，而非一个软件，它为我们提供了一种通过公用网络(如最大的公用因特网)安全地对企业内部专用网络进行远程访问的连接方式。在 VPN 隧道中通信能确保通信通道的专用性，并且传输的数据是经过压缩、加密的，所以VPN通信同样具有专用网络的通信安全性。VPN 原本用意是为了让人不在公司也能访问公司内网，但其优越的安全性也让他也有了对抗 GFW 的功能，这里不展开讲解。但是值得注意的是，那些名叫某某加速器、某某 VPN 的翻墙工具往往都不咋地，而且还有跑路的风险，甚至有的还是“家庭小作坊”，而那些大的服务商提供的虽然稳定速度快，但是又是重点监测，譬如某海外服务商的 VPN 长期坚挺，一直加 IP 来对抗 GFW ，但代价就是价格高昂。就像这张图讲的道理：\n代理服务器 这里故意把 VPN 和代理分开，事实上 VPN 也是代理的一种，但其在网络七层协议中跑在数据链路层/第二层，而socks5、Trojan、v2ray之类的则是在OSI七层模型中的第五层/会话层的，（ HTTP 在第七层/应用层， Ping 指令使用 ICMP 协议，工作于第三层/网络层）。而更低层可以代理更高层，更高层代理不了更底层。表现出来的则是你挂了梯子（非 VPN 类）发现依然没法加速 LOL 等游戏（游戏跑网络层），这也是你再挂了梯子之后依然可以用 Ping 来看主机与服务器直接的延迟的原因。但如果开了 VPN ，那他可以加速游戏，可以代理 ICMP 指令。\n说完了 VPN 与这里说的代理的区别，现在再来说常见的几种“翻墙”代理协议。\n注意  世界上没有永远安全的协议，所谓道高一尺，魔高一丈，这是一场长期的军备竞赛，双方都在不断推陈出新！   Socks5 协议与 HTTP 协议 Socks5 把你的网络数据由代理服务器转发到目的地，这个过程中你是没有一条专用通道的，只是数据包的发出，然后被代理服务器收到，然后代理服务器再进行转发，整个过程并没有额外的处理。\n但是在连接建立时、传输流量过程中有着极为明显的流量特征。因此网上也不乏唱衰 Socks5 协议的声音，甚至有流言称 Socks5 协议已被 GFW 攻破，能被其拿捏，但目前暂无明确证据，同时 Socks5协议依然是用的最多的代理协议，因此我对这种观点持保留观点。\n对抗措施：流量加密、反检测、免杀\n Socks5 + HTTP 代理并不会让本来明文传输的浏览加密，但是可以改变请求的 IP，服务器看到访问者的 IP 就是你的代理代理服务器的IP。 如果流量本身没有加密，实战中流控设备很容易识别到客户端连接成功的流量规则。 如果想要加密 Socks5 的流量，则需要安装魔改版 Socks 服务端和客户端，比如著名的 SS/SSR 就是用 Socks5 来实现的，Cobalt Strike 也有相关插件对流量进行加密。  v2ray协议 VMess协议 VMess 协议是由 V2Ray 原创并使用于 V2Ray 的加密传输协议，如同 Shadow socks 一样为了对抗墙的深度包检测而研发的。在 V2Ray 上客户端与服务器的通信主要是通过 VMess 协议通信。\nVLESS协议 VLESS 是一种无状态的轻量级数据传输协议，被定义为下一代 V2ray 数据传输协议。作者对该协议的愿景是“可扩展性空前，适合随意组合、全场景广泛使用，符合很多人的设想、几乎所有人的需求，足以成为 v2ray 的下一代主要协议，乃至整个 XX 界的终极协议。”，由此可见 VLESS 协议的强大。\n注意  VLESS 命名源自“less is more”，写法与 VMess 近似   VLESS和VMESS区别如下：\n VLESS协议不依赖于系统时间，不使用 alterId 。一些人的 V2ray 用不了，最后找出原因是电脑时间和服务器只相差两分钟，简直要让人抓狂；VLESS 协议去掉了时间要求，双手举赞； VLESS 协议不带加密，用于科学上网时要配合TLS等加密手段； VLESS 协议支持分流和回落，比 Nginx 分流转发更简洁、高效和安全； 使用TLS的情况下，VLESS 协议比 VMESS 速度更快，性能更好，因为 VLESS 不会对数据进行加解密； V2ray 官方对 VLESS 的期望更高，约束也更严格。例如要求客户端统一使用 VLESS 标识，而不是 Vless 、vless 等名称；VLESS 分享链接标准将由官方统一制定（尚未出炉）； VLESS 协议的加密更灵活，不像 VMESS 一样高度耦合（仅对开发者有用）  对于普通用户来说，VLESS 协议的主要优势是：1. 不需要客户端和服务器时间一致； 2. VLESS 协议不自带加密，使用 TLS 的情况下性能比 VMESS 更好。\nXTLS协议 XTLS官方库 的介绍仅有一句话：THE FUTURE。V2fly 官网（V2fly 社区是 V2ray 技术的主要推动力量） 称 XTLS为黑科技，VLESS协议作者的形容是：划时代的革命性概念和技术。\nXTLS 的原理是：使用 TLS 代理时，https 数据其实经过了两层 TLS：外层是代理的 TLS，内层是 https 的 TLS。XTLS 无缝拼接了内外两条货真价实的 TLS，使得代理几乎无需再对 https 流量进行数据加解密，只起到流量中转的作用，极大的提高了性能。\nVLESS + XTLS 的组合可以理解为是增强版 ECH，即多支持身份认证、代理转发、明文加密、UDP over TCP 等。但从其原理可知，VLESS + XTLS对http流量是没有多大优势的。好消息是，目前超过 90% 的流量都是 https 的，因此 VLESS + XTLS 能极大的提升性能，无愧于上面的评价。\n注意  需要说明的是，XTLS 是科学上网的 future ，不是 TLS 发展的 future。   Trojan协议 Trojan 协议简单来说是通过 TLS 协议（安全传输层协议）伪装成访问 HTTPS（超文本传输协议）的正常流量。由于 TLS 是一个完整的加密协议通过目前的任何技术手段都无法得到其加密内容，所以 Trojan 的安全性可见一斑。但目前 Trojan 还属于是一个新兴的技术，在各方面都存在问题，但其有着最值得期待的未来，我们需要做的是给予其时间，让其成长。\n在安全性方面，GFW 的主动嗅探主要是其接入目标服务器进行数据检测，而 Trojan 和其他协议不同，当 GFW 接入时不会主动断开介入服务，而是会将接入点连接到一个常规的 web 服务器。这个时候 GWF 就会以为这个服务器是一个常规服务器，从而做出错误的判断。当然，如果是人工来检测，进行了精密的流量分析的话 Trojan 也无能为力。\n找 GFW 的 BUG 这个比较少，就是寻找 GFW 的漏洞，然后依次为突破点来翻墙，这里我也没怎么了解，不做展开。\n注意  最后，如果你有任何想法，欢迎来评论区告诉我！  ","permalink":"https://www.sukun.xyz/%E6%B5%85%E6%9E%90%E7%BF%BB%E5%A2%99/","tags":["翻墙"],"title":"浅析翻墙"},{"categories":["计算机网络"],"contents":"Socket网络编程详解 本部分内容在此不做详细讲解，具体请看这篇文章\n简单的TCP通信代码详解 Server Client TCP网络通信室代码详解","permalink":"https://www.sukun.xyz/tcp%E9%80%9A%E4%BF%A1python%E5%AE%9E%E7%8E%B0/","tags":["python","Socket"],"title":"TCP通信Python实现"},{"categories":null,"contents":"博主相关情况 电科在读学子，软工专业\n兴趣爱好：\n 游戏（PC、手游） 热爱技术 看剧（不多）  主要研究方向：运维\n联系方式：\n email :1477264431@qq.com csdn :https://blog.csdn.net/sk14772 GitHub :https://github.com/14772  创建博客目的 创建本博客主要用于记录学习过程，并防止后面学着学着忘了以前学的内容\n本站相关情况 hugo v0.91.2-1798BD3F+extended windows/amd64 BuildDate=2021-12-23T15:33:34Z VendorInfo=gohugoio\nLoveIt: v0.2.10\n","permalink":"https://www.sukun.xyz/about/","tags":null,"title":"About"},{"categories":["web"],"contents":"快速建站  公网访问 docker部署 SSL证书部署 负载均衡  买好一个 VPS ，拿到 ip 地址和管理员密码，ssh 登录上去\n这里采用 docker 部署，首先利用官方脚本安装 docker 并设置开机自启动\n1 2 3  curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh sudo systemctl enable docker   然后启动 Nginx 镜像的容器，把宿主机8080，8443端口转发到容器的80，443端口\n1  docker run -dit --name web -p 8080:80 -p 8443:443 nginx   然后访问一下ip:8080能看到Nginx欢迎界面\n现在进入容器进行配置，首先是安装 vim ，然后写一个简单的网页文件\n1 2 3 4 5  docker exec -it web bash apt update apt install vim cd /etc/nginx/conf.d vim default.conf   然后修改Nginx配置文件中的 root 位置，修改 server_name 为你要绑定的域名，再重启 Nginx 服务（nginx 配置文件详解见文末）\n1  nginx -s reload   这一步完成后就可以看见你写的网页了\n这里考虑到只有一台服务器，因此我的负载均衡思路是搭建Nginx集群，把刚刚写的配置文件和网页文件拷贝到每一个容器中，配置负载均衡，让其中一个容器成为主服务器\n现在要做的就是把配置文件和网页文件拷贝到宿主机中。(这里我登录的 root 用户，所以拷贝到了 root 目录下)然后再映射这两个文件夹到新创建的Nginx集群的每个容器中去。\n1 2 3 4 5 6  docker cp web:/etc/nginx ~/conf docker cp web:/var/www/html ~/html docker run -d -it -p 8081:80 -p 8444:443 --name web1 -v ~/conf:/etc/nginx -v ~/html:/var/www/html nginx docker run -d -it -p 8082:80 -p 8445:443 --name web2 -v ~/conf:/etc/nginx -v ~/html:/var/www/html nginx   这里以web容器为主服务器，首先查看他们的ip地址，然后编辑web的Nginx配置文件（这里顺手把原来的web容器删除，以映射的方式重建了一下，这样就能直接编辑宿主机中的文件就能编辑到映射到容器中的文件）\n1 2  docker network ls docker network inspect f1c912c35ca8   现在就能根据得到的ip地址编辑web容器的default.conf文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  upstream 172.17.0.2 { server 172.17.0.3 weight=1; server 172.17.0.4 weight=2; } server { listen 80; listen 443 ssl; server_name sukunblog.cn sukunblog.cn 172.17.0.2; ssl_certificate /etc/nginx/sukunblog.cn.pem; ssl_certificate_key /etc/nginx/sukunblog.cn.key; ssl_session_timeout 10m; ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; ssl_ciphers ECDHE-RSA-AES128-GCMSHA256: ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_prefer_server_ciphers on; client_max_body_size 1024m; location / { root /var/www/html; index Hello.html; proxy_set_header HOST $host; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://172.17.0.2; } }   Nginx 配置文件详解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333  ######Nginx配置文件nginx.conf中文详解#####  #定义Nginx运行的用户和用户组 user www www; #nginx进程数，建议设置为等于CPU总核心数。 worker_processes 8; #全局错误日志定义类型，[ debug | info | notice | warn | error | crit ] error_log /usr/local/nginx/logs/error.log info; #进程pid文件 pid /usr/local/nginx/logs/nginx.pid; #指定进程可以打开的最大描述符：数目 #工作模式与连接数上限 #这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。 #现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。 #这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。 worker_rlimit_nofile 65535; events { #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型  #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。  #补充说明：  #与apache相类，nginx针对不同的操作系统，有不同的事件模型  #A）标准事件模型  #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll  #B）高效事件模型  #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。  #Epoll：使用于Linux内核2.6版本及以后的系统。  #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。  #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。  use epoll; #单个进程最大连接数（最大连接数=连接数*进程数）  #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。  worker_connections 65535; #keepalive超时时间。  keepalive_timeout 60; #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。  #分页大小可以用命令getconf PAGESIZE 取得。  #[root@web001 ~]# getconf PAGESIZE  #4096  #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。  client_header_buffer_size 4k; #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。  open_file_cache max=65535 inactive=60s; #这个是指多长时间检查一次缓存的有效信息。  #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.  open_file_cache_valid 80s; #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。  #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location 这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.  open_file_cache_min_uses 1; #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.  open_file_cache_errors on; } #设定http服务器，利用它的反向代理功能提供负载均衡支持 http { #文件扩展名与文件类型映射表  include mime.types; #默认文件类型  default_type application/octet-stream; #默认编码  #charset utf-8;  #服务器名字的hash表大小  #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.  server_names_hash_bucket_size 128; #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。  client_header_buffer_size 32k; #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。  large_client_header_buffers 4 64k; #设定通过nginx上传文件的大小  client_max_body_size 8m; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。  #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。  sendfile on; #开启目录列表访问，合适下载服务器，默认关闭。  autoindex on; #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用  tcp_nopush on; tcp_nodelay on; #长连接超时时间，单位是秒  keepalive_timeout 120; #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。  fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; #gzip模块设置  gzip on; #开启gzip压缩输出  gzip_min_length 1k; #最小压缩文件大小  gzip_buffers 4 16k; #压缩缓冲区  gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）  gzip_comp_level 2; #压缩等级  gzip_types text/plain application/x-javascript text/css application/xml; #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。  gzip_vary on; #开启限制IP连接数的时候需要使用  #limit_zone crawler $binary_remote_addr 10m;  #负载均衡配置  upstream piao.jd.com { #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。  server 192.168.80.121:80 weight=3; server 192.168.80.122:80 weight=2; server 192.168.80.123:80 weight=3; #nginx的upstream目前支持4种方式的分配  #1、轮询（默认）  #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。  #2、weight  #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。  #例如：  #upstream bakend {  # server 192.168.0.14 weight=10;  # server 192.168.0.15 weight=10;  #}  #2、ip_hash  #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。  #例如：  #upstream bakend {  # ip_hash;  # server 192.168.0.14:88;  # server 192.168.0.15:80;  #}  #3、fair（第三方）  #按后端服务器的响应时间来分配请求，响应时间短的优先分配。  #upstream backend {  # server server1;  # server server2;  # fair;  #}  #4、url_hash（第三方）  #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。  #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法  #upstream backend {  # server squid1:3128;  # server squid2:3128;  # hash $request_uri;  # hash_method crc32;  #}  #tips:  #upstream bakend{#定义负载均衡设备的Ip及设备状态}{  # ip_hash;  # server 127.0.0.1:9090 down;  # server 127.0.0.1:8080 weight=2;  # server 127.0.0.1:6060;  # server 127.0.0.1:7070 backup;  #}  #在需要使用负载均衡的server中增加 proxy_pass http://bakend/;  #每个设备的状态设置为:  #1.down表示单前的server暂时不参与负载  #2.weight为weight越大，负载的权重就越大。  #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误  #4.fail_timeout:max_fails次失败后，暂停的时间。  #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。  #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。  #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug  #client_body_temp_path设置记录文件的目录 可以设置最多3层目录  #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡  } #虚拟主机的配置  server { #监听端口  listen 80; #域名可以有多个，用空格隔开  server_name www.jd.com jd.com; index index.html index.htm index.php; root /data/www/jd; #fastcgi解析php  location ~ .*.(php|php5)?$ { #此处有两种方式去和php-fpm交互,一种是9000端口,另一种是使用socket连接  fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; } #图片缓存时间设置  location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$ { expires 10d; } #JS和CSS缓存时间设置  location ~ .*.(js|css)?$ { expires 1h; } #日志格式设定  #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；  #$remote_user：用来记录客户端用户名称；  #$time_local： 用来记录访问时间与时区；  #$request： 用来记录请求的url与http协议；  #$status： 用来记录请求状态；成功是200，  #$body_bytes_sent ：记录发送给客户端文件主体内容大小；  #$http_referer：用来记录从那个页面链接访问过来的；  #$http_user_agent：记录客户浏览器的相关信息；  #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。  log_format access \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; $http_x_forwarded_for\u0026#39;; #定义本虚拟主机的访问日志  access_log /usr/local/nginx/logs/host.access.log main; access_log /usr/local/nginx/logs/host.access.404.log log404; #对 \u0026#34;/\u0026#34; 启用反向代理  location / { proxy_pass http://127.0.0.1:88; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #以下是一些反向代理的配置，可选。  proxy_set_header Host $host; #允许客户端请求的最大单文件字节数  client_max_body_size 10m; #缓冲区代理缓冲用户端请求的最大字节数，  #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。  #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误  client_body_buffer_size 128k; #表示使nginx阻止HTTP应答代码为400或者更高的应答。  proxy_intercept_errors on; #后端服务器连接的超时时间_发起握手等候响应超时时间  #nginx跟后端服务器连接超时时间(代理连接超时)  proxy_connect_timeout 90; #后端服务器数据回传时间(代理发送超时)  #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据  proxy_send_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时)  #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）  proxy_read_timeout 90; #设置代理服务器（nginx）保存用户头信息的缓冲区大小  #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小  proxy_buffer_size 4k; #proxy_buffers缓冲区，网页平均在32k以下的设置  #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k  proxy_buffers 4 32k; #高负荷下缓冲大小（proxy_buffers*2）  proxy_busy_buffers_size 64k; #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长  #设定缓存文件夹大小，大于这个值，将从upstream服务器传  proxy_temp_file_write_size 64k; } #设定查看Nginx状态的地址  location /NginxStatus { stub_status on; access_log on; auth_basic \u0026#34;NginxStatus\u0026#34;; auth_basic_user_file confpasswd; #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。  } #本地动静分离反向代理配置  #所有jsp的页面均交由tomcat或resin处理  location ~ .(jsp|jspx|do)?$ { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080; } #所有静态文件由nginx直接读取不经过tomcat或resin  location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt| pdf|xls|mp3|wma)$ { expires 15d; } location ~ .*.(js|css)?$ { expires 1h; } } } ######Nginx配置文件nginx.conf中文详解#####   ","permalink":"https://www.sukun.xyz/%E7%AE%80%E6%98%93%E5%BB%BA%E7%AB%99/","tags":["Nginx"],"title":"简易建站"},{"categories":null,"contents":"","permalink":"https://www.sukun.xyz/search/","tags":null,"title":"Search"}]